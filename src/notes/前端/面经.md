# html/css



# JavaScript



# vue

### 1.请系统讲讲 Vue2 与 Vue3 的核心差异（响应式、API 设计、性能与编译器）。



Vue2 和 Vue3 的核心差异主要体现在以下几个方面：



**1. 响应式系统（底层原理的根本性变化）**



| **特性**     | **Vue2**                                                     | **Vue3**                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **底层实现** | 使用 **`Object.defineProperty`**                             | 使用 **`Proxy`** API                                         |
| **检测限制** | 无法监听对象属性的**新增**和**删除**，需要使用 `$set` 或 `$delete` 。 | 可以直接监听对象属性的**新增**和**删除**，不需要特殊 API。   |
| **数组检测** | 需要重写数组原型方法（如 `push`, `pop` ,`shift`,`unshift`,`splice`,`sort`,`reverse`）。 | `可以通过 `Proxy` 直接拦截数组操作，支持数组索引访问和修改。` |

**`Proxy` 的优势：** 提供了完整的对象代理能力，性能更好，且解决了 Vue2 中无法追踪新增/删除属性的痛点。

```
<template>
  <div>
    <h1>个人信息</h1>
    <h2>name:{{ student.name }}</h2>
    <h2 v-show="student.sex">sex:{{ student.sex }}</h2>
    <h2 v-show="student.height">height:{{ student.height }}</h2>
    <h2>hobby:{{ student.hobby }}</h2>

    <button @click="addproperty">添加身高属性</button>
    <button @click="deleteproperty">删除性别属性</button>
    <button @click="changeproperty">修改爱好属性</button>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      student: {
        name: "zk",
        sex: "male",
        hobby: ["drink", "walk"],
      },
    };
  },
  // 3_src_vue2响应式原理
  methods: {
    addproperty() {
      console.log(this.student);
      // 在vue2环境下，添加成功，但是页面并不会响应更新
      console.log(this.student.height);
      // this.student.height = "170";
      console.log(this.student.height);
      // 解决办法,记得在vue2环境下执行
      this.$set(this.student, "height", 170);
      // 问题：使用数组下标添加不会响应生效
      // this.student.hobby[0] = "play";
      // 解决
      this.student.hobby.splice(0, 0, "paly");
    },
    changeproperty() {
      // 问题：使用数组下标添加不会响应生效
      // this.student.hobby[0] = "play";
      // 解决
      this.student.hobby.splice(0, 1, "paly");
    },
    deleteproperty() {
      // 同样在vue2环境下，页面不能够及时响应
      // delete this.student.sex;
      // 解决办法
      this.$delete(this.student, "sex");
    },
  },
};
</script>

<style></style>

```



**2. 组件编写方式（代码组织方式的变化）**



| **特性**       | **Vue2**                                                     | **Vue3**                                                     |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **API 风格**   | **选项式 API (Options API)**：将逻辑分散到不同的选项中（`data`、`methods`、`computed`、`watch` 等） 。 | **组合式 API (Composition API)**：通过 `setup` 函数，将同一功能的逻辑集中写在一起 。 |
| **逻辑复用**   | 主要通过 `Mixins` 实现，容易造成命名冲突和数据来源不清晰。   | 通过自定义 **`Hooks`** (例如：`useMousePosition`) 实现，逻辑清晰，类型推导友好（配合 TypeScript 6）。 |
| **TypeScript** | 对 TS 支持不友好，需要额外的装饰器或工具。                   | 对 TS 支持是**原生**的， Composition API 更容易进行类型推导 7。 |



**组合式 API (Composition API) 的优势：** 提高了大型项目逻辑的可读性、可维护性和复用性，特别适合复杂组件的开发 8。





**3. 性能优化与打包体积**



| **特性**     | **Vue2**                          | **Vue3**                                                     |
| ------------ | --------------------------------- | ------------------------------------------------------------ |
| **编译优化** | 缺少静态提升，全量虚拟 DOM 比对。 | **静态提升 (Static Hoisting)** 和 **块级 (Block Tree) 优化**。 |
| **虚拟 DOM** | 全量遍历比对 VDOM 树。            | 编译时标记静态内容，运行时只比对**动态**部分，减少了不必要的比对，提升了渲染性能。 |
| **打包体积** | 难以进行彻底的 **Tree-shaking**。 | 许多内部模块（如 `Transition`、`KeepAlive`）是按需导入的，配合 Composition API，能实现更彻底的 Tree-shaking，减小打包体积。 |





**总结**

1. **响应式系统**：

   - **Vue 2**：基于Object.defineProperty，无法自动检测**对象属性的添加/删除**和**数组索引变化**，需借助Vue.set/Vue.delete等特殊 API。
   - **Vue 3**：基于Proxy，**原生支持**对对象和数组的各种变化监听，无上述限制，性能更优。

2. **API 设计**：

   - **Vue 2 (Options API)**：按选项（data,methods等）组织代码，逻辑分散。复用代码使用 **Mixins**，容易引发命名冲突。
   - **Vue 3 (Composition API)**：按**逻辑功能**组织代码，相关代码集中，更利于维护和阅读。复用代码使用**自定义 Hook 函数**，清晰灵活，且**原生 TypeScript 支持极佳**。

3. **性能与编译器**：

   - Vue 3

      在编译阶段进行了大量优化：

     - **Tree-shaking**：未使用的 API 不会打包进最终产物，体积更小。
     - **Patch Flags**：编译时标记动态节点，Diff 算法时直接定位变化，大幅提升虚拟 DOM 比对效率。
     - **静态提升**：将静态节点缓存，跳过重复渲染。

   - 结果：Vue 3 在**打包体积、更新性能、内存占用**上均优于 Vue 2。

4. **新特性**：

   - **Vue 3** 新增了 **Teleport**（将组件渲染到指定DOM）、**Fragment**（支持多根节点模板）等特性，解决了常见开发痛点。

