# html/css




## JavaScript

### 1.说说JavaScript中的数据类型？存储上的差别？
在`JavaScript`中，我们可以分成两种类型：
- 基本类型
- 复杂类型
两种类型的区别是：存储位置不同
==基本类型==
基本类型主要为以下6种：

- Number
- String
字符串可以使用双引号（"）、单引号（'）或反引号（\`）标示，字符串是不可变的，意思是一旦创建，它们的值就不能变了
- Boolean
`Boolean`（布尔值）类型有两个字面值： `true` 和`false`,通过`Boolean`可以将其他类型的数据转化成布尔值
- Undefined
`Undefined` 类型只有一个值，就是特殊值 `undefined`。当使用 `var`或 `let`声明了变量但没有初始化时，就相当于给变量赋予了 `undefined`值。
包含`undefined` 值的变量跟未定义变量是有区别的

```js
let message; // 这个变量被声明了，只是值为 undefined

console.log(message); // "undefined"
console.log(age); // 没有声明过这个变量，报错
```
- null
`Null`类型同样只有一个值，即特殊值 `null`,逻辑上讲， null 值表示一个空对象指针
- symbol

他可以最为唯一的对象属性名称，作为 Symbol **最重要**的用途。由于每个 Symbol 都是唯一的，可以避免属性名冲突。

**场景：** 为对象添加"元数据"或"隐藏属性"

```
// 不同的库或模块可能都想给对象添加属性
const user = { name: 'Alice' };

// 模块A想添加一个标识
const MODULE_A_FLAG = Symbol('moduleA');
user[MODULE_A_FLAG] = true;

// 模块B也想添加类似的标识
const MODULE_B_FLAG = Symbol('moduleB'); 
user[MODULE_B_FLAG] = 'processed';

// 两个属性不会冲突，即使描述相同也不会冲突
const ANOTHER_FLAG = Symbol('moduleA'); // 描述相同但Symbol不同
user[ANOTHER_FLAG] = 'another';

console.log(user);
//控制台输出的信息可以观察到，第一个和第三个描述key都是一样的，但是实际上他们是完全独立的，
// {
//   name: 'Alice',
//   [Symbol(moduleA)]: true,
//   [Symbol(moduleB)]: 'processed',
//   [Symbol(moduleA)]: 'another'
// }
//对于同名key该如何访问呢？
console.log(user[MODULE_A_FLAG]) //true
console.log(user[ANOTHER_FLAG])  //another
```





==引用类型==
复杂类型统称为`Object`，我们这里主要讲述下面三种：

- Object
- Array
- Function

==存储区别==
基本数据类型和引用数据类型存储在内存中的位置不同：

- 基本数据类型存储在栈中    
- 引用类型的对象存储于堆中



1. **基本数据类型 (Primitives):**
   - 存在栈里。
   - `let a = 10;` 栈上的 `a` 变量就**直接**保存着 `10` 这个**值**。
2. **引用数据类型 (References):**
   - **地址**在栈里。
   - **值**（即对象 `{...}` 或数组 `[...]` 本身）在堆里。
   - `let obj = { name: 'Tom' };` 栈上的 `obj` 变量保存的是一个**地址**（比如 `0x1A2B`），这个地址指向堆内存中存储 `{ name: 'Tom' }` 的那个位置。



- **栈 (Stack)** 是高度有序的，必须严格遵循**后进先出 (LIFO)** 的规则来分配和释放，就像叠盘子，非常高效。
- **堆 (Heap)** 就像一个大仓库，当你需要存东西（创建对象）时，系统就在仓库里找个**大小足够的空位**把东西放进去，它不需要按顺序放。因此，它的内存分配是**动态**且相对**无序**的。



==小结==

- 声明变量时不同的内存地址分配：
    - 简单类型的值存放在栈中，在栈中存放的是对应的值
    - 引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址
- 不同的类型数据导致赋值变量时的不同：
    - 简单类型赋值，是生成相同的值，两个对象对应不同的地址
    - 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象



### 2.数组常用的方法有哪些

现总结：
- 数组和字符串的转换方法：`toString()`、`toLocalString()`、`join()` 其中 `join()` 方法可以指定转换为字符串时的分隔符。

```js
console.log(num.toString()); // "123"
//返回对象的本地化字符串表示，根据语言环境和地区设置格式化。
const number = 1234567.89;
console.log(number.toString()); // "1234567.89"
console.log(number.toLocaleString()); // 中文环境："1,234,567.89"
console.log(number.toLocaleString('de-DE')); // 德语环境："1.234.567,89"
console.log(number.toLocaleString('ar-EG')); // 阿拉伯语环境："١٬٢٣٤٬٥٦٧٫٨٩"
```



- 数组尾部操作的方法 `pop()` 和 `push()`，`push` 方法可以传入多个参数。

- 数组首部操作的方法 `shift()` 和 `unshift()` ，重排序的方法 `reverse()` 和 `sort()`，`sort()` 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。

- 数组连接的方法 `concat()` ，返回的是拼接好的数组，不影响原数组。

- 数组截取办法 `slice()`，用于截取数组中的一部分返回，不影响原数组。

- 数组插入方法 `splice()`，影响原数组查找特定项的索引的方法`indexOf()` 和 `lastIndexOf()` ，迭代方法 `every()`、`some()`、`filter()`、`map()` 和`forEach()`方法

```
//every用于判断元素是否全部都满足条件，任何一个不满足就返回false
const numbers1 = [1, 2, 3, 4, 5];
const allPositive = numbers1.every(num => num > 0);
console.log(allPositive); // true

some()- 至少有一个元素满足条件

filter()- 过滤留下满足条件的元素
map()- 映射/转换每个元素
```

- 数组归并方法 `reduce()` 方法

```js
// 使用reduce
const sumReduce = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(sumReduce); // 15
```

- **改变原数组的方法**：`fill()`、`pop()`、`push()`、`shift()`、`splice()`、`unshift()`、`reverse()`、`sort()`；

```
array.fill(value, start, end)
// 填充整个数组
const arr1 = new Array(5).fill(0);
console.log(arr1); // [0, 0, 0, 0, 0]
```



- **不改变原数组的方法**：`concat()`、`every()`、`filter()`、`find()`、`findIndex()`、`forEach()`、`indexOf()`、`join()`、`lastIndexOf()`、`map()`、`reduce()`、`reduceRight()`、`slice()`、`some()`。



>增删查改

数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生
影响，哪些方法不会
==增==
下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响

- push()
  `push()`方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
- unshift()
  unshift()在数组开头添加任意多个值，然后返回新的数组长度
- splice()
  传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组
- concat(）
  首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组





==删==

下面三种都会影响原数组，最后一项不影响原数组：

- pop()
  `pop()` 方法用于删除数组的最后一项，同时减少数组的`length` 值，返回被删除的项
- shift()、
  `shift()`方法用于删除数组的第一项，同时减少数组的`length` 值，返回被删除的项
- splice()
  传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组
- slice(）
slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组

==改==
splice
传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响
==查==
即查找元素，返回元素坐标或者元素值

- indexOf()
返回要查找的元素在数组中的位置，如果没找到则返回 -1
- includes()
返回要查找的元素在数组中的位置，找到返回`true`，否则`false`
- find()
返回第一个匹配的元素
>排序方法


数组有两个方法可以用来对元素重新排序：
- reverse()
顾名思义，将数组元素方向反转
- sort()
sort()方法接受一个比较函数，用于判断哪个值应该排在前面
```js
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
let values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); // 0,1,5,10,15
```


>转换方法

join
join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串

```js
let colors = ["red", "green", "blue"];
alert(colors.join(",")); // red,green,blue
alert(colors.join("||")); // red||green||blue
```

>迭代方法
- some()
对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let someResult = numbers.some((item, index, array) => item > 2);
console.log(someResult) // true
```
- every()
对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let everyResult = numbers.every((item, index, array) => item > 2);
console.log(everyResult) // false
```
- forEach()
没有返回值
- filter()
对数组每一项都运行传入的函数，函数返回 `true` 的项会组成数组之后返回
- map()
对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组



```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let mapResult = numbers.map((item, index, array) => item * 2);
console.log(mapResult) // 2,4,6,8,10,8,6,4,2
```

### 3.字符串常用的方法
==增==
这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作
除了常用`+`以及`${}`进行字符串拼接之外，还可通过`concat`

```js
concat
let stringValue = "hello ";
let result = stringValue.concat("world");
console.log(result); // "hello world"
console.log(stringValue); // "hello"
```

==删==
这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作
常见的有：

- slice()
- substr()
- substring()

这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。

```js
let stringValue = "hello world";
console.log(stringValue.slice(3)); // "lo world"
console.log(stringValue.substring(3)); // "lo world"
console.log(stringValue.substr(3)); // "lo world"
console.log(stringValue.slice(3, 7)); // "lo w"
console.log(stringValue.substring(3,7)); // "lo w"
console.log(stringValue.substr(3, 7)); // "lo worl"
```
==改==
这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作
常见的有：

- trim()、trimLeft()、trimRight()
删除前、后或前后所有空格符，再返回新的字符串
```js
let stringValue = " hello world ";
let trimmedStringValue = stringValue.trim();
console.log(stringValue); // " hello world "
console.log(trimmedStringValue); // "hello world"
```
- repeat()
```js
let stringValue = "na ";
let copyResult = stringValue.repeat(2) // na na 
```
- padStart()、padEnd()
复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件
```js
let stringValue = "foo";
console.log(stringValue.padStart(6)); // " foo"
console.log(stringValue.padStart(9, ".")); // "......foo"
```
- toLowerCase()、 toUpperCase()



==查==
除了通过索引的方式获取字符串的值，还可通过：

- chatAt()
返回给定索引位置的字符，由传给方法的整数参数指定

```js
let message = "abcde";
console.log(message.charAt(2)); // "c"
```
- indexOf()
从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）

```js
let stringValue = "hello world";
console.log(stringValue.indexOf("o")); // 4
```
- startWith()
- includes()
从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值

```js
let message = "foobarbaz";
console.log(message.startsWith("foo")); // true
console.log(message.startsWith("bar")); // false
console.log(message.includes("bar")); // true
console.log(message.includes("qux")); // false
```
==转换方法==
把字符串按照指定的分割符，拆分成数组中的每一项

```js
let str = "12+23+34"
let arr = str.split("+") // [12,23,34]
```

==模板匹配方法==
针对正则表达式，字符串设计了几个方法：

- match()
接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，返回数组。
```js
let text = "cat, bat, sat, fat";
let pattern = /.at/;
let matches = text.match(pattern);
console.log(matches[0]); // "cat"
```
- search()
接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，找到则返回匹配索引，否则返回 -1

```js
let text = "cat, bat, sat, fat";
let pos = text.search(/at/);
console.log(pos); // 1
```
- replace()
接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）
```js
let text = "cat, bat, sat, fat";
let result = text.replace("at", "ond");
console.log(result); // "cond, bat, sat, fat"
```

### 4. 谈谈js中的类型转换机制
常见的类型转换有：
- 强制转换（显示转换）

- 自动转换（隐式转换）

  

  ==显示转换==
  显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：

- Number()

- parseInt()

- String()

- Boolean(）

**number()**
将任意类型的值转化为数值
先给出类型转换规则：
实践一下：

```js
Number(324) // 324
// 字符串：如果可以被解析为数值，则转换为相应的数值
Number('324') // 324
// 字符串：如果不可以被解析为数值，返回 NaN
Number('324abc') // NaN
// 空字符串转为0
Number('') // 0
// 布尔值：true 转成 1，false 转成 0
Number(true) // 1
Number(false) // 0
// undefined：转成 NaN
Number(undefined) // NaN
// null：转成0
Number(null) // 0
// 对象：通常转换成NaN(除了只包含单个数值的数组)
Number({a: 1}) // NaN
Number([1, 2, 3]) // NaN
Number([5]) // 5
```

从上面可以看到，`Number`转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`
**parseint**
`parseInt`相比`Number`，就没那么严格了，`parseInt`函数逐个解析字符，遇到不能转换的字符就停下来

```js
parseInt('32a3') //32
```

**string**
可以将任意类型的值转化成字符串
实践一下：

```js
// 数值：转为相应的字符串
String(1) // "1"
//字符串：转换后还是原来的值
String("a") // "a"
//布尔值：true转为字符串"true"，false转为字符串"false"
String(true) // "true"
//undefined：转为字符串"undefined"
String(undefined) // "undefined"
//null：转为字符串"null"
String(null) // "null"
//对象
String({a: 1}) // "[object Object]"
String([1, 2, 3]) // "1,2,3"
```

**Boolean**

```js
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```

==隐式转换==
在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？

我们这里可以归纳为两种情况发生隐式转换的场景：

- 比较运算（`==`、`!=`、`>`、`<`）、`if`、`while`需要布尔值地方
- 算术运算（`+`、`-`、`*`、`/`、`%`）

除了上面的场景，还要求运算符两边的操作数不是同一类型
**自动转换为布尔值**
在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用`Boolean`函数

可以得出个小结：
- undefined

- null

- false

- +0

- -0

- NaN

- ""
  除了上面几种会被转化成`false`，其他都换被转化成`true`

  

**自动转换为字符串**

遇到预期为字符串的地方，就会将非字符串的值自动转为字符串

具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串

常发生在`+`运算中，一旦存在字符串，则会进行字符串拼接操作

```js
'5' + 1 // '51'
'5' + true // "5true"
'5' + false // "5false"
'5' + {} // "5[object Object]"
'5' + [] // "5"
'5' + function (){} // "5function (){}"
'5' + undefined // "5undefined"
'5' + null // "5null"
```
**自动转换为数值**
除了`+`有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值

```js
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN
```



###  5.\==和\=\==区别，分别在什么情况下使用

==\==操作符==
等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 `true`

前面文章，我们提到在`JavaScript`中存在隐式转换。等于操作符（\==）在比较中会先进行类型转换，再确定操作数是否相等。

遵循以下规则：

如果任一操作数是布尔值，则将其转换为数值再比较是否相等

```js
let result1 = (true == 1); // true
```

如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等

```js
let result1 = ("55" == 55); // true
```

如果一个操作数是对象，另一个操作数不是，则调用对象的 `valueOf()`方法取得其原始值，再根据前面的规则进行比较

```js
let obj = {valueOf:function(){return 1}}
let result1 = (obj == 1); // true
```

`null`和`undefined`相等

```js
let result1 = (null == undefined ); // true
```

如果有任一操作数是 `NaN` ，则相等操作符返回 `false`

```js
let result1 = (NaN == NaN ); // false
```

如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回`true`

```js
let obj1 = {name:"xxx"}
let obj2 = {name:"xxx"}
let result1 = (obj1 == obj2 ); // false
```

下面进一步做个小结：

- 两个都为简单类型，字符串和布尔值都会转换成数值，再比较
  
- 简单类型与引用类型比较，对象转化成其原始类型的值，再比较
  
- 两个都为引用类型，则比较它们是否指向同一个对象
  
- null 和 undefined 相等
  
- 存在 NaN 则返回 false

==\=\==操作符==
全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 `true`。即类型相同，值也需相同

```
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`undefined` 和 `null` 与自身严格相等

```
let result1 = (null === null)  //true
let result2 = (undefined === undefined)  //false
```

==区别==
相等操作符（\==）会做类型转换，再进行值的比较，全等运算符不会做类型转换

```
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`null` 和 `undefined` 比较，相等操作符（\==）为`true`，全等为`false`

```js
let result1 = (null == undefined ); // true
let result2 = (null  === undefined); // false
```

==总结==
相等运算符隐藏的类型转换，会带来一些违反直觉的结果

```js
'' == '0' // false
0 == '' // true
0 == '0' // true

false == 'false' // false
false == '0' // true

false == undefined // false
false == null // false
null == undefined // true

' \t\r\n' == 0 // true
```

但在比较`null`的情况的时候，我们一般使用相等操作符`==`

```js
const obj = {};

if(obj.x == null){
  console.log("1");  //执行
}
```

等同于下面写法

```js
if(obj.x === null || obj.x === undefined) {
    ...
}
```

使用相等操作符（\==）的写法明显更加简洁了

所以，除了在比较对象属性为`null`或者`undefined`的情况下，我们可以使用相等操作符（\==），其他情况建议一律使用全等操作符（\=\==）

---



### 6. 深拷贝和浅拷贝的区别？如何实现深拷贝？


下面简单实现一个浅拷贝

```js
function shallowClone(obj) {
    const newObj = {};
    for(let prop in obj) {
        if(obj.hasOwnProperty(prop)){
            newObj[prop] = obj[prop];
        }
    }
    return newObj;
}
只是复制了地址，如果对深层次的数据进行修改，源数据也会发生变化。
只是复制了第一层属性/元素的值引用，而不复制嵌套对象或数组的内部结构。
```

hasOwnProperty 是 JavaScript 中 **对象原型方法**（Object.prototype.hasOwnProperty），它的作用是：

> **判断一个属性是否是对象“自身的属性”（own property），而不是从原型链上继承来的。**

JavaScript 是基于**原型继承**的语言，对象可以从原型链上继承属性。

```
const obj = { name: 'Alice' };
```
obj 除了有 name 属性外，还能访问 toString、hasOwnProperty 等方法，这些是继承自 Object.prototype 的。

```
'name' in obj;           // true  ← 自身属性
'toString' in obj;       // true  ← 继承来的！
```
使用 in 操作符**无法区分**是自身属性还是继承属性。
而 hasOwnProperty **只检查自身**：

```
obj.hasOwnProperty('name');       // true
obj.hasOwnProperty('toString');   // false ←--不是自身的
```

在`JavaScript`中，存在浅拷贝的现象有：

- `Object.assign`
- `Array.prototype.slice()`, `Array.prototype.concat()`
- 使用拓展运算符实现的复制

Object.assign

```
var obj = {
    age: 18,
    nature: ['smart', 'good'],
    names: {
        name1: 'fx',
        name2: 'xka'
    },
    love: function () {
        console.log('fx is a great girl')
    }
}
var newObj = Object.assign({}, fxObj);
newObj.nature[0]='abc'
console.log(obj.nature[0]) //'abc',被修改了。
```

slice()

```
const arr = [1, { name: 'Alice' }, [10, 20]]; //这是一个数组，不是类数组对象

const copy = arr.slice();
copy[1].name = 'Bob'; console.log(arr[1].name); // 'Bob' ← 原数组也被改了！

```

concat()

```
const arr = [1, { age: 25 }];
const copy = arr.concat(); // 等价于 [].concat(arr)
copy[1].age = 30; 
console.log(arr[1].age); // 30 ← 共享引用

```

拓展运算符

```
const obj = { a: 1, b: { x: 10 }, c: [1, 2] };
const copy = { ...obj };
copy.b.x = 99; 
console.log(obj.b.x); // 99 ← 原对象被改了！

```

==深拷贝==
深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

- _.cloneDeep()
  
- jQuery.extend()
  
- JSON.stringify()
  
- 手写循环递归
  

**\_cloneDeep**

```js
const _ = require('lodash');
//- 引入 **Lodash** 库，一个流行的 JavaScript 工具库。
- _ 是 Lodash 的默认导出对象，包含大量实用函数。
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
```

**jQuery.extend()**

```js
const $ = require('jquery');
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

**JSON.stringfy()**

```js
const obj2=JSON.parse(JSON.stringify(obj1））
//先把对象转换为JSON字符串，序列化
//在把JSON字符串转换为js对象，反序列化
//得到一个与 obj1 结构相同、但完全独立的新对象（深拷贝）
```

但是这种方式存在弊端，会忽略`undefined`、`symbol`和`函数`
```js
const obj = {
    name: 'A',
    name1: undefined,
    name3: function() {},
    name4:  Symbol('A')
}
const obj2 = JSON.parse(JSON.stringify(obj));
console.log(obj2); // {name: "A"}
```

**递归循环**
```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```

###  7. 什么是闭包？应用场景有哪些？

==什么是闭包==

在一个函数环境中，，闭包=函数+词法环境。
在 JavaScript（前端最常用的语言）里，**闭包（Closure）**指的是 **函数 + 它能够访问的外层函数作用域中的变量** 的组合。

**先总结：**

**闭包优点：**

- 创建全局私有变量，避免变量全局污染
- 可以实现封装、缓存等

**闭包缺点：**

- 创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出
  - **解决：** 在不需要使用的时候把变量设为`null`

**使用场景：**

- 用于创建全局私有变量
- 封装类和模块
- 实现函数柯里化

闭包一定会造成内存泄漏吗？

闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。只要合理的使用闭包，就不会造成内存泄漏。







它的核心价值在于：

1. **数据私有化 / 封装** 让变量只能被内部函数访问，外部无法直接读取或修改，实现“私有成员”。
2. **保持状态（记忆功能）** 每次调用闭包函数时，都能“记住”之前创建时的环境变量，实现计数器、缓存、配置等持久化状态。
3. **模块化 / 避免全局污染** 通过立即执行函数（IIFE）或模块模式，把实现细节隐藏，只暴露必要的 API。
4. **实现柯里化、函数工厂、事件绑定、回调等高级模式**

1.数据私有化,保持状态

```js
function createCounter() {
  let count = 0;               // 私有变量
  return function () {         // 闭包
    return ++count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// 外部无法直接访问 count
console.log(typeof count); // undefined
```
**解释**

- count 只在 createCounter 的词法环境中。
- 返回的匿名函数形成了闭包，**记住**了 count。
- 每次调用 counter() 都会操作同一个 count，实现私有计数器。

2.函数工厂（柯里化）

```js
function makeAdder(base) {
  return function (x) {
    return base + x;   // 记住 base
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(3));  // 8
console.log(add10(3)); // 13
```

3.模块函数
```JS
const MyModule = (function () {
  // 私有数据
  const API_KEY = 'abc123';
  const cache = {};

  // 私有方法
  function _fetch(url) {
    if (cache[url]) return cache[url];
    // 模拟异步请求
    return fetch(url + '?key=' + API_KEY).then(res => {
      cache[url] = res;
      return res;
    });
  }

  // 暴露的公共 API
  return {
    get: _fetch,
    clearCache() {
      for (let k in cache) delete cache[k];
    }
  };
})();

MyModule.get('/data').then(console.log);
MyModule.clearCache();
```


==应用场景==


| 作用          | 典型场景                  | 关键点                 |
| ------------- | ------------------------- | ---------------------- |
| **数据私有**  | 计数器、配置对象          | 外部不可直接访问变量   |
| **保持状态**  | 防抖/节流、缓存           | 闭包记住上一次调用环境 |
| **模块化**    | IIFE 模块、ES6 前私有成员 | 只暴露 API             |
| **循环/事件** | for 循环绑定事件          | 用闭包捕获每次迭代的值 |

==会不会造成内存泄露==
闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。如果后续还需要使用这个闭包变量，那么就没有造成泄露。

---



### 8.谈谈你对作用域链的理解

==一、作用域==
作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合
换句话说，作用域决定了代码区块中变量和其他资源的可见性
举个例子
```
function myFunction() {
    let inVariable = "函数内部变量";
}
myFunction();//要先执行这个函数，否则根本不知道里面是啥
console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined
```

上述例子中，函数`myFunction`内部创建一个`inVariable`变量，当我们在全局访问这个变量的时候，系统会报错
这就说明我们在全局是无法获取到（闭包除外）函数内部的变量
我们一般将作用域分成：

- 全局作用域
  
- 函数作用域
  
- 块级作用域
**1.全局作用域**

任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问
```
// 全局变量
var greeting = 'Hello World!';
function greet() {
  console.log(greeting);
}
// 打印 'Hello World!'
greet();
```

**2.函数作用域**

函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问

```
function greet() {
  var greeting = 'Hello World!';
  console.log(greeting);
}
// 打印 'Hello World!'
greet();
// 报错： Uncaught ReferenceError: greeting is not defined
console.log(greeting);
```

可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域

**3.块级作用域**

ES6引入了`let`和`const`关键字,和`var`关键字不同，在大括号中使用`let`和`const`声明的变量存在于块级作用域中。在大括号之外不能访问这些变量

```
{
  // 块级作用域中的变量
  let greeting = 'Hello World!';
  var lang = 'English';
  console.log(greeting); // Prints 'Hello World!'
}
// 变量 'English'
console.log(lang);
// 报错：Uncaught ReferenceError: greeting is not defined
console.log(greeting);
```

==二、词法作用域==
词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，`JavaScript` 遵循的就是词法作用域。函数访问外部变量时，依据的是函数定义时的位置，而不是调用时的位置。

```
var a = 2;
function foo(){
    console.log(a)
}
function bar(){
    var a = 3;
    foo(); //2
}
bar()
```

由于`JavaScript`遵循词法作用域，相同层级的 `foo` 和 `bar` 就没有办法访问到彼此块作用域中的变量，所以输出2
==三、作用域链==
当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域

如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错

这里拿《你不知道的Javascript(上)》中的一张图解释：

把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域。

变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止

下面代码演示下：

```
var sex = '男';
function person() {
    var name = '张三';
    function student() {
        var age = 18;
        console.log(name); // 张三
        console.log(sex); // 男 
    }
    student();
    console.log(age); // Uncaught ReferenceError: age is not defined
}
person();
```

上述代码主要主要做了以下工作：

- `student`函数内部属于最内层作用域，找不到`name`，向上一层作用域`person`函数内部找，找到了输出“张三”
- `student`内部输出`sex`时找不到，向上一层作用域`person`函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男”
- 在`person`函数内部输出`age`时找不到，向上一层作用域找，即全局作用域，还是找不到则报错



---


### 9.JS原型、原型链？有什么特点？

==1.原型==
`JavaScript` 常被描述为一种基于原型的语言——每个对象拥有一个原型对象

当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的`prototype`属性上，而非实例对象本身

下面举个例子：

函数可以有属性。 每个函数都有一个特殊的属性叫作原型`prototype`

```
function doSomething(){}
console.log( doSomething.prototype );
```

控制台输出

```
{
    constructor: ƒ doSomething(),
    __proto__: {
        constructor: ƒ Object(),
        hasOwnProperty: ƒ hasOwnProperty(),
        isPrototypeOf: ƒ isPrototypeOf(),
        propertyIsEnumerable: ƒ propertyIsEnumerable(),
        toLocaleString: ƒ toLocaleString(),
        toString: ƒ toString(),
        valueOf: ƒ valueOf()
    }
}
```

上面这个对象，就是大家常说的原型对象

可以看到，原型对象有一个自有属性`constructor`，这个属性指向该函数，如下图关系展示
![image-20251116222532494](D:\A_keep_learning\markdown笔记\前端\assets\image-20251116222532494.png)





==2.原型链==
原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法

在对象实例和它的构造器之间建立一个链接（它是`__proto__`属性，是从构造函数的`prototype`属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法

下面举个例子：

```
function Person(name) {
    this.name = name;
    this.age = 18;
    this.sayName = function() {
        console.log(this.name);
    }
}
// 第二步 创建实例
var person = new Person('person')
```



下面分析一下：

- 构造函数`Person`存在原型对象`Person.prototype`
  
- 构造函数生成实例对象`person`，`person`的`__proto__`指向构造函数`Person`原型对象
  
- `Person.prototype.__proto__` 指向内置对象，因为 `Person.prototype` 是个对象，默认是由 `Object`函数作为类创建的，而 `Object.prototype` 为内置对象
  
- `Person.__proto__` 指向内置匿名函数 `anonymous`，因为 Person 是个函数对象，默认由 Function 作为类创建
  
- `Function.prototype` 和 `Function.__proto__`同时指向内置匿名函数 `anonymous`，这样原型链的终点就是 `null`

==3.总结==
下面首先要看几个概念：

`__proto__`作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的

每个对象的`__proto__`都是指向它的构造函数的原型对象`prototype`的

```
person1.__proto__ === Person.prototype
```

构造函数是一个函数对象，是通过 `Function`构造器产生的

```
Person.__proto__ === Function.prototype
```

原型对象本身是一个普通对象，而普通对象的构造函数都是`Object`

```
Person.prototype.__proto__ === Object.prototype
```

刚刚上面说了，所有的构造器都是函数对象，函数对象都是 `Function`构造产生的

```
Object.__proto__ === Function.prototype
```

`Object`的原型对象也有`__proto__`属性指向`null`，`null`是原型链的顶端

```
Object.prototype.__proto__ === null
```

下面作出总结：

- 一切对象都是继承自`Object`对象，`Object` 对象直接继承根源对象`null`
  
- 一切的函数对象（包括 `Object` 对象），都是继承自 `Function` 对象
  
- `Object` 对象直接继承自 `Function` 对象
  
- `Function`对象的`__proto__`会指向自己的原型对象，最终还是继承自`Object`对象

---



### 10.JS如何实现继承

==1.继承是什么？==
继承（inheritance）是面向对象软件技术当中的一个概念。
如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类”
- 继承的优点
继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码
在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能
虽然`JavaScript`并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富
关于继承，我们举个形象的例子：
定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等

```
class Car{
    constructor(color,speed){
        this.color = color
        this.speed = speed
        // ...
    }
}
```

由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱

```
// 货车
class Truck extends Car{
    constructor(color,speed){
        super(color,speed)
        this.Container = true // 货箱
    }
}
```

这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性

在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法

```
class Truck extends Car{
    constructor(color,speed){
        super(color,speed)
        this.color = "black" //覆盖
        this.Container = true // 货箱
    }
}
```

从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系
==2.实现方式==

下面给出`JavaScripy`常见的继承方式：

- 原型链继承
- 构造函数继承（借助 call）
- 组合继承
- 原型式继承
- 寄生式继承
- 寄生组合式继承


> 原型链继承

原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针

举个例子

```
 function Parent() {
    this.name = 'parent1';
    this.play = [1, 2, 3]
  }
  function Child() {
    this.type = 'child2';
  }
  //这里的指的就是上面的Child函数，也就是构造方法。
  Child.prototype = new Parent();
  console.log(new Child())
```

![image-20251116222635970](D:\A_keep_learning\markdown笔记\前端\assets\image-20251116222635970.png)
上面代码看似没问题，实际存在潜在问题

```
var s1 = new Child();
var s2 = new Child();
s1.play.push(4);
console.log(s1.play, s2.play); // [1,2,3,4]
```

改变`s1`的`play`属性，会发现`s2`也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的


>构造函数继承（借助 call）

借助 `call`调用`Parent`函数

```
function Parent(){
    this.name = 'parent1';
}
//给原型对象设置了一个属性方法getName
Parent.prototype.getName = function () {
    return this.name;
}

function Child(){
//- **在 Child 内部，把 Parent 当成普通函数执行，但强制把 Parent 里的 `this` 指向当前正在创建的 Child 实例**。
//结果：每个 Child 实例都会**复制一份** `name` 属性，**不会共享**。
    Parent.call(this);
    this.type = 'child'
}

let child = new Child();
console.log(child);  // 没问题
//`child` 自己身上确实有了 `name`，但**并没有继承 Parent.prototype 上的方法**。
console.log(child.getName());  // 会报错
```

借用构造函数继承**只能“搬”父类构造函数里的实例属性**，**搬不到父类原型上的方法**；  

因此**引用属性不共享**是优点，**原型方法丢失**是缺点。

相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法


>组合继承

将构造函数继承和原型链继承组合到一起
```js
┌-------- ① 定义部分 --------┐
function Parent(){
    this.name   = 'parent';
    this.play   = [1,2,3];     // 引用类型
}
Parent.prototype.getName = function(){
    return this.name;
};

function Child(){
    Parent.call(this);        // ② 第二次调用 —— 为每个实例复制一份 name + play,覆盖了第一次调用的原型链提供的name和play，从此属性不再共享了。
    this.type = 'child3';
}

Child.prototype = new Parent();  // ① 第一次调用 —— 为原型链提供 getName,name,play
//构造函数在初始化的时候，会默认分配一个原型对象，该原型对象内容为{constructor:Child...}
//现在我们强行改变了原型对象为Parent实例，现在新的原型对象内容为Child.prototype也就是parent实例对象，实例对象没有constructor属性，这里我们就手动创建一个，让其纠正为Child，而不是通过--proto--原型链
//找到parent的构造函数
Child.prototype.constructor = Child;

┌-------- ③ 使用部分 --------┐
var s3 = new Child();
var s4 = new Child();
s3.play.push(4);
console.log(s3.play); // [1,2,3,4]
console.log(s4.play); // [1,2,3]   ←— 互不影响 ✅
console.log(s3.getName()); // 'parent' ✅
```

把“属性”和“方法”拆成两条跑道

| 要继承的东西                                                 | 存在位置                | 该用哪种手段                             |
| :----------------------------------------------------------- | :---------------------- | :--------------------------------------- |
| **实例属性**（name、play 等）                                | 父类构造函数体内        | 借用构造函数  <br>`Parent.call(this)`    |
| **原型方法**（getName 等）                                   | 父类 `Parent.prototype` | 原型链继承  <br>`Child.prototype = 对象` |
| 这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到`Parent` 执行了两次，造成了多构造一次的性能开销 |                         |                                          |


> 原型式继承

这里主要借助`Object.create`方法实现普通对象的继承

```
let parent = {
    name: "parent",
    friends: ["p1", "p2", "p3"],
    getName: function() {
      return this.name;
    }
  };

  let person = Object.create(parent);
  //相当于
  //let person={}
  //person.__proto__=parent
  
  person.name = "tom";
  person.friends.push("jerry");

  let person = Object.create(parent);
  person.friends.push("lucy");

  console.log(person.name); // tom
  console.log(person.name === person.getName()); // true
  console.log(person.name); // parent
  console.log(person.friends); // ["p1", "p2", "p3","jerry","lucy"]
  console.log(person.friends); // ["p1", "p2", "p3","jerry","lucy"]
```

这种继承方式的缺点也很明显，因为`Object.create`方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能

Object.create 把**普通对象直接当原型**；  

值类型属性“读共享、写复制”，引用类型属性“读写都共享”；  

想不互串，就要在子对象里**重新赋值整个数组**，而不是**原地修改**。
想要让friends也独立，这样做

```javascript
let person4 = Object.create(parent);
person4.friends = [...parent.friends]; // 复制一份再改
person4.friends.push('jerry');
```


>寄生式继承


寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法
```js
let parent = {
    name: 'parent',
    friends: ['p1','p2','p3'],
    getName() { return this.name; }
};

function clone(original) {
    // ① 浅拷贝：新建对象，并把 original 设为其原型
    let clone = Object.create(original);

    // ② 增强：给这个副本额外挂一个方法
    clone.getFriends = function () {
        return this.friends;   // 这里的 this 指向运行时调用者
    };

    return clone;              // 返回“加强版”对象
}

let person = clone(parent);
```

- `getName` 沿原型链找到 `parent.getName`
  
- `getFriends` 是**直接挂在 person 自己身上**的方法，因此**每个克隆体都有一份新函数**（内存开销比原型方式大）。

```javascript
console.log(person.getName());    // parent
console.log(person.getFriends()); // ["p1","p2","p3"]
```
好绕呀，没看明白。


>寄生组合式继承

寄生组合式继承，借助解决普通对象的继承问题的`Object.create` 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式

```
function clone (parent, child) {
    // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
}

function Parent6() {
    this.name = 'parent6';
    this.play = [1, 2, 3];
}
Parent6.prototype.getName = function () {
    return this.name;
}
function Child6() {
    Parent6.call(this);
    this.friends = 'child5';
}

clone(Parent6, Child6);

Child6.prototype.getFriends = function () {
    return this.friends;
}

let person6 = new Child6();
console.log(person6); //{friends:"child5",name:"child5",play:[1,2,3],__proto__:Parent6}
console.log(person6.getName()); // parent6
console.log(person6.getFriends()); // child5
```

可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题

文章一开头，我们是使用`ES6` 中的`extends`关键字直接实现 `JavaScript`的继承

```
class Person {
  constructor(name) {
    this.name = name
  }
  // 原型方法
  // 即 Person.prototype.getName = function() { }
  // 下面可以简写为 getName() {...}
  getName = function () {
    console.log('Person:', this.name)
  }
}
class Gamer extends Person {
  constructor(name, age) {
    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
    super(name)
    this.age = age
  }
}
const asuna = new Gamer('Asuna', 20)
asuna.getName() // 成功访问到父类的方法
```

利用`babel`工具进行转换，我们会发现`extends`实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。
晕

---



### 11.instanceof 运算符的实现原理及实现
该运算符通过原型链检查判断对象是否属于特定类型。当执行 `key instanceof Array` 返回 `true` 时，说明变量 `key` 的原型链中存在 `Array.prototype`，即 `key` 是通过数组构造函数创建的实例。

`instanceof` 原理一句话：

> **不断拿右边构造函数的原型（`prototype`），去跟左边对象的整条原型链（`__proto__`）做全等比对**，只要有一次命中就返回 `true`，走到 `null` 还没命中就返回 `false`。

模拟实现（ES5 版，20 行不到）

```javascript
function myInstanceOf(left, right) {
  // 基本类型直接出局
  if (left === null || (typeof left !== 'object' && typeof left !== 'function')) {
    return false;
  }

  // 取目标原型
  const target = right.prototype;

  // 兼容 IE 非标准 __proto__
  left = left.__proto__;

  while (left !== null) {
    if (left === target) return true;
    left = left.__proto__; // 继续往上爬
  }
  return false;
}


```



快速验证

```javascript
function Foo() {}
const f = new Foo();

console.log(myInstanceOf(f, Foo));      // true
console.log(myInstanceOf(f, Object));   // true
console.log(myInstanceOf([], Array));   // true
console.log(myInstanceOf(123, Number)); // false
```

---

### 12.typeof 和 instanceof 区别

一句话先给结论：  

**`typeof` 只能告诉你“基本类型”或“是不是函数”；**  

**`instanceof` 只能告诉你“对象是谁构造的，沿着原型链找”。**

| 对比维度     | typeof                                                       | instanceof                                      |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------- |
| 返回值       | `'string' \| 'number' \| 'boolean' \| 'undefined' \| 'function' \| 'object' \| 'symbol' \| 'bigint'` | `true / false`                                  |
| 判断依据     | 机器码低位（Tag）                                            | 原型链（`__proto__` 能否找到 `Ctor.prototype`） |
| 适合基本类型 | ✅ 精准                                                       | ❌ 报错或 false（非对象）                        |
| 适合对象细分 | ❌ 统称 `'object'` 或 `'function'`                            | ✅ 精准识别数组、日期、自定义类等                |
| 常见坑       | `typeof null === 'object'`                                   | 跨 iframe 原型链断裂会 false                    |

```javascript
typeof 42;                           // 'number'
typeof 'abc';                        // 'string'
typeof null;                         // 'object'（历史 bug）
typeof [];                           // 'object'
typeof function f(){};               // 'function'

[] instanceof Array;                 // true
[] instanceof Object;                // true
new Date() instanceof Date;          // true
/abc/ instanceof RegExp;             // true
```

------------------------------------------------
一句话总结（写卷子上）

> **基本类型用 `typeof`，对象细分用 `instanceof`（例如Object，Arrary，Function，Date，Error，Map，set）；**  
> **两者互补，绝不重叠。**

---

### 13.null和undefined的区别
`Undefined` 和 `Null` 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 `undefined` 和 `null`。

- **undefined** 代表的含义是**未定义**，一般变量**声明了但还没有定义**的时候会返回 `undefined`，`typeof`为`undefined`
- **null** 代表的含义是**空对象**，null主要用于赋值给一些可能会返回对象的变量，作为初始化，`typeof`为`object`



```
null == undefined // true 
null === undefined //false
```

  ### 14.为什么0.1+0.2!\==0.3

  因为0.1和0.2是浮点数，转换为二进制，是无限不循环小数，计算机中只能存储有限位数，所以会被截断，导致
  ```js
0.1 + 0.2 === 0.30000000000000004 // true
  ```
解决办法：
1.对于简单的可以先乘10的倍数，将其转换为整数，然后再加合，最后除回来。
2.使用to.Fixed(1)

```
(0.1 + 0.2).toFixed(1) === '0.3' // true
但是返回的是字符串
(0.1 + 0.2).toFixed(1) == 0.3 // true（隐式类型转换）
(0.1 + 0.2).toFixed(1) === 0.3 // false

```

3.使用误差范围，在一定的误差范围内，证明他们相等。

```js
function isEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

isEqual(0.1 + 0.2, 0.3); // true
```
4.使用decimal库，适用于高精度计算
如果你在做**金融、货币、科学计算**，不能用原生浮点！

推荐库：
- [decimal.js](https://github.com/MikeMcl/decimal.js/)
- [big.js](https://github.com/MikeMcl/big.js/)
- [bignumber.js](https://github.com/MikeMcl/bignumber.js/)
  

```js
import Decimal from 'decimal.js';

console.log(new Decimal(0.1).plus(0.2).equals(0.3)); // true
```
以decimal为例，有设计好的api

| 任务                      | 原生写法  | 高精度写法                              |
| :------------------------ | :-------- | :-------------------------------------- |
| 创建                      | `0.1`     | `new Decimal('0.1')` ⚠️ 一定要传字符串   |
| 加法                      | `a + b`   | `a.plus(b)`                             |
| 减法                      | `a - b`   | `a.minus(b)`                            |
| 乘法                      | `a * b`   | `a.times(b)` 或 `mul()`                 |
| 除法                      | `a / b`   | `a.div(b)`                              |
| 取余                      | `a % b`   | `a.mod(b)`                              |
| 幂                        | `a ** b`  | `a.pow(b)`                              |
| 比较                      | `a === b` | `a.eq(b)` / `gt` / `gte` / `lt` / `lte` |
| 保留 n 位                 | 无原生    | `toFixed(n)` 或 `toDecimalPlaces(n)`    |
| 转 Number                 | 无        | `toNumber()`（可能再丢精度）            |
| 转字符串                  | 无        | `toString()`                            |
| 实战 1：0.1 + 0.2 === 0.3 |           |                                         |

```js
import Decimal from 'decimal.js';

const a = new Decimal('0.1');
const b = new Decimal('0.2');
const c = new Decimal('0.3');

console.log(a.plus(b).eq(c));   // true
console.log(a.plus(b).toString()); // "0.3"
```

---

### 15.判断数组的方式有哪些

1.通过Object.prototype.toString.call()做判断

```
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
```
**`Object.prototype.toString.call(value)` 就是“查内置标签”**：  

引擎不看 `.constructor`、不看 `instanceof`，只看 **创建时写死的内部插槽**； 
数组的插槽永远是 `"Array"`，所以返回 `"[object Array]"`——**一锤定音，无法伪造**。

2.通过原型链做判断
```
obj.__proto__ === Array.prototype;
```
3.Arrary.isArrary()

```
Array.isArrray(obj);
```
4.instanceof

```
obj instanceof Array
const isArr=instanceof(obj,Array) //true或false


```

---

### 16.对类数组对象的理解，如何转化为数组

类数组对象（Array-like Objects）通常指的是：**拥有 `length` 属性，且属性名是数字索引**，但它们**不具备** `Array.prototype` 上的方法（如 `map`, `slice`, `push` 等）。

以下是 JavaScript 中最常见、最典型的四个类数组对象例子：

1.`arguments` 对象 (Function Arguments)

这是最经典、最古老的类数组对象。在函数内部，`arguments` 对象包含函数被调用时传入的所有参数。

```
function sum(a, b, c) {
  console.log(arguments); 
  // 输出: [Arguments] { '0': 10, '1': 20, '2': 30 }
  
  console.log(typeof arguments); // object
  console.log(arguments.length); // 3 (✔ 有 length 属性)
  console.log(arguments[0]);     // 10 (✔ 可以通过索引访问)

  // arguments.slice(1); // ❌ 错误：arguments.slice is not a function
}

sum(10, 20, 30);
```

**特点：**

- 有 `length` 属性。
- 可以通过索引 `[0]`, `[1]` 访问元素。
- **不继承** `Array.prototype` 上的方法。



2.DOM `NodeList`

当你使用某些 DOM 查询方法（比如 `document.getElementsByTagName()` 或 `document.querySelectorAll()`）时，返回的结果通常是 `NodeList`。

**示例：**

假设你的 HTML 页面中有三个 `<div>` 元素。

```
// 使用 document.querySelectorAll
const nodeList = document.querySelectorAll('div'); 

console.log(nodeList); 
// 输出: NodeList(3) [div, div, div] (看起来像数组)

console.log(nodeList.length);  // 3
console.log(nodeList[0]);      // 第一个 div 元素

// nodeList.map((el) => el.tagName); // ❌ 错误：nodeList.map is not a function
```

**特点：**

- `NodeList` 是一个实时的或静态的 DOM 元素集合。
- 有 `length` 属性，可以通过索引访问。
- **传统上**它没有数组方法，因此被视为类数组。
  - *注意：* 现代浏览器中的 `NodeList` 已经有 `forEach` 方法了，但仍然没有 `slice`, `map`, `filter` 等方法，所以它依然是类数组的代表。



3.DOM `HTMLCollection`

当你使用 `document.getElementsByClassName()` 或 `document.images`（获取所有 `<img>` 元素）时，返回的结果是 `HTMLCollection`。

```
const collection = document.getElementsByClassName('item');
// 假设有 2 个 class="item" 的元素

console.log(collection.length); // 2
console.log(collection[0]);     // 第一个元素

// collection.slice(); // ❌ 错误：collection.slice is not a function
```

**特点：**

- `HTMLCollection` 是一个**实时 (live)** 的 DOM 元素集合。
- 有 `length` 属性，可以通过索引访问。
- **不继承** `Array.prototype` 上的方法。



4.任何自定义的、带有 `length` 和数字索引的对象

你可以手动创建一个类数组对象，只要它符合那两个基本特征：

```
const customArrayLike = {
  0: 'Red',
  1: 'Green',
  2: 'Blue',
  length: 3 // 必须手动设置 length 属性
};

console.log(customArrayLike.length); // 3
console.log(customArrayLike[1]);     // Green

// customArrayLike.push('Yellow'); // ❌ 错误：customArrayLike.push is not a function
```

**特点：**

- 你无法对它使用 `push` 或 `pop` 等数组操作方法。
- 它完全由你手动定义，是人为创建的类数组对象。

💡 如何把类数组对象转换成真正的数组？



由于类数组对象没有数组方法，如果想对它们使用 `slice`、`map` 等操作，你需要先将它们转换为真正的数组。

最常用的方法有三种：

**使用 `Array.from()` (ES6+)**：

JavaScript

```
const realArray1 = Array.from(nodeList); 
```

**使用扩展运算符 `[...]` (ES6+)**：

JavaScript

```
const realArray2 = [...nodeList];
```

**使用 `Array.prototype.slice.call()` (经典方法)**：

```
// 借用 Array 的 slice 方法来处理类数组对象
const realArray3 = Array.prototype.slice.call(arguments);
```

**通过 `call` 调用数组的 `splice` 方法来实现转换**

```
Array.prototype.splice.call(arrayLike, 0)

```

**通过 `apply` 调用数组的 `concat` 方法来实现转换**

```
Array.prototype.concat.apply([], arrayLike)

```

**Array.propotype.slice.call()是什么** 比如`Array.prototype.slice.call(arguments)`这句里，就是把 `arguments` 当做当前对象。

也就是说 要调用的是 `arguments` 的 `slice` 方法，而`typeof arguments="Object"` 而不是 `Array`

它没有`slice`这个方法，通过这么`Array.prototype.slice.call`调用，JS的内部机制应该是 把`arguments`对象转化为`Array`





### 17.substring和substr的区别
它们都是字符串方法，用于截取字符串的一部分，主要区别在于参数不同

- `substring(startIndex, endIndex)`： 接收两个参数，一个起始索引和结束索引，来指定字符串范围，如果省略第二个参数，则截取到字符串末尾。
- `substr(startIndex, length)`： 接收两个参数，并返回从 `startIndex` 开始，长度为 `length` 的子字符串。如果省略第二个参数，则截取到字符串末尾。
```js
const str = "Hello, World!";

console.log(str.substring(0, 5)); // 输出: "Hello"

console.log(str.substr(7, 5)); // 输出: "World"
```


### 18.object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别

基本类型独立，复杂类型不独立，也就是浅拷贝。
- `Object.assign()`方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。
- 扩展操作符`（…）`使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 `symbols` 属性。







### 19.new操作符的实现原理

1. 创建空对象 `obj`。
2. 把 `obj` 的 `[[Prototype]]`（即 `__proto__`）指向构造函数的 `prototype` 属性。
3. 以 `obj` 为 `this` 执行构造函数(意思就是构造函数执行的时候，使用obj的环境)，拿到返回值 `result`。

这一步非常关键。它描述了如何将第一步创建的空对象与构造函数关联起来。通过使用 `apply`（或 `call`）方法，可以强制改变函数内部 `this`的指向。在这里，就是用新创建的对象作为 `this`的上下文去调用构造函数。这样，在构造函数内部，所有对 `this`的操作（例如 `this.name = ‘Alice’`) 实际上都是在给这个新对象添加属性。



4. 如果 `result` 是对象（含函数、数组）且 **不为 null**，则返回 `result`；否则返回 `obj`。

- 如果构造函数**没有 `return`语句**，或者 `return`了一个基本类型的值，那么 `new`操作符会**忽略**这个返回值，并正常返回第一步创建的新对象。
- 如果构造函数**显式 `return`了一个对象（引用类型）**，那么 `new`操作符会**返回这个指定的对象**，而第一步创建的新对象就会被“丢弃”。



根据上面的原理，我们可以模拟一个 `myNew`函数来实现 `new`的功能：

```
function myNew(constructorFn, ...args) {
  // 1. 创建一个新对象，并链接到构造函数的原型
  let newObj = Object.create(constructorFn.prototype);
  // 这行代码等价于：
  // let newObj = {};
  // newObj.__proto__ = constructorFn.prototype;

  // 2. 将 this 指向新对象，并执行构造函数（给新对象添加属性）
  let result = constructorFn.apply(newObj, args);

  // 3. 判断返回值：如果结果是对象则返回，否则返回新创建的对象（注:我没有搞明白为什么要这样设计？）
  if (result && (typeof result === 'object' || typeof result === 'function')) {
    return result;
  }
  return newObj;
}

// 测试用例
function Person(name, age) {
  this.name = name;
  this.age = age;
  // 没有return语句，默认返回 undefined（基本类型），所以 myNew 会返回 newObj
}
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

let p1 = myNew(Person, 'Alice', 25);
console.log(p1.name); // Alice
p1.sayHello(); // Hello, I'm Alice
console.log(p1 instanceof Person); // true

// 测试构造函数返回对象的情况
function Car(brand) {
  this.brand = brand;
  return { type: 'SUV' }; // 显式返回一个对象
}

let c1 = myNew(Car, 'Toyota');
console.log(c1.brand); // undefined （因为新创建的 newObj 被丢弃了）
console.log(c1.type); // SUV
```



### 20.如何使用for...of遍历对象

`for…of`是作为ES6新增的遍历方式，能被其遍历的数据内部都有一个**遍历器iterator接口**，而数组、字符串、`Map`、`Set`内部已经实现，普通对象内部没有，所以在遍历的时候会报错。想要遍历对象，可以给对象添加一个`Symbol.iterator`属性，并指向一个迭代器即可

在迭代器里面，通过`Object.keys`获取对象所有的`key`，然后遍历返回`key 、value`。

```js
var obj = {
    a:1,
    b:2,
    c:3
};
//function*()是生成器函数，它是一种特殊的函数，调用时会自动返回一个迭代器对象，大大简化了手动实现 next()方法的复杂度
obj[Symbol.iterator] = function*(){
    var keys = Object.keys(obj);
    for(var k of keys){
        yield [k,obj[k]]
    }
};
//生成器函数内部使用 yield关键字来定义每次迭代返回的值。
for(var [k,v] of obj){
    console.log(k,v);
}
```



### 21.对AJAX的理解，实现一个AJAX请求

`AJAX`是 Asynchronous JavaScript and XML 的缩写，**指的是通过 JavaScript 的 异步通信**，从服务器获取 `XML` 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。 创建`AJAX`请求的步骤：

- 创建一个 `XMLHttpRequest` 对象。
- 在这个对象上使用 `open` 方法创建一个 `HTTP` 请求，`open` 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。
- 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 `setRequestHeader` 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 `XMLHttpRequest` 对象一共有 5 个状态，当它的状态变化时会触发`onreadystatechange` 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 `readyState` 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 `response` 中的数据来对页面进行更新了。
- 当对象的属性和监听函数设置完成后，最后调用 `send` 方法来向服务器发起请求，可以传入参数作为发送的数据体。

```js
const SERVER_URL = "/server";
let xhr = new XMLHttpRequest();
// 创建 Http 请求
xhr.open("GET", url, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (this.readyState !== 4) return;
  // 当请求成功时
  if (this.status === 200) {
    handle(this.response);
  } else {
    console.error(this.statusText);
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
// 发送 Http 请求
xhr.send(null);
```



### 22.ajax,axios,fetch的区别

**ajax**

- **架构不清晰**：API 设计比较底层和冗长，配置和调用方式复杂。
- **基于事件的异步模型**：需要通过监听 `onreadystatechange`等事件来处理响应，容易产生“回调地狱”。
- **不符合 MVVM**：在 Vue、React 等现代框架中，这种基于事件的回调模式与声明式的数据驱动开发风格不匹配

**核心概念：什么是 AJAX？**

**AJAX** 是一种技术概念，全称是 Asynchronous JavaScript and XML（异步 JavaScript 和 XML）。它允许网页在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容。我们通常所说的“AJAX”指的是使用 `XMLHttpRequest`对象来实现这一技术。

下面我将基于你提供的要点进行解释，并补充一些例子。

```
// 1. 创建 XHR 对象
const xhr = new XMLHttpRequest();

// 2. 配置请求：方法、URL、是否异步
xhr.open('GET', '/api/user/1', true);

// 3. 设置事件监听器（回调函数）
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) { // 请求完成
        if (xhr.status === 200) { // 请求成功
            console.log(JSON.parse(xhr.responseText));
        } else {
            console.error('请求失败');
        }
    }
};

// 4. 设置错误监听器（另一个回调）
xhr.onerror = function() {
    console.error('网络错误');
};

// 5. 发送请求
xhr.send();
```

**问题**：如果下一个请求依赖于上一个请求的结果，代码就会嵌套很深，形成回调地狱。



**axios**

Axios 是一个基于 Promise 的**第三方 HTTP 库**，它是对原生 `XMLHttpRequest`的封装，使其更易用、功能更强大。

- **支持 Promise API**：使用 `.then()`和 `.catch()`处理响应，支持 `async/await`，解决了回调地狱问题。
- **浏览器和 Node.js 通用**：在浏览器中用 XHR，在 Node.js 中用 `http`模块。
- **拦截器**：可以在请求发出前或响应返回后统一处理（例如添加认证 token、统一报错处理）。
- **自动转换 JSON**：响应数据会自动转换为 JavaScript 对象。
- **防御 CSRF**：可以自动在请求头中添加 CSRF token。

**代码示例：**

```
// 使用 Promise 链
axios.get('/api/user/1')
    .then(response => {
        console.log(response.data);
        return axios.post('/api/profile', { name: 'new name' }); // 链式调用
    })
    .then(response => {
        console.log('更新成功');
    })
    .catch(error => {
        console.error('请求出错', error);
    });

// 使用 async/await（更清晰）
async function getUserData() {
    try {
        const userResponse = await axios.get('/api/user/1');
        const profileResponse = await axios.post('/api/profile', { name: userResponse.data.name });
        console.log(profileResponse.data);
    } catch (error) {
        console.error('操作失败', error);
    }
}

// 添加请求拦截器
axios.interceptors.request.use(config => {
    config.headers.Authorization = `Bearer ${getToken()}`; // 自动添加 token
    return config;
});
```



**fetch**

Fetch 是浏览器原生的、现代化的**替代 AJAX 的方案**，它基于 Promise 设计，语法更简洁。

- **浏览器原生**：无需安装第三方库。
- **基于 Promise**：和 Axios 一样，支持 `.then()`和 `async/await`。
- **默认不携带 Cookie**：需要显式设置 `credentials: 'include'`。
- **对 HTTP 错误状态码不报错**：`fetch()`只有在网络故障时才会被标记为 reject（拒绝），而 404、500 等 HTTP 错误状态码会被标记为 resolve（完成）。这是与 Axios 最大的行为差异之一。
- **无法监控进度**：不像 XHR 可以监听上传/下载进度。

```js
// 基本使用
fetch('/api/user/1')
    .then(response => {
        // 注意：即使状态码是404，这里也会进入then
        if (!response.ok) { // 需要手动检查响应是否成功
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json(); // 解析JSON数据
    })
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        // 这里会捕获网络错误和上面手动抛出的错误
        console.error('Error:', error);
    });

// 使用 async/await
async function fetchUser() {
    try {
        const response = await fetch('/api/user/1');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const userData = await response.json();
        console.log(userData);
    } catch (error) {
        console.error('Fetch failed:', error);
    }
}

// 配置项：携带Cookie、设置请求头等
fetch('/api/data', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({ key: 'value' }),
    credentials: 'include' // 携带Cookie
});
```



### 23.forEach和map方法的区别

两个方法都是用来遍历循环数组，区别如下：

- `forEach()`对数据的操作会改变原数组，该方法没有返回值；
- `map()`方法不会改变原数组的值，**返回一个新数组**，新数组中的值为原数组调用函数处理之后的值；





### 24.什么是尾调用，使用尾调用有什么好处？

尾调用就是在函数的**最后一步调用函数**，在一个函数里调用另外一个函数会**保留当前执行的上下文**，如果在函数尾部调用，因为已经是函数最后一步，所以这时可以不用保留当前的执行上下文，**从而节省内存**。但是ES6的尾调用只能在**严格模式下开启**，正常模式是无效的。







# ES6

### 1.说说var、let、const之间的区别

==先总结==
`var`、`let`、`const`三者区别可以围绕下面五点展开：

- 变量提升
- 暂时性死区
- 块级作用域
- 重复声明
- 修改声明的变量
- 使用

**变量提升**

```
var`声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined
```

`let`和`const`不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错

```js
// var
console.log(a)  // undefined
var a = 10

// let 
console.log(b)  // Cannot access 'b' before initialization
let b = 10

// const
console.log(c)  // Cannot access 'c' before initialization
const c = 10
```

**暂时性死区**

**暂时性死区**指的是从代码块开始到变量声明语句执行完毕的这段时间，在这段时间内访问该变量会抛出错误。

`var`不存在暂时性死区

`let`和`const`存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量

```js
// var
console.log(a)  // undefined
var a = 10

// let
console.log(b)  // Cannot access 'b' before initialization
let b = 10

// const
console.log(c)  // Cannot access 'c' before initialization
const c = 10
```

**块级作用域**
`var`不存在块级作用域
`let`和`const`存在块级作用域

```js
// var
{
    var a = 20
}
console.log(a)  // 20

// let
{
    let b = 20
}
console.log(b)  // Uncaught ReferenceError: b is not defined

// const
{
    const c = 20
}
console.log(c)  // Uncaught ReferenceError: c is not defined
```
**重复声明**
`var`允许重复声明变量
`let`和`const`在同一作用域不允许重复声明变量

```js
// var
var a = 10
var a = 20 // 20

// let
let b = 10
let b = 20 // Identifier 'b' has already been declared

// const
const c = 10
const c = 20 // Identifier 'c' has already been declared
```
**声明变量是否可修改**
`var`和`let`可以
`const`声明一个只读的常量。一旦声明，常量的值就不能改变

```js
// var
var a = 10
a = 20
console.log(a)  // 20

//let
let b = 10
b = 20
console.log(b)  // 20

// const
const c = 10
c = 20
console.log(c) // Uncaught TypeError: Assignment to constant variable
```

**使用**
能用`const`的情况尽量使用`const`，其他情况下大多数使用`let`，避免使用`var`

==1.==var
在ES5中，顶层对象的属性和全局变量是等价的，用`var`声明的变量既是全局变量，也是顶层变量
注意：顶层对象，在浏览器环境指的是`window`对象，在 `Node` 指的是`global`对象
```js
var a = 10;
console.log(window.a) // 10
```
使用`var`声明的变量存在变量提升的情况
```js
console.log(a) // undefined
var a = 20
```
在编译阶段，编译器会将其变成以下执行
```js
var a
console.log(a)
a = 20
```
使用`var`，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明
```js
var a = 20 
var a = 30
console.log(a) // 30
```
在函数中使用使用`var`声明变量时候，该变量是局部的
```js
var a = 20
function change(){
    var a = 30
}
change()
console.log(a) // 20 
```
而如果在函数内不使用`var`，该变量是全局的
```js
var a = 20
function change(){
   a = 30
}
change()
console.log(a) // 30 
```

==2.==let
`let`是`ES6`新增的命令，用来声明变量
用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效
```js
{
    let a = 20
}
console.log(a) // ReferenceError: a is not defined.
```
不存在变量提升
```js
console.log(a) // 报错ReferenceError
let a = 2
```
这表示在声明它之前，变量`a`是不存在的，这时如果用到它，就会抛出一个错误
只要块级作用域内存在`let`命令，这个区域就不再受外部影响
```js
var a = 123
if (true) {
    a = 'abc' // ReferenceError
    let a;
}
```
使用`let`声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”
最后，`let`不允许在相同作用域中重复声明
```js
let a = 20
let a = 30
// Uncaught SyntaxError: Identifier 'a' has already been declared
```
注意的是相同作用域，下面这种情况是不会报错的
```js
let a = 20
{
    let a = 30
}
```
因此，我们不能在函数内部重新声明参数
```js
function func(arg) {
  let arg;
}
func()
// Uncaught SyntaxError: Identifier 'arg' has already been declared
```

==3.==const
`const`声明一个只读的常量，一旦声明，常量的值就不能改变
```js
const a = 1
a = 3
// TypeError: Assignment to constant variable.
```
这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值
```js
const a;
// SyntaxError: Missing initializer in const declaration
```

如果之前用`var`或`let`声明过变量，再用`const`声明同样会报错

```js
var a = 20
let b = 20
const a = 30
const b = 30
// 都会报错
```

`const`实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动

对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量

对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的，并不能确保改变量的结构不变

```js
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

其它情况，`const`与`let`一致



### 2.ES6中数组新增了哪些扩展？

==1.==拓展运算符

ES6通过扩展元素符`...`，好比 `rest` 参数的逆运算，将一个数组转为用逗号分隔的参数序列

```js
console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll('div')]
// [<div>, <div>, <div>]
```

注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组

可以将字符串转为真正的数组

```javascript
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```

==2.==构造函数新增方法

关于构造函数，数组新增的方法有如下：

- Array.from()
- Array.of()

**arrary.from**

将两类对象转为真正的数组：类似数组的对象和可遍历`（iterable）`的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）

```js
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
//控制length可以增加可识别的数量。
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组

```js
Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```

**arrary.of**

用于将一组值，转换为数组

```js
Array.of(3, 11, 8) // [3,11,8]
```

没有参数的时候，返回一个空数组

当参数只有一个的时候，实际上是指定数组的长度

参数个数不少于 2 个时，`Array()`才会返回由参数组成的新数组

```js
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
```

==3.==实例对象新增方法

- copyWithin()
- find()、findIndex()
- fill()
- entries()，keys()，values()
- includes()
- flat()，flatMap()

**copyWithin**

将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组

参数如下：

- target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
- start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

```js
[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5] 
```

**find()、findIndex**

`find()`用于找出第一个符合条件的数组成员

参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组

```js
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10
findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2
```

这两个方法都可以接受第二个参数，用来绑定回调函数的`this`对象。

```js
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26
```

**fill**

使用给定值，填充一个数组

```javascript
['a', 'b', 'c'].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
```

还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置

```js
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
```

注意，如果填充的类型为对象，则是浅拷贝

**entries()，keys()，values()**

`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历

```js
or (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
```

**includes()**

用于判断数组是否包含给定的值

```js
[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
```

方法的第二个参数表示搜索的起始位置，默认为`0`

参数为负数则表示倒数的位置

```js
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
```

**flat()，flatMap()**

将数组扁平化处理，返回一个新数组，对原数据没有影响

```js
[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
```

`flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1

```js
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
```

`flatMap()`方法对原数组的每个成员执行一个函数相当于执行`Array.prototype.map()`，然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this
```

==数组的空位置==

数组的空位指，数组的某一个位置没有任何值

ES6 则是明确将空位转为`undefined`，包括`Array.from`、扩展运算符、`copyWithin()`、`fill()`、`entries()`、`keys()`、`values()`、`find()`和`findIndex()`

建议大家在日常书写中，避免出现空位

==排序稳定性==

将`sort()`默认设置为稳定的排序算法

```js
const arr = [
  'peach',
  'straw',
  'apple',
  'spork'
];

const stableSorting = (s1, s2) => {
  if (s1[0] < s2[0]) return -1;
  return 1;
};

arr.sort(stableSorting)
// ["apple", "peach", "straw", "spork"]
```

排序结果中，`straw`在`spork`的前面，跟原始顺序一致

### 3.对象新增了哪些扩展？

- 属性的简写：ES6中，当对象键名与对应值名相等的时候，可以进行简写
- 属性名表达式：ES6 允许字面量定义对象时，将表达式放在括号内
-  super关键字：`this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字`super`，指向当前对象的原型对象

```js
class Animal {
    constructor(name) {
        this.name = name;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // 调用父类 Animal 的构造函数
        this.breed = breed;
    }
}

const myDog = new Dog('Buddy', 'Golden Retriever');
console.log(myDog.name); // "Buddy" (来自父类)
console.log(myDog.breed); // "Golden Retriever" (来自子类)
```



- 拓展运算符
- 属性的遍历方法：Object.keys(obj）、for...in、Object.getOwnPropertyNames(obj)、Reflect.ownKeys(obj)：、Object.getOwnPropertySymbols(obj)
- 对象的新增方法：Object.is()、Object.assign()、Object.getOwnPropertyDescriptors()、Object.setPrototypeOf()，Object.getPrototypeOf()、Object.keys()，Object.values()，Object.entries()、Object.fromEntries()



==1.==属性的简写

ES6中，当对象键名与对应值名相等的时候，可以进行简写

```js
const baz = {foo:foo}

// 等同于
const baz = {foo}
```

方法也能够进行简写

```js
const o = {
  method() {
    return "Hello!";
  }
};

// 等同于

const o = {
  method: function() {
    return "Hello!";
  }
}
```

在函数内作为返回值，也会变得方便很多

```js
function getPoint() {
  const x = 1;
  const y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
```

注意：简写的对象方法不能用作构造函数，否则会报错

```js
const obj = {
  f() {
    this.foo = 'bar';
  }
};

new obj.f() // 报错
```

==2.属性名表达式==

ES6 允许字面量定义对象时，将表达式放在括号内

```js
let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
```

表达式还可以用于定义方法名

```js
let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello() // hi
```
注意，属性名表达式与简洁表示法，不能同时使用，会报错

```js
// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };
// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
```

注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串`[object Object]`

```js
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```

==3.super关键字==

`this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字`super`，指向当前对象的原型对象

```javascript
const proto = {
  foo: 'hello'
};

const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto); // 为obj设置原型对象
obj.find() // "hello"
```

==4.拓展运算符的应用==

在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面

```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

注意：解构赋值必须是最后一个参数，否则会报错

解构赋值是浅拷贝

```js
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
```

对象的扩展运算符等同于使用`Object.assign()`方法

==5.属性的遍历==

ES6 一共有 5 种方法可以遍历对象的属性。

- for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）
- Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名
- Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名
- Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名
- Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不
  管键名是 Symbol 或字符串，也不管是否可枚举

上述遍历，都遵守同样的属性遍历的次序规则：

- 首先遍历所有数值键，按照数值升序排列
- 其次遍历所有字符串键，按照加入时间升序排列
- 最后遍历所有 Symbol 键，按照加入时间升序排

```js
Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
```

==6.对象的新增方法==

关于对象新增的方法，分别有以下：

- Object.is()
- Object.assign()
- Object.getOwnPropertyDescriptors()
- Object.setPrototypeOf()，Object.getPrototypeOf()
- Object.keys()，Object.values()，Object.entries()
- Object.fromEntries()

**object.is**

严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身

```js
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

**object.assign**

```
Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target
```

`Object.assign()`方法的第一个参数是目标对象，后面的参数都是源对象

```javascript
const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
```

注意：`Object.assign()`方法是浅拷贝，遇到同名属性会进行替换

**Object.getOwnPropertyDescriptors()**

返回指定对象所有自身属性（非继承属性）的描述对象

```js
const obj = {
  foo: 123,
  get bar() { return 'abc' }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
```

**Object.setPrototypeOf()**

`Object.setPrototypeOf`方法用来设置一个对象的原型对象

```js
Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf({}, null);
```

**Object.keys()**

返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组

```js
var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// ["foo", "baz"]
```

**Object.values()**

```js
const obj = { foo: 'bar', baz: 42 };
Object.values(obj)
// ["bar", 42]
```

**Object.entries()**

返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组

```js
const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]
```

**Object.fromEntries()**

用于将一个键值对数组转为对象

```js
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: "bar", baz: 42 }
```

---

### 4.函数对象新增了哪些扩展

- 允许为参数设置默认值
- 增添了函数的length属性，表示传入没有指定默认值的参数
- 添加了name属性，表示函数名
- 严格模式
- 箭头函数



==1.参数==
`ES6`允许为函数的参数设置默认值

```
function log(x, y = 'World') {
  console.log(x, y);
}

console.log('Hello') // Hello World
console.log('Hello', 'China') // Hello China
console.log('Hello', '') // Hello
```
==2.属性==
**1.函数的length属性**
`length`将返回没有指定默认值的参数个数

```
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```

`rest` 参数也不会计入`length`属性

```
(function(...args) {}).length // 0
```
如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了
```js
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```
**2.name属性**

返回该函数的函数名
```
var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"
```
==3.作用域==
一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域
等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会
出现的
下面例子中，`y=x`会形成一个单独作用域，`x`没有被定义，所以指向全局变量`x`
```
let x = 1;

function f(y = x) { 
  // 等同于 let y = x  
  let x = 2; 
  console.log(y);
}

f() // 1
```
==4.严格模式==
只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错
```
// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
```
==5.箭头函数==

---

### 5.你是怎么理解ES6新增Set、Map两种数据结构的？
么是集合？什么又是字典？
- 集合  

是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合

- 字典  

是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同

区别？
- 共同点：集合、字典都可以存储不重复的值
- 不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储
==set==
`Set`是`es6`新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合
`Set`本身是一个构造函数，用来生成 Set 数据结构
```
const s = new Set();
```

`Set`的实例关于增删改查的方法：
- add()
- delete()
- has()  返回一个布尔值，判断该值是否为`Set`的成员
- clear()  清除所有成员，没有返回值
`Set`实例遍历的方法有如下：
关于遍历的方法，有如下：
- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回键值对的遍历器
- forEach()：使用回调函数遍历每个成员
`Set`的遍历顺序就是插入顺序
`keys`方法、`values`方法、`entries`方法返回的都是遍历器对象
```
let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]
```
`forEach()`用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的`forEach`方法有第二个参数，用于绑定处理函数的`this`

```
let set = new Set([1, 4, 9]);
set.forEach((value, key) => console.log(key + ' : ' + value))
// 1 : 1
// 4 : 4
// 9 : 9
```
扩展运算符和`Set` 结构相结合实现数组或字符串去重
```
// 数组
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)]; // [3, 5, 2]

// 字符串
let str = "352255";
let unique = [...new Set(str)].join(""); // "352"
```
实现并集、交集、和差集
```
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
```
==Map==
`Map`类型是键值对的有序列表，而键和值都可以是任意类型
`Map`本身是一个构造函数，用来生成 `Map` 数据结构

```
const m = new Map()
```
`Map` 结构的实例针对增删改查有以下属性和操作方法：

- size 属性
- set()
- get()
- has()
- delete()
- clear()
`Map`结构原生提供三个遍历器生成函数和一个遍历方法：
- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回所有成员的遍历器
- forEach()：遍历 Map 的所有成员

---

### 6.你是怎么理解ES6中 Promise的？使用场景？
==什么是Promise==
`Promise`，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大
在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码

```
doSomething(function(result) {
  doSomethingElse(result, function(newResult) {
    doThirdThing(newResult, function(finalResult) {
      console.log('得到最终结果: ' + finalResult);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
```
阅读上面代码，是不是很难受，上述形成了经典的回调地狱
现在通过`Promise`的改写上面的代码

```
doSomething().then(function(result) {
  return doSomethingElse(result);
})
.then(function(newResult) {
  return doThirdThing(newResult);
})
.then(function(finalResult) {
  console.log('得到最终结果: ' + finalResult);
})
.catch(failureCallback);
```

瞬间感受到`promise`解决异步操作的优点：

- 链式操作减低了编码难度
- 代码可读性明显增强

下面我们正式来认识`promise`：

==状态==
`promise`对象仅有三种状态
- `pending`（进行中）
- `fulfilled`（已成功）
- `rejected`（已失败）
特点：
- 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态
- 一旦状态改变（从`pending`变为`fulfilled`和从`pending`变为`rejected`），就不会再变，任何时候都可以得到这个结果

==用法==
`Promise`对象是一个构造函数，用来生成`Promise`实例

```
const promise = new Promise(function(resolve, reject) {});
```
`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`
- `resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”
- `reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”
==实例方法==
`Promise`构建出来的实例存在以下方法：
- then()
- catch()
- finally()
==then()==

`then`是实例状态发生改变时的回调函数，第一个参数是`resolved`状态的回调函数，第二个参数是`rejected`状态的回调函数
`then`方法返回的是一个新的`Promise`实例，也就是`promise`能链式书写的原因
```
getJSON("/posts.json").then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
```

==catch==
`catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数

```
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
```
`Promise`对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止
```
getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
```
一般来说，使用`catch`方法代替`then()`第二个参数
`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应
```
const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};
```
浏览器运行到这一行，会打印出错误提示`ReferenceError: x is not defined`，但是不会退出进程
`catch()`方法之中，还能再抛出错误，通过后面`catch`方法捕获到
==finally()==
`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作

```
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```

==构造函数方法==

`Promise`构造函数存在以下方法：

- all()
- race()
- allSettled()
- resolve()
- reject()
- try()

==all()==
`Promise.all()`方法用于将多个 `Promise`实例，包装成一个新的 `Promise`实例
```
const p = Promise.all([p1, p2, p3]);
```
接受一个数组（迭代对象）作为参数，数组成员都应为`Promise`实例
实例`p`的状态由`p1`、`p2`、`p3`决定，分为两种：
- 只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数
- 只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数
注意，如果作为参数的 `Promise` 实例，自己定义了`catch`方法，那么它一旦被`rejected`，并不会触发`Promise.all()`的`catch`方法
```
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result)
.catch(e => e);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result)
.catch(e => e);

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e));
// ["hello", Error: 报错了]
```
如果`p2`没有自己的`catch`方法，就会调用`Promise.all()`的`catch`方法
```
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result);

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e));
// Error: 报错了
```

==race()==
`Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例

```
const p = Promise.race([p1, p2, p3]);
```
只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变
率先改变的 Promise 实例的返回值则传递给`p`的回调函数

```
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
```
==allSettled()==

`Promise.allSettled()`方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例
只有等到所有这些参数实例都返回结果，不管是`fulfilled`还是`rejected`，包装实例才会结束.也就是所有的实例都完成了，无论是成功或失败，allSettled才会返回结果。

```
const promises = [
  fetch('/api-1'),
  fetch('/api-2'),
  fetch('/api-3'),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
```

==resolve()==

将现有对象转为 `Promise`对象，实例状态为`fullfilled`

```
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

参数可以分成四种情况，分别如下：

- 参数是一个 Promise 实例，`promise.resolve`将不做任何修改、原封不动地返回这个实例
- 参数是一个`thenable`对象，`promise.resolve`会将这个对象转为 `Promise`对象，然后就立即执行`thenable`对象的`then()`方法
- 参数不是具有`then()`方法的对象，或根本就不是对象，`Promise.resolve()`会返回一个新的 Promise 对象，状态为`resolved`
- 没有参数时，直接返回一个`resolved`状态的 Promise 对象

==reject()==

`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`

```
const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) => reject('出错了'))

p.then(null, function (s) {
  console.log(s)
});
// 出错了
```

`Promise.reject()`方法的参数，会原封不动地变成后续方法的参数

```
Promise.reject('出错了')
.catch(e => {
  console.log(e === '出错了')
})
// true
```

==三、使用场景==

将图片的加载写成一个`Promise`，一旦加载完成，`Promise`的状态就发生变化

```
const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
```

通过链式操作，将多个渲染数据分别给个`then`，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题

```
// 各司其职
getInfo().then(res=>{
    let { bannerList } = res
    //渲染轮播图
    console.log(bannerList)
    return res
}).then(res=>{
    
    let { storeList } = res
    //渲染店铺列表
    console.log(storeList)
    return res
}).then(res=>{
    let { categoryList } = res
    console.log(categoryList)
    //渲染分类列表
    return res
})
```

通过`all()`实现多个请求合并在一起，汇总所有请求结果，只需设置一个`loading`即可

```
function initLoad(){
    // loading.show() //加载loading
    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=>{
        console.log(res)
        loading.hide() //关闭loading
    }).catch(err=>{
        console.log(err)
        loading.hide()//关闭loading
    })
}
//数据初始化    
initLoad()
```

通过`race`可以设置图片请求超时

```
//请求某个图片资源
function requestImg(){
    var p = new Promise(function(resolve, reject){
        var img = new Image();
        img.onload = function(){
           resolve(img);
        }
        //img.src = "https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg"; 正确的
        img.src = "https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1";
    });
    return p;
}

//延时函数，用于给请求计时
function timeout(){
    var p = new Promise(function(resolve, reject){
        setTimeout(function(){
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}

Promise
.race([requestImg(), timeout()])
.then(function(results){
    console.log(results);
})
.catch(function(reason){
    console.log(reason);
});
```


### 7.你是怎么理解ES6中 Proxy？使用场景？

ES6 中的 `Proxy` 是一个非常强大的特性，它允许你创建一个对象的“代理”，从而**拦截并自定义**该对象上的基本操作。

你可以把 `Proxy` 想象成一个在你和目标对象之间的**“中介”或“看门人”**。所有对该对象的访问（如读取、设置属性等）都必须先经过这个“看门人”（Proxy），而“看门人”可以决定如何处理这些操作。

基本语法
`Proxy` 是一个构造函数，像这样使用：

```
const target = {
  message: "Hello"
};

const handler = {
  // "handler" 是一个配置对象，它定义了要拦截哪些操作
  // 以及如何自定义这些操作（这些自定义函数被称为 "陷阱" trap）
};

const proxy = new Proxy(target, handler);
//Proxy对象的作用就是，当修改属性的时候，会执行handler中的set方法，进行一些预设的操作再判断是否进行设置；当访问属性的时候，会执行handler的get方法，进行一些预设的验证后再返回读取的值。
```

- `target`: 你要代理的原始对象（目标对象）。
- `handler`: 一个配置对象，用于定义各种“陷阱”（traps）。
- `proxy`: 返回的代理对象。

之后，你操作的应该是 `proxy` 对象，而不是 `target` 对象。


`Proxy` 的主要作用（通过 `handler` 陷阱实现）

`Proxy` 的强大之处在于 `handler` 对象可以定义多达 13 种不同的“陷阱”（trap），来拦截几乎所有对目标对象的基本操作。
以下是几个最常见和最有用的作用：

1. 数据验证（使用 `set` 陷阱）
这是最常见的用途之一。你可以在给对象属性赋值之前，拦截 `set` 操作，以验证新值的有效性。
**示例：** 确保 `age` 属性只能被设置为数字。

```js
let target = { name: "Alice", age: 30 };

let handler = {
  set(target, property, value) {
    if (property === 'age') {
      if (typeof value !== 'number' || value <= 0) {
        throw new Error("Age must be a positive number.");
      }
    }
    // 如果验证通过，才真正设置值
    target[property] = value;
    return true; // 表示设置成功
  }
};

let proxy = new Proxy(target, handler);

proxy.age = 31;      // 成功
console.log(proxy.age); // 31

// 尝试设置一个无效值
try {
  proxy.age = "fourty"; // 抛出错误: "Age must be a positive number."
} catch (e) {
  console.error(e.message);
}
```

 2. 响应式系统（现代框架的核心）

这是 `Proxy` 最著名的用途。像 **Vue 3** 这样的现代前端框架，其核心的响应式系统就是基于 `Proxy` 构建的。

- **`get` 陷阱**：当读取一个属性时（例如在模板中渲染 `{{ user.name }}`），`get` 陷阱会被触发。此时，框架可以**收集依赖**，即“记录”下是哪个组件的哪部分依赖了这个数据。
- **`set` 陷阱**：当修改一个属性时（例如 `user.name = "Bob"`），`set` 陷阱会被触发。此时，框架可以**通知**所有“记录”在案的、依赖这个数据的组件去重新渲染。

这比 ES5 的 `Object.defineProperty`（Vue 2 使用的）更强大，因为 `Proxy` 可以代理整个对象，包括新增的属性和数组操作，而 `defineProperty` 只能针对已存在的属性。

 3. 日志记录与调试（使用 `get` 和 `set`）

你可以拦截所有读写操作，并将其打印到控制台，以便跟踪对象在何时何处被访问或修改。

```js
let handler = {
  get(target, property) {
    console.log(`[LOG] Getting property: ${property}`);
    return target[property];
  },
  set(target, property, value) {
    console.log(`[LOG] Setting property: ${property} = ${value}`);
    target[property] = value;
    return true;
  }
};

let proxy = new Proxy({}, handler);
proxy.name = "Test"; // [LOG] Setting property: name = Test
let x = proxy.name;  // [LOG] Getting property: name
```

4. 访问控制（私有属性）

JavaScript 原生没有真正的私有属性（虽然现在有了 `#` 语法，但 `Proxy` 提供了另一种方式）。你可以约定以下划线 `_` 开头的属性为“私有”，并使用 `get` 和 `set` 陷阱阻止外部访问。

```
let handler = {
  get(target, property) {
    if (property.startsWith('_')) {
      throw new Error("Access to private property is denied.");
    }
    return target[property];
  }
  // ... 同样可以为 set, deleteProperty 等设置
};

let target = { name: "Public", _secret: "12345" };
let proxy = new Proxy(target, handler);

console.log(proxy.name); // "Public"
// console.log(proxy._secret); // 抛出错误: "Access to private property is denied."
```

---

`Proxy` 与 `Reflect`

提到 `Proxy` 几乎总要提到 `Reflect`。`Reflect` 是 ES6 提供的另一个内置对象，它提供了一套与 `Proxy` 陷阱同名的方法（如 `Reflect.get()`, `Reflect.set()`, `Reflect.apply()`）。
**最佳实践是：** 在 `Proxy` 的 `handler` 陷阱中，使用 `Reflect` 对应的方法来执行对 `target` 对象的**默认操作**。
例如，在 `set` 陷阱中，应该使用 `Reflect.set(target, property, value)` 来代替 `target[property] = value`。

```
let handler = {
  set(target, property, value, receiver) {
    console.log("Setting...");
    // 使用 Reflect.set 来执行默认操作，而不是 target[property] = value
    // 它能正确处理 "receiver"（this指向）并返回一个布尔值
    return Reflect.set(target, property, value, receiver);
  }
};
```



**“为什么在 Proxy 的陷阱函数 (handler) 内部，推荐使用 `Reflect` 的方法（如 `Reflect.set`），而不是直接操作 `target` 对象（如 `target[property] = value`）？”**

答案是：使用 `Reflect` 可以确保**操作的正确性、规范性，并简化代码**。
不使用 `Reflect` 会导致一些难以察觉的 bug，尤其是在涉及 `getter/setter` 和 `this` 指向时。
以下是必须使用 `Reflect` 的几个核心理由：

1. 确保 `this` (receiver) 指向的正确性（最重要）

这是最关键、也是最容易出错的地方。
当你通过 `proxy` 访问一个属性时，如果这个属性在 `target` 对象上是一个 `getter` 或 `setter`，你希望这个 `getter/setter` 内部的 `this` 指向的是 `proxy` 对象，而不是 `target` 对象。
**`Reflect` 方法（如 `Reflect.get`, `Reflect.set`）接受一个 `receiver` 参数，这个参数就是 `Proxy` 陷阱函数接收到的第三个参数（它通常就是 `proxy` 实例本身）。`Reflect` 会确保将这个 `receiver` 作为 `getter/setter` 的 `this` 上下文。**
**如果你直接操作 `target`，`this` 就会指向 `target`**，这就破坏了代理的封装性。
**看个例子：**

```
const target = {
  _name: "Alice",
  get name() {
    // 我们期望这里的 'this' 指向 proxy，而不是 target
    console.log('Getter中的this是否指向Proxy:', this === proxy); 
    return this._name;
  }
};

const handler = {
  get(target, property, receiver) {
    console.log(`拦截到 get 操作: ${property}`);
    
    // 错误的做法：直接操作 target
    // return target[property]; 
    // 上面这行会导致 Getter 中的 'this' 指向 target，输出 false
    
    // 正确的做法：使用 Reflect，并传入 receiver
    return Reflect.get(target, property, receiver);
  }
};

const proxy = new Proxy(target, handler);

// 当我们访问 proxy.name 时...
proxy.name; 
```

**运行结果（使用 `Reflect.get`）：**

```
拦截到 get 操作: name
Getter中的this是否指向Proxy: true
```

**如果改成 `return target[property]`：**

```
拦截到 get 操作: name
Getter中的this是否指向Proxy: false  <-- 问题在这里！
```

2. 保证规范的返回值

`Proxy` 的 `set` 或 `deleteProperty` 陷阱函数**被规范要求必须返回一个布尔值**（`true` 表示成功，`false` 表示失败）。

- **直接操作**：`target[property] = value` 这样的赋值语句，在非严格模式下通常返回赋的值，在严格模式下失败时会抛出错误。你很难统一处理它的返回值。
- **`Reflect` 操作**：`Reflect.set()` 和 `Reflect.deleteProperty()` 被设计为**总是返回一个布尔值**，无论是否在严格模式下。

这使得 `Proxy` 陷阱函数能非常干净地返回 `Reflect` 操作的结果。

```
const target = {};
Object.freeze(target); // 冻结对象，使其不可写

const handler = {
  set(target, property, value, receiver) {
    console.log("拦截 set");
    
    // 错误的做法：
    /*
    try {
      target[property] = value; // 在严格模式下会抛错
      return true; // 即使不抛错，如果静默失败了，这里也会错误地返回 true
    } catch (e) {
      return false; // 需要 try...catch 来捕获
    }
    */

    // 正确的做法：
    const success = Reflect.set(target, property, value, receiver);
    if (!success) {
      console.warn("设置失败!");
    }
    return success; // 直接返回 Reflect 的结果，干净利落
  }
};

const proxy = new Proxy(target, handler);
proxy.name = "Test"; 
// 输出: 拦截 set
// 输出: 设置失败!
```

 3. 代码更简洁且与陷阱一一对应
`Reflect` 提供了 13 个静态方法，与 `Proxy` 的 13 个陷阱（trap）**一一对应**。

| **Proxy 陷阱 (Handler)** | **Reflect 默认操作 (Method)** |
| ------------------------ | ----------------------------- |
| `get()`                  | `Reflect.get()`               |
| `set()`                  | `Reflect.set()`               |
| `has()`                  | `Reflect.has()`               |
| `apply()`                | `Reflect.apply()`             |
| `deleteProperty()`       | `Reflect.deleteProperty()`    |
| ... (等等)               | ... (等等)                    |

这使得在 `Proxy` 陷阱中调用 `Reflect` 成为一种非常自然和易读的“标准”写法。



### 8. 箭头函数和普通函数的区别

1. 箭头函数是匿名函数，不能作为构造函数，使用 `new`关键字。
2. 箭头函数没有 `arguments`对象

在普通函数中，`arguments`是一个类数组对象，包含传入函数的所有参数。箭头函数本身没有 `arguments`，但可以访问外围函数的 `arguments`。



1. 箭头函数是匿名函数，不能作为构造函数，使用 `new`关键字。

**解释**：箭头函数没有 `[[Construct]]`内部方法，因此无法使用 `new`来实例化对象。

**代码示例**：

```
// 普通函数可以作为构造函数
const Person = function(name) {
    this.name = name;
};
const alice = new Person('Alice'); // 正确
console.log(alice.name); // "Alice"

// 箭头函数不能作为构造函数
const Animal = (name) => {
    this.name = name; // 这里的this是定义时的上下文，不是新对象
};
const cat = new Animal('Cat'); // 报错：TypeError: Animal is not a constructor
```



2. 箭头函数没有 `arguments`对象。

**解释**：在普通函数中，`arguments`是一个类数组对象，包含传入函数的所有参数。箭头函数本身没有 `arguments`，但可以访问外围函数的 `arguments`。

**代码示例**：

```
// 普通函数有 arguments
function regularFunc() {
    console.log(arguments); // Arguments(3) [1, 2, 3]
}
regularFunc(1, 2, 3);

// 箭头函数没有自己的 arguments
const arrowFunc = () => {
    console.log(arguments); // 报错：arguments is not defined
};
arrowFunc(1, 2, 3);

// 但可以访问外围函数的 arguments
function outer() {
    const inner = () => {
        console.log(arguments); // 继承自outer函数的arguments
    };
    inner();
}
outer(1, 2, 3); // 输出：Arguments(3) [1, 2, 3]

// 推荐做法：使用剩余参数（Rest Parameters）
const modernArrow = (...args) => {
    console.log(args); // [1, 2, 3] - 真正的数组
};
modernArrow(1, 2, 3);
```



3. 箭头函数没有自己的 `this`，会获取所在的上下文作为自己的 `this`。

4.  `call()`、`apply()`、`bind()`方法不能改变箭头函数中的 `this`指向。

**解释**：由于箭头函数的 `this`在定义时就已经固定，无法通过 `call`、`apply`、`bind`这些方法来改变。

**代码示例**：

```js
const obj1 = { name: 'Alice' };
const obj2 = { name: 'Bob' };

// 普通函数可以被绑定
const regularFunc = function() {
    console.log(this.name);
};
regularFunc.call(obj1); // "Alice"
regularFunc.call(obj2); // "Bob"

// 箭头函数的this无法被改变
const arrowFunc = () => {
    console.log(this.name);
};
arrowFunc.call(obj1); // ""（仍然是定义时的this）
arrowFunc.call(obj2); // ""（不变）

// bind对箭头函数无效
const boundArrow = arrowFunc.bind(obj1);
boundArrow(); // ""（this仍然不变）
```

5. 箭头函数没有 `prototype`属性。

**解释**：由于箭头函数不能作为构造函数，所以不需要 `prototype`属性。



6. 箭头函数不能用作 Generator 函数，不能使用 `yield`关键字。

**解释**：`yield`关键字只能在 `function*`生成器函数中使用，箭头函数不支持这种语法。

**代码示例**：

```
// 正确的Generator函数
function* regularGenerator() {
    yield 1;
    yield 2;
    yield 3;
}
const gen = regularGenerator();
console.log(gen.next().value); // 1

// 箭头函数不能使用yield
const arrowGenerator = *() => {  // 语法错误
    yield 1;
};

// 这也是错误的
const arrowGen = () => {
    yield 1; // 语法错误：Unexpected token 'yield'
};
```

### 9.Set、Map的区别

**Set**

- 创建：`  new Set([1, 1, 2, 3, 3, 4, 2])`
- `.add(value)`：添加某个值，返回Set结构本身。
- `.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `.has(value)`：返回一个布尔值，表示该值是否为Set的成员。
- `.clear()`：清除所有成员，没有返回值。

**Map**

- `.set(key, val):` 向`Map`中添加新元素
- `.get(key):` 通过键值查找特定的数值并返回
- `.has(key): `判断`Map`对象中是否有`Key`所对应的值，有返回`true`,否则返回`false`
- `.delete(key): `通过键值从`Map`中移除对应的数据
- `.clear():` 将这个`Map`中的所有元素删除

区别

- `Map`是一种键值对的集合，和对象不同的是，键可以是任意值
- `Map`可以遍历，可以和各种数据格式转换
- `Set`是类似数组的一种的数据结构，类似数组的一种集合，但在Set中没有重复的值



### 10.map和Object的区别

`map`和`Object`都是用键值对来存储数据，区别如下：

- **键的类型**：`Map` 的键可以是**任意数据类型**（包括对象、函数、`NaN `等），而 `Object` 的键**只能是字符串**或者 `Symbol` 类型。

- **键值对的顺序**：`Map`中的键值对是按照插入的顺序存储的，而对象中的键值对则没有顺序。

**Object 的顺序不可靠**

在 ES6 之前，`Object`的属性顺序依赖于 JavaScript 引擎的实现。ES6 规范后，对于**字符串键**有了一定的顺序规则，但依然有特殊情况。

```
const obj = {};
obj['b'] = 2;
obj['a'] = 1;
obj['2'] = '数字2';
obj['1'] = '数字1';

// 遍历顺序：数字键按数字顺序，字符串键按添加顺序
for (let key in obj) {
    console.log(key); // "1", "2", "b", "a"
}

// 但不同浏览器或环境下可能有差异
```

**Map 的插入顺序保证**

`Map`严格按照键值对的插入顺序进行迭代。

```
const map = new Map();
map.set('b', 2);
map.set('a', 1);
map.set(2, '数字2');
map.set(1, '数字1');

// 严格按照插入顺序遍历
for (let [key, value] of map) {
    console.log(key, value); 
    // "b" 2
    // "a" 1
    // 2 "数字2"
    // 1 "数字1"
}
```



- **键值对的遍例**：`Map` 的键值对可以使用 `for...of` 进行遍历，而 `Object` 的键值对需要手动遍历键值对。
- **继承关系**：`Map`没有继承关系，而 `Object` 是所有对象的基类。



### 11.map和weakMap的区别

它们是 `JavaScript` 中的两种不同的键值对集合，主要区别如下：

1. `map`的键可以是任意类型，`weakMap`键只能是对象类型。

**Map：键可以是任意类型**

```
const myMap = new Map();

// 所有类型都可以作为键
myMap.set('string', '字符串键');       // 字符串
myMap.set(42, '数字键');              // 数字
myMap.set(true, '布尔键');            // 布尔值
myMap.set({id: 1}, '对象键');          // 对象
myMap.set(['a', 'b'], '数组键');      // 数组
myMap.set(function() {}, '函数键');    // 函数
myMap.set(Symbol('sym'), 'Symbol键'); // Symbol
myMap.set(null, 'null键');            // null
myMap.set(undefined, 'undefined键');  // undefined

console.log(myMap.get(42)); // "数字键"
console.log(myMap.get(null)); // "null键"
```

**WeakMap：键只能是对象类型**

```
const myWeakMap = new WeakMap();

const obj = { name: 'Alice' };
const func = function() {};
const array = [1, 2, 3];

// 这些是有效的（对象类型）
myWeakMap.set(obj, '关联数据1');
myWeakMap.set(func, '关联数据2'); 
myWeakMap.set(array, '关联数据3');

// 这些会报错（非对象类型）
// myWeakMap.set('string', '值');    // TypeError: Invalid value used as weak map key
// myWeakMap.set(42, '值');          // TypeError
// myWeakMap.set(true, '值');        // TypeError
// myWeakMap.set(null, '值');        // TypeError
// myWeakMap.set(undefined, '值');   // TypeError
// myWeakMap.set(Symbol('sym'), '值'); // TypeError

console.log(myWeakMap.get(obj)); // "关联数据1"
```

2. `map` 使用常规的引用来管理键和值之间的关系，因此即使键不再使用，`map` 仍然会保留该键的内存。`weakMap` 使用弱引用来管理键和值之间的关系，因此如果键不再有其他引用，垃圾回收机制可以自动回收键值对。

这是 `WeakMap`存在的根本原因，也是最重要的区别。

**Map：强引用，阻止垃圾回收**

```
// Map 示例 - 强引用
let obj = { data: '重要数据' };
const myMap = new Map();

myMap.set(obj, '一些元数据');

// 即使我们不再需要 obj，Map 仍然保留着对它的强引用
obj = null; // 解除对对象的引用

// 但对象仍然存在于 Map 中，无法被垃圾回收
console.log([...myMap.keys()]); // [{data: "重要数据"}] - 对象还在！

// 必须手动删除才能释放内存
myMap.delete({data: '重要数据'}); // 这样是删不掉的，因为引用不同
// 正确做法：在设置引用时就保存引用，或者遍历查找
```

**WeakMap：弱引用，允许垃圾回收**

```
// WeakMap 示例 - 弱引用
let obj = { data: '重要数据' };
const myWeakMap = new WeakMap();

myWeakMap.set(obj, '一些元数据');

console.log(myWeakMap.get(obj)); // "一些元数据" - 当前可以访问

// 当我们不再需要 obj 时
obj = null; // 解除对对象的唯一强引用

// 现在，对象只有 WeakMap 的弱引用
// 垃圾回收器会在下次运行时自动回收这个对象
// 同时，WeakMap 中的对应键值对也会被自动移除

// 我们无法验证这一点，因为 WeakMap 不可遍历
// 但可以确信内存已经被释放
```



### 22.说说你对Promise的理解

`Promise`是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了地狱回调。

`Promise`的实例有三个状态:

- `Pending`（初始状态）
- `Fulfilled`（成功状态）
- `Rejected`（失败状态）

`Promise`的实例有两个过程：

- `pending` -> `fulfilled` : **Resolved（已完成）**

- `pending` -> `rejected`：**Rejected（已拒绝）**

  注意：一旦从进行状态变成为其他状态就永远不能更改状态了，其过程是不可逆的。

`Promise`构造函数接收一个带有`resolve`和`reject`参数的回调函数。

- `resolve`的作用是将`Promise`状态从`pending`变为`fulfilled`，在异步操作成功时调用，并将异步结果返回，作为参数传递出去
- `reject`的作用是将`Promise`状态从`pending`变为`rejected`，在异步操作失败后，将异步操作错误的结果，作为参数传递出去

`Promise`的缺点：

- 无法取消 `Promise`，一旦新建它就会立即执行，无法中途取消。
- 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。
- 当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。



### 23.Promise方法

- `promise.then()`  对应`resolve`成功的处理
- `promise.catch()`对应`reject`失败的处理
- `promise.all()`可以完成并行任务，将多个`Promise`实例数组，包装成一个新的`Promise`实例，返回的实例就是普通的`Promise`。有一个失败，代表该`Primise`失败。当所有的子`Promise`完成，返回值时全部值的数组
- `promise.race()`类似`promise.all()`，区别在于有任意一个完成,状态就立刻改变。
- `promise.allSettled()` 返回一个在所有给定的 `promise` 都已经 `fulfilled` 或 `rejected` 后的 `promise` ，并带有一个对象数组，每个对象表示对应的`promise` 结果。



### 24.promise.all 和 promise.allsettled 区别

`Promise.all()` 和 `Promise.allSettled()` 都是用来处理多个 `Promise` 实例的方法，它们的区别在于以下几点：

- **all:** 只有当所有`Promise`实例都`resolve`后，才会`resolve`返回一个由所有`Promise`返回值组成的数组。如果有一个`Promise`实例`reject`，就会立即被拒绝，并返回拒绝原因。`all`是团队的成功才算，如果有一个人失败就算失败。
- **allSettled：** 等所有`Promise`执行完毕后，不管成功或失败， 都会吧每个`Promise`状态信息放到一个数组里面返回。



### 25.对async/await 的理解

`async/await`其实是Generator 的语法糖，它能实现的效果都能用`then`链来实现，它是为优化`then`链而开发出来的。通过`async`关键字声明一个异步函数， `await `用于等待一个异步方法执行完成，**并且会阻塞执行**。 `async` 函数返回的是一个 Promise 对象，如果在函数中 `return` 一个变量，`async` 会把这个直接量通过 `Promise.resolve()` 封装成 `Promise` 对象。如果没有返回值，返回 `Promise.resolve(undefined)`



### 26.async/await对比Promise的优势

- 代码可读性高，`Promise`虽然摆脱了回掉地狱，但自身的链式调用会影响可读性。
- 相对`Promise`更优雅，传值更方便。
- 对错误处理友好，可以通过`try/catch`捕获，`Promise`的错误捕获⾮常冗余

---



### 27.谈谈你对ES6的理解

**先总结：**

- 解构赋值
- 扩展运算符
- 箭头函数
- 模版字符串
- `Set`、`Map`集合
- 新增`class`类
- `Proxy`
- `Promise`



 ES6（ECMAScript 2015）是 JavaScript 语言的一次里程碑式的更新，它引入了大量的新特性，极大地提升了语言的表达能力、开发效率和工程化水平。可以说，现代前端开发（如 React、Vue 等框架）都是建立在 ES6 的基础之上的。

> 1.解构赋值 (Destructuring Assignment)

**理解**：这是一种从数组或对象中提取值的语法，能显著简化赋值操作。

**应用场景与优势**：

- **数组解构**：快速获取数组元素，交换变量值无需中间变量。

  ```
  const [a, b] = [1, 2]; // a=1, b=2
  [a, b] = [b, a]; // 交换变量值
  ```

- **对象解构**：从函数参数或 API 返回对象中快速提取所需属性，代码更直观。

  ```
  const { name, age } = user; // 从user对象中提取name和age
  function connect({ host, port }) { ... } // 函数参数解构，清晰明了
  connect({ host: 'localhost', port: 8080 });
  ```

  **回答要点**：解构赋值让数据提取变得非常简洁，提高了代码的可读性和编写效率。

> 2.扩展运算符 (Spread Operator) `...`

**理解**：它像一把“语法糖”，用于展开数组或对象。

**应用场景与优势**：

- **数组操作**：轻松实现数组复制、合并。

  ```
  const newArr = [...oldArr, newItem]; // 数组合并
  const arrCopy = [...originalArr]; // 数组浅拷贝
  ```

- **对象操作**：实现对象浅拷贝、合并新属性，是替代 `Object.assign`的更直观方式。

  ```
  const newObj = { ...oldObj, newProp: 'value' }; // 对象合并
  ```

- **函数调用**：将数组展开为函数的参数列表。

  ```
  const nums = [1, 2, 3];
  Math.max(...nums); // 等同于 Math.max(1, 2, 3)
  ```

  **回答要点**：扩展运算符极大地简化了集合数据的操作，使代码更函数式、更优雅。

> 3.箭头函数 (Arrow Functions) `=>`

**理解**：提供了一种更简洁的函数写法，并解决了 `this`指向的难题。

**应用场景与优势**：

- **语法简洁**：特别适合用于回调函数。

  ```
  // 传统函数
  arr.map(function(item) { return item * 2; });
  // 箭头函数
  arr.map(item => item * 2);
  ```

  

  **没有自己的 `this`**：箭头函数内的 `this`继承自定义它的外层作用域。这彻底解决了传统函数中 `this`指向不确定的问题，尤其在事件处理、定时器回调等场景下非常有用。

  ```
  class Counter {
      constructor() {
          this.count = 0;
          // 传统函数需要 .bind(this)，箭头函数则不需要
          setInterval(() => {
              this.count++; // 这里的this正确地指向Counter实例
          }, 1000);
      }
  }
  ```

  **回答要点**：箭头函数不仅让代码更短，更重要的是它词法作用域的 `this`行为，避免了许多潜在错误。

> 4. 模板字符串 (Template Literals)

**理解**：使用反引号 (`) 来定义字符串，允许嵌入变量和表达式。

**应用场景与优势**：

- **字符串拼接**：告别繁琐的 `+`号拼接，支持多行字符串，非常适合拼接 HTML 模板或长文本。

  ```
  const name = 'Alice';
  const message = `Hello, ${name}!
  Welcome to our website.`;
  ```

  **回答要点**：模板字符串极大地改善了字符串的处理体验，使动态字符串的生成更加清晰和方便。

> 5. Set 与 Map 集合

**理解**：提供了更专业的集合数据结构。

- **`Set`**：成员值唯一的集合，常用于数组去重。

  ```
  const unique = [...new Set([1, 2, 2, 3])]; // [1, 2, 3]
  ```

- **`Map`**：键值对集合，但键可以是任意类型（对象、函数等），比普通 Object 更强大。

  ```
  const map = new Map();
  const keyObj = {};
  map.set(keyObj, 'value'); // 对象作为键
  ```

  **回答要点**：`Set`和 `Map`填补了 JavaScript 在特定数据结构上的空白，提供了比普通对象和数组更语义化、更高效的操作方式。

>  6. 新增 Class 类

**理解**：语法糖，让基于原型的继承写法更清晰、更像传统面向对象语言。

**应用场景与优势**：

- 引入了 `class`、`constructor`、`static`、`extends`、`super`等关键字。

  ```
  class Person {
      constructor(name) { this.name = name; }
      sayHello() { console.log(`Hello, I'm ${this.name}`); }
  }
  class Student extends Person {
      constructor(name, grade) {
          super(name); // 调用父类构造函数
          this.grade = grade;
      }
  }
  ```

  **回答要点**：`class`语法并没有改变 JavaScript 基于原型的本质，但它降低了面向对象编程的理解和上手门槛，使代码结构更清晰。

> 7. Proxy

**理解**：用于创建一个对象的代理，从而可以拦截并自定义对象的基本操作（如属性查找、赋值、函数调用等）。

**应用场景与优势**：

- 实现高级功能，如数据绑定（Vue 3 的核心）、验证、日志记录等。

  ```
  const handler = {
      get(target, prop) {
          console.log(`Getting property ${prop}`);
          return target[prop];
      }
  };
  const p = new Proxy({}, handler);
  p.a = 1;
  console.log(p.a); // 会打印日志 "Getting property a"
  ```

  **回答要点**：`Proxy`提供了强大的**元编程**能力，允许我们扩展语言本身的行为，是实现复杂框架和库的基石。

> 8. Promise

**理解**：异步编程的一种解决方案，比传统的回调函数更强大。

**应用场景与优势**：

- **解决回调地狱**：通过链式调用（`.then().catch()`）将嵌套的异步操作变为扁平化的流水线操作，代码可读性大大增强。

  ```
  fetchData()
      .then(processData)
      .then(displayData)
      .catch(handleError);
  ```

- **为 async/await 奠基**：`Promise`是 `async/await`语法的基础，后者让异步代码看起来像同步代码，是目前处理异步的首选方案。 **回答要点**：`Promise`统一了异步编程模型，是现代 JavaScript 异步处理的基石，它使得复杂的异步流程控制变得简单可控。



### 28.ES6 模块与 CommonJS 模块的区别

ES6 模块和 CommonJS 模块是现代 JavaScript 开发中两种主要的模块系统,在前端业务代码部分，主要使用es6，在项目底层、构建工具、npm包生态中，commjs则扮演者更重要的角色。他们是js中两种不同的模块化方案。

> 1. 导入、导出模块方式不同

- **ES6 模块 (ESM)**：使用声明式的 `import`和 `export`关键字。

  ```
  // 导入 (import)
  import { foo, bar } from './module.js'; // 命名导入
  import defaultExport from './module.js'; // 默认导入
  import * as Module from './module.js'; // 全部导入
  
  // 导出 (export)
  export const bar = 'bar'; // 命名导出
  export default foo; // 默认导出
  ```

  **特点**：语法是静态的，意味着导入导出语句必须位于模块的顶层作用域，不能嵌套在条件语句中。这种设计有利于进行静态分析。

- **CommonJS (CJS)**：使用函数式的 `require()`和对象式的 `module.exports`或 `exports`。

  ```
  // 导入 (require)
  const fs = require('fs'); // 导入内置模块
  const myModule = require('./my-module.js'); // 导入本地模块
  
  // 导出 (module.exports / exports)
  module.exports = someValue; // 直接导出
  exports.bar = 'bar'; // 命名导出 (exports 是 module.exports 的一个引用)
  ```

  **特点**：语法是动态的，`require()`可以出现在代码的任何地方（如条件判断、函数中），因为它是一个函数调用。

**核心区别**：ESM 是**静态**的，CJS 是**动态**的。ESM 的静态结构使得打包工具（如 Webpack、Vite）可以在打包阶段就分析出模块的依赖关系，进行 **Tree Shaking**（消除死代码），这是 ESM 的一个巨大优势。

> 2.加载时机与运行方式 (Loading Time & Execution)

这是最本质的区别，决定了它们的应用场景。

- **CommonJS (CJS)**：**同步加载**，主要用于服务器端（如 Node.js 环境）。**过程**：当执行 `require('./module.js')`时，Node.js 会**同步地**阻塞后续代码，先去读取、执行整个 `module.js`文件，然后将 `module.exports`的值返回给 `require`的调用方。**适用场景**：在服务器端，模块文件都在本地磁盘，同步加载速度很快，不会成为性能瓶颈。
- **ES6 模块 (ESM)**：**异步加载**，天生适用于浏览器环境。**过程**：当遇到 `import`语句时，浏览器会**异步地**发起请求获取模块文件，但不会阻塞主线程。它会先解析整个模块的依赖关系，形成一个“模块图”，然后按照依赖顺序执行模块代码。

> 3. 值的引用与拷贝 (Value Reference vs. Copy)

这关系到模块导入值的动态绑定问题。

- **CommonJS (CJS)**：输出的是值的**拷贝**。

  ```
  // commonjs.js
  let count = 0;
  function increment() { count++; }
  module.exports = { count, increment };
  
  // main.js
  const { count, increment } = require('./commonjs.js');
  console.log(count); // 0
  increment();
  console.log(count); // 0 (值没有改变，因为导入的是原始值的拷贝)
  ```

- **ES6 模块 (ESM)**：输出的是值的**引用**（动态绑定）。

  ```
  // esm.js
  export let count = 0;
  export function increment() { count++; }
  
  // main.js
  import { count, increment } from './esm.js';
  console.log(count); // 0
  increment();
  console.log(count); // 1 (值改变了，因为导入的是活的引用)
  ```

**核心区别**：ESM 是**动态绑定**，类似于指针，导入的变量会随着导出模块内值的改变而改变。CJS 是**值的浅拷贝**，导入后就和导出模块没关系了。





### 29.call() 、bind（）、 apply() 的区别？

`call`、`apply`和 `bind`都用于改变函数的 `this`指向，主要区别在于：

**执行时机**：`call`和 `apply`会**立即执行**函数，而 `bind`是**返回一个新函数**供后续调用。

**参数传递**：`call`接受**参数列表**，`apply`接受**参数数组**，`bind`可以分两次传递参数。

**使用场景**：`call`常用于**方法借用**，比如将类数组转为真正数组`apply`适合处理**参数是数组**的情况，比如数组合并`bind`主要用于**固定 `this`上下文**，比如事件处理函数和回调函数

简单来说，如果想立即调用函数，根据参数形式选择 `call`或 `apply`；如果想创建一个新的绑定函数供以后使用，就选择 `bind`。





好的，这是一个非常经典的面试题。`call()`、`apply()`和 `bind()`都是用于改变函数内部 `this`指向的方法，但它们在用法和时机上有关键区别。

**核心区别总结表**

| 特性         | `call(thisArg, arg1, arg2, ...)` | `apply(thisArg, [argsArray])`         | `bind(thisArg, arg1, arg2, ...)`                   |
| :----------- | :------------------------------- | :------------------------------------ | :------------------------------------------------- |
| **执行时机** | **立即执行**                     | **立即执行**                          | **不立即执行**，返回一个新函数（绑定函数）         |
| **参数形式** | 参数**逐个传递**                 | 参数作为**数组**或**类数组对象**传递  | 参数可逐个传递（分两次：绑定时可传，执行时可再传） |
| **返回值**   | 原函数的返回值                   | 原函数的返回值                        | 一个**新的函数**，其 `this`被永久绑定              |
| **主要用途** | 1. 借用方法 2. 继承              | 1. 参数是数组的情况 2. 与数学函数结合 | 1. 回调函数绑定 `this` 2. 偏函数应用               |





假设我们有一个对象和一个函数：

```
const person = {
  name: 'Alice'
};

function introduce(city, country) {
  console.log(`Hello, I'm ${this.name} from ${city}, ${country}`);
}
```

1.`call()`- 立即调用，参数逐个传递

**语法：** `function.call(thisArg, arg1, arg2, ...)`

```
introduce.call(person, 'Beijing', 'China');
// 立即输出: "Hello, I'm Alice from Beijing, China"
- 第一个参数是 `this`的新指向（`person`）
- 后续参数逐个传递给原函数
```

**经典应用：借用方法**

```
// 类数组对象 arguments 没有数组的 slice 方法
function logArgs() {
  // 借用 Array.prototype.slice 方法
  const argsArray = Array.prototype.slice.call(arguments);
  console.log(argsArray); // 变成真正的数组: [1, 2, 3]
}
logArgs(1, 2, 3);
```

2.`apply()`- 立即调用，参数数组传递

**语法：** `function.apply(thisArg, [argsArray])`

```
const myInfo = ['Shanghai', 'China'];
introduce.apply(person, myInfo);
// 立即输出: "Hello, I'm Alice from Shanghai, China"
- 第一个参数是 `this`的新指向
- 第二个参数是**数组**（或类数组对象），包含所有要传递的参数
```

**经典应用：数组合并**

```
const numbers = [1, 2, 3];
const moreNumbers = [4, 5, 6];

// 将 moreNumbers 的元素 push 到 numbers 中
Array.prototype.push.apply(numbers, moreNumbers);
console.log(numbers); // [1, 2, 3, 4, 5, 6]

// 现代写法（ES6+）：
numbers.push(...moreNumbers);
```

3.`bind()`- 不立即调用，返回新函数

**语法：** `function.bind(thisArg, arg1, arg2, ...)`

```
// 不立即执行，而是返回一个新函数
const introduceAlice = introduce.bind(person, 'Tokyo');
// 此时还没有输出任何内容

// 需要手动调用新函数
introduceAlice('Japan'); 
// 输出: "Hello, I'm Alice from Tokyo, Japan"

// 也可以一次性绑定所有参数
const introduceAliceFromTokyoJapan = introduce.bind(person, 'Tokyo', 'Japan');
introduceAliceFromTokyoJapan(); 
// 输出: "Hello, I'm Alice from Tokyo, Japan"
- 返回一个**新函数**，其 `this`被永久绑定到 `thisArg`
- 绑定的参数是"部分应用"的，调用新函数时可以继续传递剩余参数
```

**经典应用：事件处理函数**

```
class Button {
  constructor() {
    this.text = 'Click me';
    // 将 handleClick 的 this 永久绑定到当前实例
    this.element = document.createElement('button');
    this.element.addEventListener('click', this.handleClick.bind(this));
  }

  handleClick() {
    console.log(`Button text: ${this.text}`); // 这里的 this 始终指向实例
  }
}
```

**连续使用 `bind`时，`this`的指向取决于第一个 `bind`调用，后续的 `bind`调用不会改变 `this`指向。**

这是一个非常重要的知识点，也是面试中常见的陷阱题。

**`bind()`创建的绑定函数的 `this`是永久性的，后续再次 `bind()`无法覆盖。**

```
const obj1 = { name: 'Object 1' };
const obj2 = { name: 'Object 2' };  
const obj3 = { name: 'Object 3' };

function showName() {
    console.log(this.name);
}

// 连续 bind
const boundFn = showName.bind(obj1).bind(obj2).bind(obj3);

boundFn(); // 输出: "Object 1"（而不是 Object 3！）
```

> 手写call

前置知识：

一、不同环境下的全局对象不同：

```
// 在浏览器中运行
console.log(window); // 存在，是全局对象
console.log(global); // undefined

// 在Node.js中运行  
console.log(window); // undefined
console.log(global); // 存在，是全局对象

// 在Web Workers或其他环境中
console.log(window); // undefined
console.log(global); // undefined
```

代码解析

```
context = context || (typeof window !== 'undefined' ? window : global);
```

这行代码的意思是：

1. 如果用户传入了 `context`，就使用用户传入的
2. 如果用户没传 `context`（即 `context`是 `null`或 `undefined`）：先检查 `window`是否存在（判断是否在浏览器环境）如果 `window`存在，使用 `window`作为默认 `this`指向如果 `window`不存在，使用 `global`（Node.js 环境）

二、一个对象调用了一个函数，那么这个函数内部的this指的就是这个对象。

在 JavaScript 中，**方法的 `this`指向调用该方法的对象**，函数也是一种对象。



手写call代码：
```js
Function.prototype.myCall = function(context, ...args) {
    console.log(this) //greet，mycall方法被greet函数对象调用，this指的是greet函数。
    // 1. 处理 context 为 null 或 undefined 的情况，默认指向 window（浏览器）或 global（Node.js）
    context = context || (typeof window !== 'undefined' ? window : global);
    
    // 2. 避免属性名冲突，使用 Symbol 创建唯一键
    const fnKey = Symbol('fn');
    
    // 3. 将当前函数（this）设置为 context 的方法
    context[fnKey] = this;

    // 现在content的内容包括：
    // person{
    //     name:'Alice',
    //     ['fn']:greet(){...}
    // }
    
    // 4. 执行函数，传入参数
    const result = context[fnKey](...args);
    
    // 5. 删除添加的属性，避免污染原对象
    delete context[fnKey];
    
    // 6. 返回执行结果
    return result;
};
```

测试：

```js
const person = {
    name: 'Alice'
};

function greet(age, city) {
    console.log(`Hello, I'm ${this.name}, ${age} years old, from ${city}`);
}

// 原生 call
greet.call(person, 25, 'Beijing');        // Hello, I'm Alice, 25 years old, from Beijing

// 手写 myCall
greet.myCall(person, 25, 'Beijing');      // Hello, I'm Alice, 25 years old, from Beijing

// 边界情况测试
greet.myCall(null, 30, 'Shanghai');       // Hello, I'm undefined, 30 years old, from Shanghai（指向全局）
```





> 手写apply

```js

Function.prototype.myApply = function(context, argsArray) {
    // 1. 处理 context
    context = context || (typeof window !== 'undefined' ? window : global);
    
    // 2. 处理参数数组（argsArray 可能为 undefined 或 null）
    const args = argsArray || [];
    
    // 3. 使用 Symbol 避免属性冲突
    const fnKey = Symbol('fn');
    
    // 4. 将函数设置为 context 的方法
    context[fnKey] = this;
    
    // 5. 执行函数，使用展开语法传递参数数组
    const result = context[fnKey](...args);
    
    // 6. 清理属性
    delete context[fnKey];
    
    // 7. 返回结果
    return result;
};
```

```js
const numbers = [1, 2, 3, 4, 5];

// 求最大值 - 原生 apply
const max1 = Math.max.apply(null, numbers);

// 求最大值 - 手写 myApply  
const max2 = Math.max.myApply(null, numbers);

console.log(max1, max2); // 5 5

// 数组拼接测试
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

Array.prototype.push.myApply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
```



> 手写bind

实现思路：

1. 返回一个新函数（闭包）
2. 新函数执行时，使用正确的 `this`上下文
3. 支持参数合并（绑定时参数 + 执行时参数）
4. 处理 `new`操作符的情况（构造函数调用）

代码实现：

```js
Function.prototype.myBind = function(context, ...bindArgs) {
    const originalFn = this;
    
    // 返回绑定函数
    const boundFn = function(...callArgs) {
        // 判断是否通过 new 调用（构造函数调用）
        const isNewCall = this instanceof boundFn;
        
        // 如果是 new 调用，this 指向新创建的对象，否则使用绑定的 context
        const thisContext = isNewCall ? this : context;
        
        return originalFn.apply(thisContext, [...bindArgs, ...callArgs]);
    };
    
    // 维护原型关系：确保 boundFn 与 originalFn 有相同的原型链
    // 这样 instanceof 操作符才能正常工作
    if (originalFn.prototype) {
        // 使用空函数中转，避免直接修改 boundFn.prototype 影响 originalFn.prototype
        const Empty = function() {};
        Empty.prototype = originalFn.prototype;
        boundFn.prototype = new Empty();
    }
    
    return boundFn;
};
```

```js
const person = {
    name: 'Alice'
};

function introduce(age, city, hobby) {
    console.log(`I'm ${this.name}, ${age} years old, from ${city}, like ${hobby}`);
}

// 原生 bind
const bound1 = introduce.bind(person, 25);
bound1('Beijing', 'coding');  // I'm Alice, 25 years old, from Beijing, like coding

// 手写 myBind  
const bound2 = introduce.myBind(person, 25);
bound2('Beijing', 'coding');  // I'm Alice, 25 years old, from Beijing, like coding

// 测试参数合并
const boundWithArgs = introduce.myBind(person, 25, 'Shanghai');
boundWithArgs('reading');  // I'm Alice, 25 years old, from Shanghai, like reading

// 测试 new 操作符
function Person(name) {
    this.name = name;
}

const BoundPerson = Person.myBind({}, 'Initial');
const instance = new BoundPerson();  // this 指向新实例，不是绑定的 {}
console.log(instance.name);  // 'Initial'
```













### 30.浏览器的垃圾回收机制

**垃圾回收**：`JavaScript`代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。

在 V8 中，会把堆分为**新生代和老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象：

- Major  GC(主垃圾回收器)

  ：主要负责老生代垃圾的回收

  - 内存占用比较小

- Minor GC(副垃圾回收器)

  ：主要负责新生代垃圾的回收

  - 对象的占用空间大  对象存活时间长 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b90d49a71ff04b1b926a00e4acc3cb8d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=801&h=540&s=47668&e=png&b=fefefe)

**新生代（副垃圾回收器）**

副垃圾回收器主要负责新⽣代的垃圾回收。大多数的对象最开始都会被分配在新生代，该存储空间相对较小，分为两个空间：**from 空间**（对象区）和 **to 空间**（空闲区）。

- 新增变量会放到`To`空间，当空间满后需要执行一次垃圾清理操作
- 对垃圾数据进行标记，标记完成后**将存活的数据复制到From空间中**，有序排列
- 交换两个空间，原来的`To`变成`From`，旧的`From`变成`To`

**老生代（主垃圾回收器）**

主垃圾回收器主要负责⽼⽣代中的垃圾回收。存储一些占用空间大、存活时间长的数据，采用**标记清除**算法进行垃圾回收。

主要分为**标记**、**清除**两个阶段。

- **标记**：将所有的变量打上标记0，然后从根节点(`window`对象、DOM树等)开始遍历，把存活的变量标记为1
- **清除**：清除标记为0的对象，释放内存。清除后将1的变量改为0，方便下一轮回收。

对⼀块内存多次执⾏标记清除算法后，会**产⽣⼤量不连续的内存碎⽚**。⽽碎⽚过多会导致⼤对象⽆法分配到⾜够的连续内存，于是⼜引⼊了另外⼀种算法——**标记整理**。

**标记整理**的标记过程仍然与标记清除算法⾥的是⼀样的，先标记可回收对象，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有**存活的对象都向⼀端移动**，然后直接清理掉这⼀端之外的内存。

**引用计数法**

一个对象被引用一次，引用数就+1，反之就-1。当引用为0，就会出发垃圾回收。

这种方式会产生一个问题，在循环引用时，引用数永远不会为0，无法回收。





### 31.哪些情况会导致内存泄漏

意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

被遗忘的计时器或回调函数：设置了 `setInterval` 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

脱离 `DOM` 的引用：获取一个 `DOM` 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。

闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。






