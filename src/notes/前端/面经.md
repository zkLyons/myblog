---
title:面经
---


# html/css




## JavaScript

### 1.说说JavaScript中的数据类型？存储上的差别？
在`JavaScript`中，我们可以分成两种类型：
- 基本类型
- 复杂类型
两种类型的区别是：存储位置不同
==基本类型==
基本类型主要为以下6种：

- Number
- String
字符串可以使用双引号（"）、单引号（'）或反引号（\`）标示，字符串是不可变的，意思是一旦创建，它们的值就不能变了
- Boolean
`Boolean`（布尔值）类型有两个字面值： `true` 和`false`,通过`Boolean`可以将其他类型的数据转化成布尔值
- Undefined
`Undefined` 类型只有一个值，就是特殊值 `undefined`。当使用 `var`或 `let`声明了变量但没有初始化时，就相当于给变量赋予了 `undefined`值。
包含`undefined` 值的变量跟未定义变量是有区别的

```js
let message; // 这个变量被声明了，只是值为 undefined

console.log(message); // "undefined"
console.log(age); // 没有声明过这个变量，报错
```
- null
`Null`类型同样只有一个值，即特殊值 `null`,逻辑上讲， null 值表示一个空对象指针
- symbol

他可以最为唯一的对象属性名称，作为 Symbol **最重要**的用途。由于每个 Symbol 都是唯一的，可以避免属性名冲突。

**场景：** 为对象添加"元数据"或"隐藏属性"

```
// 不同的库或模块可能都想给对象添加属性
const user = { name: 'Alice' };

// 模块A想添加一个标识
const MODULE_A_FLAG = Symbol('moduleA');
user[MODULE_A_FLAG] = true;

// 模块B也想添加类似的标识
const MODULE_B_FLAG = Symbol('moduleB'); 
user[MODULE_B_FLAG] = 'processed';

// 两个属性不会冲突，即使描述相同也不会冲突
const ANOTHER_FLAG = Symbol('moduleA'); // 描述相同但Symbol不同
user[ANOTHER_FLAG] = 'another';

console.log(user);
//控制台输出的信息可以观察到，第一个和第三个描述key都是一样的，但是实际上他们是完全独立的，
// {
//   name: 'Alice',
//   [Symbol(moduleA)]: true,
//   [Symbol(moduleB)]: 'processed',
//   [Symbol(moduleA)]: 'another'
// }
//对于同名key该如何访问呢？
console.log(user[MODULE_A_FLAG]) //true
console.log(user[ANOTHER_FLAG])  //another
```





==引用类型==
复杂类型统称为`Object`，我们这里主要讲述下面三种：

- Object
- Array
- Function

==存储区别==
基本数据类型和引用数据类型存储在内存中的位置不同：

- 基本数据类型存储在栈中    
- 引用类型的对象存储于堆中



1. **基本数据类型 (Primitives):**
   - 存在栈里。
   - `let a = 10;` 栈上的 `a` 变量就**直接**保存着 `10` 这个**值**。
2. **引用数据类型 (References):**
   - **地址**在栈里。
   - **值**（即对象 `{...}` 或数组 `[...]` 本身）在堆里。
   - `let obj = { name: 'Tom' };` 栈上的 `obj` 变量保存的是一个**地址**（比如 `0x1A2B`），这个地址指向堆内存中存储 `{ name: 'Tom' }` 的那个位置。



- **栈 (Stack)** 是高度有序的，必须严格遵循**后进先出 (LIFO)** 的规则来分配和释放，就像叠盘子，非常高效。
- **堆 (Heap)** 就像一个大仓库，当你需要存东西（创建对象）时，系统就在仓库里找个**大小足够的空位**把东西放进去，它不需要按顺序放。因此，它的内存分配是**动态**且相对**无序**的。



==小结==

- 声明变量时不同的内存地址分配：
    - 简单类型的值存放在栈中，在栈中存放的是对应的值
    - 引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址
- 不同的类型数据导致赋值变量时的不同：
    - 简单类型赋值，是生成相同的值，两个对象对应不同的地址
    - 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象



### 2.数组常用的方法有哪些

现总结：
- 数组和字符串的转换方法：`toString()`、`toLocalString()`、`join()` 其中 `join()` 方法可以指定转换为字符串时的分隔符。

```js
console.log(num.toString()); // "123"
//返回对象的本地化字符串表示，根据语言环境和地区设置格式化。
const number = 1234567.89;
console.log(number.toString()); // "1234567.89"
console.log(number.toLocaleString()); // 中文环境："1,234,567.89"
console.log(number.toLocaleString('de-DE')); // 德语环境："1.234.567,89"
console.log(number.toLocaleString('ar-EG')); // 阿拉伯语环境："١٬٢٣٤٬٥٦٧٫٨٩"
```



- 数组尾部操作的方法 `pop()` 和 `push()`，`push` 方法可以传入多个参数。

- 数组首部操作的方法 `shift()` 和 `unshift()` ，重排序的方法 `reverse()` 和 `sort()`，`sort()` 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。

- 数组连接的方法 `concat()` ，返回的是拼接好的数组，不影响原数组。

- 数组截取办法 `slice()`，用于截取数组中的一部分返回，不影响原数组。

- 数组插入方法 `splice()`，影响原数组查找特定项的索引的方法`indexOf()` 和 `lastIndexOf()` ，迭代方法 `every()`、`some()`、`filter()`、`map()` 和`forEach()`方法

```
//every用于判断元素是否全部都满足条件，任何一个不满足就返回false
const numbers1 = [1, 2, 3, 4, 5];
const allPositive = numbers1.every(num => num > 0);
console.log(allPositive); // true

some()- 至少有一个元素满足条件

filter()- 过滤留下满足条件的元素
map()- 映射/转换每个元素
```

- 数组归并方法 `reduce()` 方法

```js
// 使用reduce
const sumReduce = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(sumReduce); // 15
```

- **改变原数组的方法**：`fill()`、`pop()`、`push()`、`shift()`、`splice()`、`unshift()`、`reverse()`、`sort()`；

```
array.fill(value, start, end)
// 填充整个数组
const arr1 = new Array(5).fill(0);
console.log(arr1); // [0, 0, 0, 0, 0]
```



- **不改变原数组的方法**：`concat()`、`every()`、`filter()`、`find()`、`findIndex()`、`forEach()`、`indexOf()`、`join()`、`lastIndexOf()`、`map()`、`reduce()`、`reduceRight()`、`slice()`、`some()`。



>增删查改

数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生
影响，哪些方法不会
==增==
下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响

- push()
  `push()`方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
- unshift()
  unshift()在数组开头添加任意多个值，然后返回新的数组长度
- splice()
  传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组
- concat(）
  首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组





==删==

下面三种都会影响原数组，最后一项不影响原数组：

- pop()
  `pop()` 方法用于删除数组的最后一项，同时减少数组的`length` 值，返回被删除的项
- shift()、
  `shift()`方法用于删除数组的第一项，同时减少数组的`length` 值，返回被删除的项
- splice()
  传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组
- slice(）
slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组

==改==
splice
传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响
==查==
即查找元素，返回元素坐标或者元素值

- indexOf()
返回要查找的元素在数组中的位置，如果没找到则返回 -1
- includes()
返回要查找的元素在数组中的位置，找到返回`true`，否则`false`
- find()
返回第一个匹配的元素
>排序方法


数组有两个方法可以用来对元素重新排序：
- reverse()
顾名思义，将数组元素方向反转
- sort()
sort()方法接受一个比较函数，用于判断哪个值应该排在前面
```js
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
let values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); // 0,1,5,10,15
```


>转换方法

join
join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串

```js
let colors = ["red", "green", "blue"];
alert(colors.join(",")); // red,green,blue
alert(colors.join("||")); // red||green||blue
```

>迭代方法
- some()
对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let someResult = numbers.some((item, index, array) => item > 2);
console.log(someResult) // true
```
- every()
对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let everyResult = numbers.every((item, index, array) => item > 2);
console.log(everyResult) // false
```
- forEach()
没有返回值
- filter()
对数组每一项都运行传入的函数，函数返回 `true` 的项会组成数组之后返回
- map()
对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组



```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let mapResult = numbers.map((item, index, array) => item * 2);
console.log(mapResult) // 2,4,6,8,10,8,6,4,2
```

### 3.字符串常用的方法
==增==
这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作
除了常用`+`以及`${}`进行字符串拼接之外，还可通过`concat`

```js
concat
let stringValue = "hello ";
let result = stringValue.concat("world");
console.log(result); // "hello world"
console.log(stringValue); // "hello"
```

==删==
这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作
常见的有：

- slice()
- substr()
- substring()

这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。

```js
let stringValue = "hello world";
console.log(stringValue.slice(3)); // "lo world"
console.log(stringValue.substring(3)); // "lo world"
console.log(stringValue.substr(3)); // "lo world"
console.log(stringValue.slice(3, 7)); // "lo w"
console.log(stringValue.substring(3,7)); // "lo w"
console.log(stringValue.substr(3, 7)); // "lo worl"
```
==改==
这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作
常见的有：

- trim()、trimLeft()、trimRight()
删除前、后或前后所有空格符，再返回新的字符串
```js
let stringValue = " hello world ";
let trimmedStringValue = stringValue.trim();
console.log(stringValue); // " hello world "
console.log(trimmedStringValue); // "hello world"
```
- repeat()
```js
let stringValue = "na ";
let copyResult = stringValue.repeat(2) // na na 
```
- padStart()、padEnd()
复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件
```js
let stringValue = "foo";
console.log(stringValue.padStart(6)); // " foo"
console.log(stringValue.padStart(9, ".")); // "......foo"
```
- toLowerCase()、 toUpperCase()



==查==
除了通过索引的方式获取字符串的值，还可通过：

- chatAt()
返回给定索引位置的字符，由传给方法的整数参数指定

```js
let message = "abcde";
console.log(message.charAt(2)); // "c"
```
- indexOf()
从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）

```js
let stringValue = "hello world";
console.log(stringValue.indexOf("o")); // 4
```
- startWith()
- includes()
从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值

```js
let message = "foobarbaz";
console.log(message.startsWith("foo")); // true
console.log(message.startsWith("bar")); // false
console.log(message.includes("bar")); // true
console.log(message.includes("qux")); // false
```
==转换方法==
把字符串按照指定的分割符，拆分成数组中的每一项

```js
let str = "12+23+34"
let arr = str.split("+") // [12,23,34]
```

==模板匹配方法==
针对正则表达式，字符串设计了几个方法：

- match()
接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，返回数组。
```js
let text = "cat, bat, sat, fat";
let pattern = /.at/;
let matches = text.match(pattern);
console.log(matches[0]); // "cat"
```
- search()
接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，找到则返回匹配索引，否则返回 -1

```js
let text = "cat, bat, sat, fat";
let pos = text.search(/at/);
console.log(pos); // 1
```
- replace()
接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）
```js
let text = "cat, bat, sat, fat";
let result = text.replace("at", "ond");
console.log(result); // "cond, bat, sat, fat"
```

### 4. 谈谈js中的类型转换机制
常见的类型转换有：
- 强制转换（显示转换）

- 自动转换（隐式转换）

  

  ==显示转换==
  显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：

- Number()

- parseInt()

- String()

- Boolean(）

**number()**
将任意类型的值转化为数值
先给出类型转换规则：
实践一下：

```js
Number(324) // 324
// 字符串：如果可以被解析为数值，则转换为相应的数值
Number('324') // 324
// 字符串：如果不可以被解析为数值，返回 NaN
Number('324abc') // NaN
// 空字符串转为0
Number('') // 0
// 布尔值：true 转成 1，false 转成 0
Number(true) // 1
Number(false) // 0
// undefined：转成 NaN
Number(undefined) // NaN
// null：转成0
Number(null) // 0
// 对象：通常转换成NaN(除了只包含单个数值的数组)
Number({a: 1}) // NaN
Number([1, 2, 3]) // NaN
Number([5]) // 5
```

从上面可以看到，`Number`转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`
**parseint**
`parseInt`相比`Number`，就没那么严格了，`parseInt`函数逐个解析字符，遇到不能转换的字符就停下来

```js
parseInt('32a3') //32
```

**string**
可以将任意类型的值转化成字符串
实践一下：

```js
// 数值：转为相应的字符串
String(1) // "1"
//字符串：转换后还是原来的值
String("a") // "a"
//布尔值：true转为字符串"true"，false转为字符串"false"
String(true) // "true"
//undefined：转为字符串"undefined"
String(undefined) // "undefined"
//null：转为字符串"null"
String(null) // "null"
//对象
String({a: 1}) // "[object Object]"
String([1, 2, 3]) // "1,2,3"
```

**Boolean**

```js
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```

==隐式转换==
在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？

我们这里可以归纳为两种情况发生隐式转换的场景：

- 比较运算（`==`、`!=`、`>`、`<`）、`if`、`while`需要布尔值地方
- 算术运算（`+`、`-`、`*`、`/`、`%`）

除了上面的场景，还要求运算符两边的操作数不是同一类型
**自动转换为布尔值**
在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用`Boolean`函数

可以得出个小结：
- undefined

- null

- false

- +0

- -0

- NaN

- ""
  除了上面几种会被转化成`false`，其他都换被转化成`true`

  

**自动转换为字符串**

遇到预期为字符串的地方，就会将非字符串的值自动转为字符串

具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串

常发生在`+`运算中，一旦存在字符串，则会进行字符串拼接操作

```js
'5' + 1 // '51'
'5' + true // "5true"
'5' + false // "5false"
'5' + {} // "5[object Object]"
'5' + [] // "5"
'5' + function (){} // "5function (){}"
'5' + undefined // "5undefined"
'5' + null // "5null"
```
**自动转换为数值**
除了`+`有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值

```js
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN
```



###  5.\==和\=\==区别，分别在什么情况下使用

==\==操作符==
等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 `true`

前面文章，我们提到在`JavaScript`中存在隐式转换。等于操作符（\==）在比较中会先进行类型转换，再确定操作数是否相等。

遵循以下规则：

如果任一操作数是布尔值，则将其转换为数值再比较是否相等

```js
let result1 = (true == 1); // true
```

如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等

```js
let result1 = ("55" == 55); // true
```

如果一个操作数是对象，另一个操作数不是，则调用对象的 `valueOf()`方法取得其原始值，再根据前面的规则进行比较

```js
let obj = {valueOf:function(){return 1}}
let result1 = (obj == 1); // true
```

`null`和`undefined`相等

```js
let result1 = (null == undefined ); // true
```

如果有任一操作数是 `NaN` ，则相等操作符返回 `false`

```js
let result1 = (NaN == NaN ); // false
```

如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回`true`

```js
let obj1 = {name:"xxx"}
let obj2 = {name:"xxx"}
let result1 = (obj1 == obj2 ); // false
```

下面进一步做个小结：

- 两个都为简单类型，字符串和布尔值都会转换成数值，再比较
  
- 简单类型与引用类型比较，对象转化成其原始类型的值，再比较
  
- 两个都为引用类型，则比较它们是否指向同一个对象
  
- null 和 undefined 相等
  
- 存在 NaN 则返回 false

==\=\==操作符==
全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 `true`。即类型相同，值也需相同

```
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`undefined` 和 `null` 与自身严格相等

```
let result1 = (null === null)  //true
let result2 = (undefined === undefined)  //false
```

==区别==
相等操作符（\==）会做类型转换，再进行值的比较，全等运算符不会做类型转换

```
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`null` 和 `undefined` 比较，相等操作符（\==）为`true`，全等为`false`

```js
let result1 = (null == undefined ); // true
let result2 = (null  === undefined); // false
```

==总结==
相等运算符隐藏的类型转换，会带来一些违反直觉的结果

```js
'' == '0' // false
0 == '' // true
0 == '0' // true

false == 'false' // false
false == '0' // true

false == undefined // false
false == null // false
null == undefined // true

' \t\r\n' == 0 // true
```

但在比较`null`的情况的时候，我们一般使用相等操作符`==`

```js
const obj = {};

if(obj.x == null){
  console.log("1");  //执行
}
```

等同于下面写法

```js
if(obj.x === null || obj.x === undefined) {
    ...
}
```

使用相等操作符（\==）的写法明显更加简洁了

所以，除了在比较对象属性为`null`或者`undefined`的情况下，我们可以使用相等操作符（\==），其他情况建议一律使用全等操作符（\=\==）

---



### 6. 深拷贝和浅拷贝的区别？如何实现深拷贝？


下面简单实现一个浅拷贝

```js
function shallowClone(obj) {
    const newObj = {};
    for(let prop in obj) {
        if(obj.hasOwnProperty(prop)){
            newObj[prop] = obj[prop];
        }
    }
    return newObj;
}
只是复制了地址，如果对深层次的数据进行修改，源数据也会发生变化。
只是复制了第一层属性/元素的值引用，而不复制嵌套对象或数组的内部结构。
```

hasOwnProperty 是 JavaScript 中 **对象原型方法**（Object.prototype.hasOwnProperty），它的作用是：

> **判断一个属性是否是对象“自身的属性”（own property），而不是从原型链上继承来的。**

JavaScript 是基于**原型继承**的语言，对象可以从原型链上继承属性。

```
const obj = { name: 'Alice' };
```
obj 除了有 name 属性外，还能访问 toString、hasOwnProperty 等方法，这些是继承自 Object.prototype 的。

```
'name' in obj;           // true  ← 自身属性
'toString' in obj;       // true  ← 继承来的！
```
使用 in 操作符**无法区分**是自身属性还是继承属性。
而 hasOwnProperty **只检查自身**：

```
obj.hasOwnProperty('name');       // true
obj.hasOwnProperty('toString');   // false ←--不是自身的
```

在`JavaScript`中，存在浅拷贝的现象有：

- `Object.assign`
- `Array.prototype.slice()`, `Array.prototype.concat()`
- 使用拓展运算符实现的复制

Object.assign

```
var obj = {
    age: 18,
    nature: ['smart', 'good'],
    names: {
        name1: 'fx',
        name2: 'xka'
    },
    love: function () {
        console.log('fx is a great girl')
    }
}
var newObj = Object.assign({}, fxObj);
newObj.nature[0]='abc'
console.log(obj.nature[0]) //'abc',被修改了。
```

slice()

```
const arr = [1, { name: 'Alice' }, [10, 20]]; //这是一个数组，不是类数组对象

const copy = arr.slice();
copy[1].name = 'Bob'; console.log(arr[1].name); // 'Bob' ← 原数组也被改了！

```

concat()

```
const arr = [1, { age: 25 }];
const copy = arr.concat(); // 等价于 [].concat(arr)
copy[1].age = 30; 
console.log(arr[1].age); // 30 ← 共享引用

```

拓展运算符

```
const obj = { a: 1, b: { x: 10 }, c: [1, 2] };
const copy = { ...obj };
copy.b.x = 99; 
console.log(obj.b.x); // 99 ← 原对象被改了！

```

==深拷贝==
深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

- _.cloneDeep()
  
- jQuery.extend()
  
- JSON.stringify()
  
- 手写循环递归
  

**\_cloneDeep**

```js
const _ = require('lodash');
//- 引入 **Lodash** 库，一个流行的 JavaScript 工具库。
- _ 是 Lodash 的默认导出对象，包含大量实用函数。
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
```

**jQuery.extend()**

```js
const $ = require('jquery');
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

**JSON.stringfy()**

```js
const obj2=JSON.parse(JSON.stringify(obj1））
//先把对象转换为JSON字符串，序列化
//在把JSON字符串转换为js对象，反序列化
//得到一个与 obj1 结构相同、但完全独立的新对象（深拷贝）
```

但是这种方式存在弊端，会忽略`undefined`、`symbol`和`函数`
```js
const obj = {
    name: 'A',
    name1: undefined,
    name3: function() {},
    name4:  Symbol('A')
}
const obj2 = JSON.parse(JSON.stringify(obj));
console.log(obj2); // {name: "A"}
```

**递归循环**
```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```

###  7. 什么是闭包？应用场景有哪些？

==什么是闭包==

在一个函数环境中，闭包=函数+词法环境。
在 JavaScript（前端最常用的语言）里，**闭包（Closure）**指的是 **函数 + 它能够访问的外层函数作用域中的变量** 的组合。

**先总结：**

**闭包优点：**

- 创建全局私有变量，避免变量全局污染
- 可以实现封装、缓存等

**闭包缺点：**

- 创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出
  - **解决：** 在不需要使用的时候把变量设为`null`

**使用场景：**

- 用于创建全局私有变量
- 封装类和模块
- 实现函数柯里化

闭包一定会造成内存泄漏吗？

闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。只要合理的使用闭包，就不会造成内存泄漏。



它的核心价值在于：

1. **数据私有化 / 封装** 让变量只能被内部函数访问，外部无法直接读取或修改，实现“私有成员”。
2. **保持状态（记忆功能）** 每次调用闭包函数时，都能“记住”之前创建时的环境变量，实现计数器、缓存、配置等持久化状态。
3. **模块化 / 避免全局污染** 通过立即执行函数（IIFE）或模块模式，把实现细节隐藏，只暴露必要的 API。
4. **实现柯里化、函数工厂、事件绑定、回调等高级模式**

1.数据私有化,保持状态

```js
function createCounter() {
  let count = 0;               // 私有变量
  return function () {         // 闭包
    return ++count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// 外部无法直接访问 count
console.log(typeof count); // undefined
```

**解释**

- count 只在 createCounter 的词法环境中。
- 返回的匿名函数形成了闭包，**记住**了 count。
- 每次调用 counter() 都会操作同一个 count，实现私有计数器。

2.函数工厂（柯里化）

```js
function makeAdder(base) {
  return function (x) {
    return base + x;   // 记住 base
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(3));  // 8
console.log(add10(3)); // 13
```

3.模块函数

```JS
const MyModule = (function () {
  // 私有数据
  const API_KEY = 'abc123';
  const cache = {};

  // 私有方法
  function _fetch(url) {
    if (cache[url]) return cache[url];
    // 模拟异步请求
    return fetch(url + '?key=' + API_KEY).then(res => {
      cache[url] = res;
      return res;
    });
  }

  // 暴露的公共 API
  return {
    get: _fetch,
    clearCache() {
      for (let k in cache) delete cache[k];
    }
  };
})();

MyModule.get('/data').then(console.log);
MyModule.clearCache();
```


==应用场景==


| 作用          | 典型场景                  | 关键点                 |
| ------------- | ------------------------- | ---------------------- |
| **数据私有**  | 计数器、配置对象          | 外部不可直接访问变量   |
| **保持状态**  | 防抖/节流、缓存           | 闭包记住上一次调用环境 |
| **模块化**    | IIFE 模块、ES6 前私有成员 | 只暴露 API             |
| **循环/事件** | for 循环绑定事件          | 用闭包捕获每次迭代的值 |

==会不会造成内存泄露==
闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。如果后续还需要使用这个闭包变量，那么就没有造成泄露。

---



### 8.谈谈你对作用域链的理解

==一、作用域==
作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合
换句话说，作用域决定了代码区块中变量和其他资源的可见性
举个例子

```
function myFunction() {
    let inVariable = "函数内部变量";
}
myFunction();//要先执行这个函数，否则根本不知道里面是啥
console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined
```

上述例子中，函数`myFunction`内部创建一个`inVariable`变量，当我们在全局访问这个变量的时候，系统会报错
这就说明我们在全局是无法获取到（闭包除外）函数内部的变量
我们一般将作用域分成：

- 全局作用域

- 函数作用域

- 块级作用域
  **1.全局作用域**

任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问

```
// 全局变量
var greeting = 'Hello World!';
function greet() {
  console.log(greeting);
}
// 打印 'Hello World!'
greet();
```

**2.函数作用域**

函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问

```
function greet() {
  var greeting = 'Hello World!';
  console.log(greeting);
}
// 打印 'Hello World!'
greet();
// 报错： Uncaught ReferenceError: greeting is not defined
console.log(greeting);
```

可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域

**3.块级作用域**

ES6引入了`let`和`const`关键字,和`var`关键字不同，在大括号中使用`let`和`const`声明的变量存在于块级作用域中。在大括号之外不能访问这些变量

```
{
  // 块级作用域中的变量
  let greeting = 'Hello World!';
  var lang = 'English';
  console.log(greeting); // Prints 'Hello World!'
}
// 变量 'English'
console.log(lang);
// 报错：Uncaught ReferenceError: greeting is not defined
console.log(greeting);
```

==二、词法作用域==
词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，`JavaScript` 遵循的就是词法作用域。函数访问外部变量时，依据的是函数定义时的位置，而不是调用时的位置。

```
var a = 2;
function foo(){
    console.log(a)
}
function bar(){
    var a = 3;
    foo(); //2
}
bar()
```

由于`JavaScript`遵循词法作用域，相同层级的 `foo` 和 `bar` 就没有办法访问到彼此块作用域中的变量，所以输出2
==三、作用域链==
当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域

如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错

这里拿《你不知道的Javascript(上)》中的一张图解释：

把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域。

变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止

下面代码演示下：

```
var sex = '男';
function person() {
    var name = '张三';
    function student() {
        var age = 18;
        console.log(name); // 张三
        console.log(sex); // 男 
    }
    student();
    console.log(age); // Uncaught ReferenceError: age is not defined
}
person();
```

上述代码主要主要做了以下工作：

- `student`函数内部属于最内层作用域，找不到`name`，向上一层作用域`person`函数内部找，找到了输出“张三”
- `student`内部输出`sex`时找不到，向上一层作用域`person`函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男”
- 在`person`函数内部输出`age`时找不到，向上一层作用域找，即全局作用域，还是找不到则报错



---



### 9.JS原型、原型链？有什么特点？

==1.原型==
`JavaScript` 常被描述为一种基于原型的语言——每个对象拥有一个原型对象

当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的`prototype`属性上，而非实例对象本身

下面举个例子：

函数可以有属性。 每个函数都有一个特殊的属性叫作原型`prototype`

```
function doSomething(){}
console.log( doSomething.prototype );
```

控制台输出

```
{
    constructor: ƒ doSomething(),
    __proto__: {
        constructor: ƒ Object(),
        hasOwnProperty: ƒ hasOwnProperty(),
        isPrototypeOf: ƒ isPrototypeOf(),
        propertyIsEnumerable: ƒ propertyIsEnumerable(),
        toLocaleString: ƒ toLocaleString(),
        toString: ƒ toString(),
        valueOf: ƒ valueOf()
    }
}
```

上面这个对象，就是大家常说的原型对象

可以看到，原型对象有一个自有属性`constructor`，这个属性指向该函数，如下图关系展示
![image-20251116222532494](.\assets\image-20251116222532494.png)





==2.原型链==
原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法

在对象实例和它的构造器之间建立一个链接（它是`__proto__`属性，是从构造函数的`prototype`属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法

下面举个例子：

```
function Person(name) {
    this.name = name;
    this.age = 18;
    this.sayName = function() {
        console.log(this.name);
    }
}
// 第二步 创建实例
var person = new Person('person')
```



下面分析一下：

- 构造函数`Person`存在原型对象`Person.prototype`

- 构造函数生成实例对象`person`，`person`的`__proto__`指向构造函数`Person`原型对象

- `Person.prototype.__proto__` 指向内置对象，因为 `Person.prototype` 是个对象，默认是由 `Object`函数作为类创建的，而 `Object.prototype` 为内置对象

- `Person.__proto__` 指向内置匿名函数 `anonymous`，因为 Person 是个函数对象，默认由 Function 作为类创建

- `Function.prototype` 和 `Function.__proto__`同时指向内置匿名函数 `anonymous`，这样原型链的终点就是 `null`

==3.总结==
下面首先要看几个概念：

`__proto__`作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的

每个对象的`__proto__`都是指向它的构造函数的原型对象`prototype`的

```
person1.__proto__ === Person.prototype
```

构造函数是一个函数对象，是通过 `Function`构造器产生的

```
Person.__proto__ === Function.prototype
```

原型对象本身是一个普通对象，而普通对象的构造函数都是`Object`

```
Person.prototype.__proto__ === Object.prototype
```

刚刚上面说了，所有的构造器都是函数对象，函数对象都是 `Function`构造产生的

```
Object.__proto__ === Function.prototype
```

`Object`的原型对象也有`__proto__`属性指向`null`，`null`是原型链的顶端

```
Object.prototype.__proto__ === null
```

下面作出总结：

- 一切对象都是继承自`Object`对象，`Object` 对象直接继承根源对象`null`

- 一切的函数对象（包括 `Object` 对象），都是继承自 `Function` 对象

- `Object` 对象直接继承自 `Function` 对象

- `Function`对象的`__proto__`会指向自己的原型对象，最终还是继承自`Object`对象

---





### 10.JS如何实现继承

==1.继承是什么？==
继承（inheritance）是面向对象软件技术当中的一个概念。
如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类”

- 继承的优点
  继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码
  在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能
  虽然`JavaScript`并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富
  关于继承，我们举个形象的例子：
  定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等

```
class Car{
    constructor(color,speed){
        this.color = color
        this.speed = speed
        // ...
    }
}
```

由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱

```
// 货车
class Truck extends Car{
    constructor(color,speed){
        super(color,speed)
        this.Container = true // 货箱
    }
}
```

这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性

在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法

```
class Truck extends Car{
    constructor(color,speed){
        super(color,speed)
        this.color = "black" //覆盖
        this.Container = true // 货箱
    }
}
```

从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系
==2.实现方式==

下面给出`JavaScripy`常见的继承方式：

- 原型链继承
- 构造函数继承（借助 call）
- 组合继承
- 原型式继承
- 寄生式继承
- 寄生组合式继承


> 原型链继承

原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针

举个例子

```
 function Parent() {
    this.name = 'parent1';
    this.play = [1, 2, 3]
  }
  function Child() {
    this.type = 'child2';
  }
  //这里的指的就是上面的Child函数，也就是构造方法。
  Child.prototype = new Parent();
  console.log(new Child())
```

![image-20251116222635970](.\assets\image-20251116222635970.png)
上面代码看似没问题，实际存在潜在问题

```
var s1 = new Child();
var s2 = new Child();
s1.play.push(4);
console.log(s1.play, s2.play); // [1,2,3,4]
```

改变`s1`的`play`属性，会发现`s2`也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的


>构造函数继承（借助 call）

借助 `call`调用`Parent`函数

```
function Parent(){
    this.name = 'parent1';
}
//给原型对象设置了一个属性方法getName
Parent.prototype.getName = function () {
    return this.name;
}

function Child(){
//- **在 Child 内部，把 Parent 当成普通函数执行，但强制把 Parent 里的 `this` 指向当前正在创建的 Child 实例**。
//结果：每个 Child 实例都会**复制一份** `name` 属性，**不会共享**。
    Parent.call(this);
    this.type = 'child'
}

let child = new Child();
console.log(child);  // 没问题
//`child` 自己身上确实有了 `name`，但**并没有继承 Parent.prototype 上的方法**。
console.log(child.getName());  // 会报错
```

借用构造函数继承**只能“搬”父类构造函数里的实例属性**，**搬不到父类原型上的方法**；  

因此**引用属性不共享**是优点，**原型方法丢失**是缺点。

相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法


>组合继承

将构造函数继承和原型链继承组合到一起

```js
┌-------- ① 定义部分 --------┐
function Parent(){
    this.name   = 'parent';
    this.play   = [1,2,3];     // 引用类型
}
Parent.prototype.getName = function(){
    return this.name;
};

function Child(){
    Parent.call(this);        // ② 第二次调用 —— 为每个实例复制一份 name + play,覆盖了第一次调用的原型链提供的name和play，从此属性不再共享了。
    this.type = 'child3';
}

Child.prototype = new Parent();  // ① 第一次调用 —— 为原型链提供 getName,name,play
//构造函数在初始化的时候，会默认分配一个原型对象，该原型对象内容为{constructor:Child...}
//现在我们强行改变了原型对象为Parent实例，现在新的原型对象内容为Child.prototype也就是parent实例对象，实例对象没有constructor属性，这里我们就手动创建一个，让其纠正为Child，而不是通过--proto--原型链
//找到parent的构造函数
Child.prototype.constructor = Child;

┌-------- ③ 使用部分 --------┐
var s3 = new Child();
var s4 = new Child();
s3.play.push(4);
console.log(s3.play); // [1,2,3,4]
console.log(s4.play); // [1,2,3]   ←— 互不影响 ✅
console.log(s3.getName()); // 'parent' ✅
```

把“属性”和“方法”拆成两条跑道

| 要继承的东西                                                 | 存在位置                | 该用哪种手段                             |
| :----------------------------------------------------------- | :---------------------- | :--------------------------------------- |
| **实例属性**（name、play 等）                                | 父类构造函数体内        | 借用构造函数  <br>`Parent.call(this)`    |
| **原型方法**（getName 等）                                   | 父类 `Parent.prototype` | 原型链继承  <br>`Child.prototype = 对象` |
| 这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到`Parent` 执行了两次，造成了多构造一次的性能开销 |                         |                                          |


> 原型式继承

这里主要借助`Object.create`方法实现普通对象的继承

```
let parent = {
    name: "parent",
    friends: ["p1", "p2", "p3"],
    getName: function() {
      return this.name;
    }
  };

  let person = Object.create(parent);
  //相当于
  //let person={}
  //person.__proto__=parent
  
  person.name = "tom";
  person.friends.push("jerry");

  let person = Object.create(parent);
  person.friends.push("lucy");

  console.log(person.name); // tom
  console.log(person.name === person.getName()); // true
  console.log(person.name); // parent
  console.log(person.friends); // ["p1", "p2", "p3","jerry","lucy"]
  console.log(person.friends); // ["p1", "p2", "p3","jerry","lucy"]
```

这种继承方式的缺点也很明显，因为`Object.create`方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能

Object.create 把**普通对象直接当原型**；  

值类型属性“读共享、写复制”，引用类型属性“读写都共享”；  

想不互串，就要在子对象里**重新赋值整个数组**，而不是**原地修改**。
想要让friends也独立，这样做

```javascript
let person4 = Object.create(parent);
person4.friends = [...parent.friends]; // 复制一份再改
person4.friends.push('jerry');
```


>寄生式继承


寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法

```js
let parent = {
    name: 'parent',
    friends: ['p1','p2','p3'],
    getName() { return this.name; }
};

function clone(original) {
    // ① 浅拷贝：新建对象，并把 original 设为其原型
    let clone = Object.create(original);

    // ② 增强：给这个副本额外挂一个方法
    clone.getFriends = function () {
        return this.friends;   // 这里的 this 指向运行时调用者
    };

    return clone;              // 返回“加强版”对象
}

let person = clone(parent);
```

- `getName` 沿原型链找到 `parent.getName`

- `getFriends` 是**直接挂在 person 自己身上**的方法，因此**每个克隆体都有一份新函数**（内存开销比原型方式大）。

```javascript
console.log(person.getName());    // parent
console.log(person.getFriends()); // ["p1","p2","p3"]
```

好绕呀，没看明白。


>寄生组合式继承

寄生组合式继承，借助解决普通对象的继承问题的`Object.create` 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式

```
function clone (parent, child) {
    // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
}

function Parent6() {
    this.name = 'parent6';
    this.play = [1, 2, 3];
}
Parent6.prototype.getName = function () {
    return this.name;
}
function Child6() {
    Parent6.call(this);
    this.friends = 'child5';
}

clone(Parent6, Child6);

Child6.prototype.getFriends = function () {
    return this.friends;
}

let person6 = new Child6();
console.log(person6); //{friends:"child5",name:"child5",play:[1,2,3],__proto__:Parent6}
console.log(person6.getName()); // parent6
console.log(person6.getFriends()); // child5
```

可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题

文章一开头，我们是使用`ES6` 中的`extends`关键字直接实现 `JavaScript`的继承

```
class Person {
  constructor(name) {
    this.name = name
  }
  // 原型方法
  // 即 Person.prototype.getName = function() { }
  // 下面可以简写为 getName() {...}
  getName = function () {
    console.log('Person:', this.name)
  }
}
class Gamer extends Person {
  constructor(name, age) {
    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
    super(name)
    this.age = age
  }
}
const asuna = new Gamer('Asuna', 20)
asuna.getName() // 成功访问到父类的方法
```

利用`babel`工具进行转换，我们会发现`extends`实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。
晕

---



### 11.instanceof 运算符的实现原理及实现

该运算符通过原型链检查判断对象是否属于特定类型。当执行 `key instanceof Array` 返回 `true` 时，说明变量 `key` 的原型链中存在 `Array.prototype`，即 `key` 是通过数组构造函数创建的实例。

`instanceof` 原理一句话：

> **不断拿右边构造函数的原型（`prototype`），去跟左边对象的整条原型链（`__proto__`）做全等比对**，只要有一次命中就返回 `true`，走到 `null` 还没命中就返回 `false`。

模拟实现（ES5 版，20 行不到）

```javascript
function myInstanceOf(left, right) {
  // 基本类型直接出局
  if (left === null || (typeof left !== 'object' && typeof left !== 'function')) {
    return false;
  }

  // 取目标原型
  const target = right.prototype;

  // 兼容 IE 非标准 __proto__
  left = left.__proto__;

  while (left !== null) {
    if (left === target) return true;
    left = left.__proto__; // 继续往上爬
  }
  return false;
}


```



快速验证

```javascript
function Foo() {}
const f = new Foo();

console.log(myInstanceOf(f, Foo));      // true
console.log(myInstanceOf(f, Object));   // true
console.log(myInstanceOf([], Array));   // true
console.log(myInstanceOf(123, Number)); // false
```

---

### 12.typeof 和 instanceof 区别

一句话先给结论：  

**`typeof` 只能告诉你“基本类型”或“是不是函数”；**  

**`instanceof` 只能告诉你“对象是谁构造的，沿着原型链找”。**

| 对比维度     | typeof                                                       | instanceof                                      |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------- |
| 返回值       | `'string' \| 'number' \| 'boolean' \| 'undefined' \| 'function' \| 'object' \| 'symbol' \| 'bigint'` | `true / false`                                  |
| 判断依据     | 机器码低位（Tag）                                            | 原型链（`__proto__` 能否找到 `Ctor.prototype`） |
| 适合基本类型 | ✅ 精准                                                       | ❌ 报错或 false（非对象）                        |
| 适合对象细分 | ❌ 统称 `'object'` 或 `'function'`                            | ✅ 精准识别数组、日期、自定义类等                |
| 常见坑       | `typeof null === 'object'`                                   | 跨 iframe 原型链断裂会 false                    |

```javascript
typeof 42;                           // 'number'
typeof 'abc';                        // 'string'
typeof null;                         // 'object'（历史 bug）
typeof [];                           // 'object'
typeof function f(){};               // 'function'

[] instanceof Array;                 // true
[] instanceof Object;                // true
new Date() instanceof Date;          // true
/abc/ instanceof RegExp;             // true
```

------------------------------------------------

一句话总结（写卷子上）

> **基本类型用 `typeof`，对象细分用 `instanceof`（例如Object，Arrary，Function，Date，Error，Map，set）；**  
> **两者互补，绝不重叠。**

---

### 13.null和undefined的区别

`Undefined` 和 `Null` 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 `undefined` 和 `null`。

- **undefined** 代表的含义是**未定义**，一般变量**声明了但还没有定义**的时候会返回 `undefined`，`typeof`为`undefined`
- **null** 代表的含义是**空对象**，null主要用于赋值给一些可能会返回对象的变量，作为初始化，`typeof`为`object`



```
null == undefined // true 
null === undefined //false
```



  ### 14.为什么0.1+0.2!\==0.3

  因为0.1和0.2是浮点数，转换为二进制，是无限不循环小数，计算机中只能存储有限位数，所以会被截断，导致

  ```js
0.1 + 0.2 === 0.30000000000000004 // true
  ```

解决办法：
1.对于简单的可以先乘10的倍数，将其转换为整数，然后再加合，最后除回来。
2.使用to.Fixed(1)

```
(0.1 + 0.2).toFixed(1) === '0.3' // true
但是返回的是字符串
(0.1 + 0.2).toFixed(1) == 0.3 // true（隐式类型转换）
(0.1 + 0.2).toFixed(1) === 0.3 // false

```

3.使用误差范围，在一定的误差范围内，证明他们相等。

```js
function isEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

isEqual(0.1 + 0.2, 0.3); // true
```

4.使用decimal库，适用于高精度计算
如果你在做**金融、货币、科学计算**，不能用原生浮点！

推荐库：

- [decimal.js](https://github.com/MikeMcl/decimal.js/)
- [big.js](https://github.com/MikeMcl/big.js/)
- [bignumber.js](https://github.com/MikeMcl/bignumber.js/)

```js
import Decimal from 'decimal.js';

console.log(new Decimal(0.1).plus(0.2).equals(0.3)); // true
```

以decimal为例，有设计好的api

| 任务                      | 原生写法  | 高精度写法                              |
| :------------------------ | :-------- | :-------------------------------------- |
| 创建                      | `0.1`     | `new Decimal('0.1')` ⚠️ 一定要传字符串   |
| 加法                      | `a + b`   | `a.plus(b)`                             |
| 减法                      | `a - b`   | `a.minus(b)`                            |
| 乘法                      | `a * b`   | `a.times(b)` 或 `mul()`                 |
| 除法                      | `a / b`   | `a.div(b)`                              |
| 取余                      | `a % b`   | `a.mod(b)`                              |
| 幂                        | `a ** b`  | `a.pow(b)`                              |
| 比较                      | `a === b` | `a.eq(b)` / `gt` / `gte` / `lt` / `lte` |
| 保留 n 位                 | 无原生    | `toFixed(n)` 或 `toDecimalPlaces(n)`    |
| 转 Number                 | 无        | `toNumber()`（可能再丢精度）            |
| 转字符串                  | 无        | `toString()`                            |
| 实战 1：0.1 + 0.2 === 0.3 |           |                                         |

```js
import Decimal from 'decimal.js';

const a = new Decimal('0.1');
const b = new Decimal('0.2');
const c = new Decimal('0.3');

console.log(a.plus(b).eq(c));   // true
console.log(a.plus(b).toString()); // "0.3"
```

---

### 15.判断数组的方式有哪些

1.通过Object.prototype.toString.call()做判断

```
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
```

**`Object.prototype.toString.call(value)` 就是“查内置标签”**：  

引擎不看 `.constructor`、不看 `instanceof`，只看 **创建时写死的内部插槽**； 
数组的插槽永远是 `"Array"`，所以返回 `"[object Array]"`——**一锤定音，无法伪造**。

2.通过原型链做判断

```
obj.__proto__ === Array.prototype;
```

3.Arrary.isArrary()

```
Array.isArrray(obj);
```

4.instanceof

```
obj instanceof Array
const isArr=instanceof(obj,Array) //true或false


```

---

### 16.对类数组对象的理解，如何转化为数组

类数组对象（Array-like Objects）通常指的是：**拥有 `length` 属性，且属性名是数字索引**，但它们**不具备** `Array.prototype` 上的方法（如 `map`, `slice`, `push` 等）。

以下是 JavaScript 中最常见、最典型的四个类数组对象例子：

1.`arguments` 对象 (Function Arguments)

这是最经典、最古老的类数组对象。在函数内部，`arguments` 对象包含函数被调用时传入的所有参数。

```
function sum(a, b, c) {
  console.log(arguments); 
  // 输出: [Arguments] { '0': 10, '1': 20, '2': 30 }
  
  console.log(typeof arguments); // object
  console.log(arguments.length); // 3 (✔ 有 length 属性)
  console.log(arguments[0]);     // 10 (✔ 可以通过索引访问)

  // arguments.slice(1); // ❌ 错误：arguments.slice is not a function
}

sum(10, 20, 30);
```

**特点：**

- 有 `length` 属性。
- 可以通过索引 `[0]`, `[1]` 访问元素。
- **不继承** `Array.prototype` 上的方法。



2.DOM `NodeList`

当你使用某些 DOM 查询方法（比如 `document.getElementsByTagName()` 或 `document.querySelectorAll()`）时，返回的结果通常是 `NodeList`。

**示例：**

假设你的 HTML 页面中有三个 `<div>` 元素。

```
// 使用 document.querySelectorAll
const nodeList = document.querySelectorAll('div'); 

console.log(nodeList); 
// 输出: NodeList(3) [div, div, div] (看起来像数组)

console.log(nodeList.length);  // 3
console.log(nodeList[0]);      // 第一个 div 元素

// nodeList.map((el) => el.tagName); // ❌ 错误：nodeList.map is not a function
```

**特点：**

- `NodeList` 是一个实时的或静态的 DOM 元素集合。
- 有 `length` 属性，可以通过索引访问。
- **传统上**它没有数组方法，因此被视为类数组。
  - *注意：* 现代浏览器中的 `NodeList` 已经有 `forEach` 方法了，但仍然没有 `slice`, `map`, `filter` 等方法，所以它依然是类数组的代表。



3.DOM `HTMLCollection`

当你使用 `document.getElementsByClassName()` 或 `document.images`（获取所有 `<img>` 元素）时，返回的结果是 `HTMLCollection`。

```
const collection = document.getElementsByClassName('item');
// 假设有 2 个 class="item" 的元素

console.log(collection.length); // 2
console.log(collection[0]);     // 第一个元素

// collection.slice(); // ❌ 错误：collection.slice is not a function
```

**特点：**

- `HTMLCollection` 是一个**实时 (live)** 的 DOM 元素集合。
- 有 `length` 属性，可以通过索引访问。
- **不继承** `Array.prototype` 上的方法。



4.任何自定义的、带有 `length` 和数字索引的对象

你可以手动创建一个类数组对象，只要它符合那两个基本特征：

```
const customArrayLike = {
  0: 'Red',
  1: 'Green',
  2: 'Blue',
  length: 3 // 必须手动设置 length 属性
};

console.log(customArrayLike.length); // 3
console.log(customArrayLike[1]);     // Green

// customArrayLike.push('Yellow'); // ❌ 错误：customArrayLike.push is not a function
```

**特点：**

- 你无法对它使用 `push` 或 `pop` 等数组操作方法。
- 它完全由你手动定义，是人为创建的类数组对象。

💡 如何把类数组对象转换成真正的数组？



由于类数组对象没有数组方法，如果想对它们使用 `slice`、`map` 等操作，你需要先将它们转换为真正的数组。

最常用的方法有三种：

**使用 `Array.from()` (ES6+)**：

JavaScript

```
const realArray1 = Array.from(nodeList); 
```

**使用扩展运算符 `[...]` (ES6+)**：

JavaScript

```
const realArray2 = [...nodeList];
```

**使用 `Array.prototype.slice.call()` (经典方法)**：

```
// 借用 Array 的 slice 方法来处理类数组对象
const realArray3 = Array.prototype.slice.call(arguments);
```

**通过 `call` 调用数组的 `splice` 方法来实现转换**

```
Array.prototype.splice.call(arrayLike, 0)

```

**通过 `apply` 调用数组的 `concat` 方法来实现转换**

```
Array.prototype.concat.apply([], arrayLike)

```

**Array.propotype.slice.call()是什么** 比如`Array.prototype.slice.call(arguments)`这句里，就是把 `arguments` 当做当前对象。

也就是说 要调用的是 `arguments` 的 `slice` 方法，而`typeof arguments="Object"` 而不是 `Array`

它没有`slice`这个方法，通过这么`Array.prototype.slice.call`调用，JS的内部机制应该是 把`arguments`对象转化为`Array`





### 17.substring和substr的区别

它们都是字符串方法，用于截取字符串的一部分，主要区别在于参数不同

- `substring(startIndex, endIndex)`： 接收两个参数，一个起始索引和结束索引，来指定字符串范围，如果省略第二个参数，则截取到字符串末尾。
- `substr(startIndex, length)`： 接收两个参数，并返回从 `startIndex` 开始，长度为 `length` 的子字符串。如果省略第二个参数，则截取到字符串末尾。

```js
const str = "Hello, World!";

console.log(str.substring(0, 5)); // 输出: "Hello"

console.log(str.substr(7, 5)); // 输出: "World"
```


### 18.object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别

基本类型独立，复杂类型不独立，也就是浅拷贝。

- `Object.assign()`方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。
- 扩展操作符`（…）`使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 `symbols` 属性。







### 19.new操作符的实现原理

1. 创建空对象 `obj`。
2. 把 `obj` 的 `[[Prototype]]`（即 `__proto__`）指向构造函数的 `prototype` 属性。
3. 以 `obj` 为 `this` 执行构造函数(意思就是构造函数执行的时候，使用obj的环境)，拿到返回值 `result`。

这一步非常关键。它描述了如何将第一步创建的空对象与构造函数关联起来。通过使用 `apply`（或 `call`）方法，可以强制改变函数内部 `this`的指向。在这里，就是用新创建的对象作为 `this`的上下文去调用构造函数。这样，在构造函数内部，所有对 `this`的操作（例如 `this.name = ‘Alice’`) 实际上都是在给这个新对象添加属性。



4. 如果 `result` 是对象（含函数、数组）且 **不为 null**，则返回 `result`；否则返回 `obj`。

- 如果构造函数**没有 `return`语句**，或者 `return`了一个基本类型的值，那么 `new`操作符会**忽略**这个返回值，并正常返回第一步创建的新对象。
- 如果构造函数**显式 `return`了一个对象（引用类型）**，那么 `new`操作符会**返回这个指定的对象**，而第一步创建的新对象就会被“丢弃”。



根据上面的原理，我们可以模拟一个 `myNew`函数来实现 `new`的功能：

```
function myNew(constructorFn, ...args) {
  // 1. 创建一个新对象，并链接到构造函数的原型
  let newObj = Object.create(constructorFn.prototype);
  // 这行代码等价于：
  // let newObj = {};
  // newObj.__proto__ = constructorFn.prototype;

  // 2. 将 this 指向新对象，并执行构造函数（给新对象添加属性）
  let result = constructorFn.apply(newObj, args);

  // 3. 判断返回值：如果结果是对象则返回，否则返回新创建的对象（注:我没有搞明白为什么要这样设计？）
  if (result && (typeof result === 'object' || typeof result === 'function')) {
    return result;
  }
  return newObj;
}

// 测试用例
function Person(name, age) {
  this.name = name;
  this.age = age;
  // 没有return语句，默认返回 undefined（基本类型），所以 myNew 会返回 newObj
}
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

let p1 = myNew(Person, 'Alice', 25);
console.log(p1.name); // Alice
p1.sayHello(); // Hello, I'm Alice
console.log(p1 instanceof Person); // true

// 测试构造函数返回对象的情况
function Car(brand) {
  this.brand = brand;
  return { type: 'SUV' }; // 显式返回一个对象
}

let c1 = myNew(Car, 'Toyota');
console.log(c1.brand); // undefined （因为新创建的 newObj 被丢弃了）
console.log(c1.type); // SUV
```



### 20.如何使用for...of遍历对象

`for…of`是作为ES6新增的遍历方式，能被其遍历的数据内部都有一个**遍历器iterator接口**，而数组、字符串、`Map`、`Set`内部已经实现，普通对象内部没有，所以在遍历的时候会报错。想要遍历对象，可以给对象添加一个`Symbol.iterator`属性，并指向一个迭代器即可

在迭代器里面，通过`Object.keys`获取对象所有的`key`，然后遍历返回`key 、value`。

```js
var obj = {
    a:1,
    b:2,
    c:3
};
//function*()是生成器函数，它是一种特殊的函数，调用时会自动返回一个迭代器对象，大大简化了手动实现 next()方法的复杂度
obj[Symbol.iterator] = function*(){
    var keys = Object.keys(obj);
    for(var k of keys){
        yield [k,obj[k]]
    }
};
//生成器函数内部使用 yield关键字来定义每次迭代返回的值。
for(var [k,v] of obj){
    console.log(k,v);
}
```



### 21.对AJAX的理解，实现一个AJAX请求

`AJAX`是 Asynchronous JavaScript and XML 的缩写，**指的是通过 JavaScript 的 异步通信**，从服务器获取 `XML` 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。 创建`AJAX`请求的步骤：

- 创建一个 `XMLHttpRequest` 对象。
- 在这个对象上使用 `open` 方法创建一个 `HTTP` 请求，`open` 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。
- 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 `setRequestHeader` 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 `XMLHttpRequest` 对象一共有 5 个状态，当它的状态变化时会触发`onreadystatechange` 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 `readyState` 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 `response` 中的数据来对页面进行更新了。
- 当对象的属性和监听函数设置完成后，最后调用 `send` 方法来向服务器发起请求，可以传入参数作为发送的数据体。

```js
const SERVER_URL = "/server";
let xhr = new XMLHttpRequest();
// 创建 Http 请求
xhr.open("GET", url, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (this.readyState !== 4) return;
  // 当请求成功时
  if (this.status === 200) {
    handle(this.response);
  } else {
    console.error(this.statusText);
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
// 发送 Http 请求
xhr.send(null);
```



### 22.ajax,axios,fetch的区别

**ajax**

- **架构不清晰**：API 设计比较底层和冗长，配置和调用方式复杂。
- **基于事件的异步模型**：需要通过监听 `onreadystatechange`等事件来处理响应，容易产生“回调地狱”。
- **不符合 MVVM**：在 Vue、React 等现代框架中，这种基于事件的回调模式与声明式的数据驱动开发风格不匹配

**核心概念：什么是 AJAX？**

**AJAX** 是一种技术概念，全称是 Asynchronous JavaScript and XML（异步 JavaScript 和 XML）。它允许网页在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容。我们通常所说的“AJAX”指的是使用 `XMLHttpRequest`对象来实现这一技术。

下面我将基于你提供的要点进行解释，并补充一些例子。

```
// 1. 创建 XHR 对象
const xhr = new XMLHttpRequest();

// 2. 配置请求：方法、URL、是否异步
xhr.open('GET', '/api/user/1', true);

// 3. 设置事件监听器（回调函数）
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) { // 请求完成
        if (xhr.status === 200) { // 请求成功
            console.log(JSON.parse(xhr.responseText));
        } else {
            console.error('请求失败');
        }
    }
};

// 4. 设置错误监听器（另一个回调）
xhr.onerror = function() {
    console.error('网络错误');
};

// 5. 发送请求
xhr.send();
```

**问题**：如果下一个请求依赖于上一个请求的结果，代码就会嵌套很深，形成回调地狱。



**axios**

Axios 是一个基于 Promise 的**第三方 HTTP 库**，它是对原生 `XMLHttpRequest`的封装，使其更易用、功能更强大。

- **支持 Promise API**：使用 `.then()`和 `.catch()`处理响应，支持 `async/await`，解决了回调地狱问题。
- **浏览器和 Node.js 通用**：在浏览器中用 XHR，在 Node.js 中用 `http`模块。
- **拦截器**：可以在请求发出前或响应返回后统一处理（例如添加认证 token、统一报错处理）。
- **自动转换 JSON**：响应数据会自动转换为 JavaScript 对象。
- **防御 CSRF**：可以自动在请求头中添加 CSRF token。

**代码示例：**

```
// 使用 Promise 链
axios.get('/api/user/1')
    .then(response => {
        console.log(response.data);
        return axios.post('/api/profile', { name: 'new name' }); // 链式调用
    })
    .then(response => {
        console.log('更新成功');
    })
    .catch(error => {
        console.error('请求出错', error);
    });

// 使用 async/await（更清晰）
async function getUserData() {
    try {
        const userResponse = await axios.get('/api/user/1');
        const profileResponse = await axios.post('/api/profile', { name: userResponse.data.name });
        console.log(profileResponse.data);
    } catch (error) {
        console.error('操作失败', error);
    }
}

// 添加请求拦截器
axios.interceptors.request.use(config => {
    config.headers.Authorization = `Bearer ${getToken()}`; // 自动添加 token
    return config;
});
```



**fetch**

Fetch 是浏览器原生的、现代化的**替代 AJAX 的方案**，它基于 Promise 设计，语法更简洁。

- **浏览器原生**：无需安装第三方库。
- **基于 Promise**：和 Axios 一样，支持 `.then()`和 `async/await`。
- **默认不携带 Cookie**：需要显式设置 `credentials: 'include'`。
- **对 HTTP 错误状态码不报错**：`fetch()`只有在网络故障时才会被标记为 reject（拒绝），而 404、500 等 HTTP 错误状态码会被标记为 resolve（完成）。这是与 Axios 最大的行为差异之一。
- **无法监控进度**：不像 XHR 可以监听上传/下载进度。

```js
// 基本使用
fetch('/api/user/1')
    .then(response => {
        // 注意：即使状态码是404，这里也会进入then
        if (!response.ok) { // 需要手动检查响应是否成功
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json(); // 解析JSON数据
    })
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        // 这里会捕获网络错误和上面手动抛出的错误
        console.error('Error:', error);
    });

// 使用 async/await
async function fetchUser() {
    try {
        const response = await fetch('/api/user/1');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const userData = await response.json();
        console.log(userData);
    } catch (error) {
        console.error('Fetch failed:', error);
    }
}

// 配置项：携带Cookie、设置请求头等
fetch('/api/data', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({ key: 'value' }),
    credentials: 'include' // 携带Cookie
});
```



### 23.forEach和map方法的区别

两个方法都是用来遍历循环数组，区别如下：

- `forEach()`对数据的操作会改变原数组，该方法没有返回值；
- `map()`方法不会改变原数组的值，**返回一个新数组**，新数组中的值为原数组调用函数处理之后的值；





### 24.什么是尾调用，使用尾调用有什么好处？

尾调用就是在函数的**最后一步调用函数**，在一个函数里调用另外一个函数会**保留当前执行的上下文**，如果在函数尾部调用，因为已经是函数最后一步，所以这时可以不用保留当前的执行上下文，**从而节省内存**。但是ES6的尾调用只能在**严格模式下开启**，正常模式是无效的。









# ES6

### 1.说说var、let、const之间的区别

==先总结==
`var`、`let`、`const`三者区别可以围绕下面五点展开：

- 变量提升
- 暂时性死区
- 块级作用域
- 重复声明
- 修改声明的变量
- 使用

**变量提升**

```
var`声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined
```

`let`和`const`不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错

```js
// var
console.log(a)  // undefined
var a = 10

// let 
console.log(b)  // Cannot access 'b' before initialization
let b = 10

// const
console.log(c)  // Cannot access 'c' before initialization
const c = 10
```

**暂时性死区**

**暂时性死区**指的是从代码块开始到变量声明语句执行完毕的这段时间，在这段时间内访问该变量会抛出错误。

`var`不存在暂时性死区

`let`和`const`存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量

```js
// var
console.log(a)  // undefined
var a = 10

// let
console.log(b)  // Cannot access 'b' before initialization
let b = 10

// const
console.log(c)  // Cannot access 'c' before initialization
const c = 10
```

**块级作用域**
`var`不存在块级作用域
`let`和`const`存在块级作用域

```js
// var
{
    var a = 20
}
console.log(a)  // 20

// let
{
    let b = 20
}
console.log(b)  // Uncaught ReferenceError: b is not defined

// const
{
    const c = 20
}
console.log(c)  // Uncaught ReferenceError: c is not defined
```

**重复声明**
`var`允许重复声明变量
`let`和`const`在同一作用域不允许重复声明变量

```js
// var
var a = 10
var a = 20 // 20

// let
let b = 10
let b = 20 // Identifier 'b' has already been declared

// const
const c = 10
const c = 20 // Identifier 'c' has already been declared
```

**声明变量是否可修改**
`var`和`let`可以
`const`声明一个只读的常量。一旦声明，常量的值就不能改变

```js
// var
var a = 10
a = 20
console.log(a)  // 20

//let
let b = 10
b = 20
console.log(b)  // 20

// const
const c = 10
c = 20
console.log(c) // Uncaught TypeError: Assignment to constant variable
```

**使用**
能用`const`的情况尽量使用`const`，其他情况下大多数使用`let`，避免使用`var`

==1.==var
在ES5中，顶层对象的属性和全局变量是等价的，用`var`声明的变量既是全局变量，也是顶层变量
注意：顶层对象，在浏览器环境指的是`window`对象，在 `Node` 指的是`global`对象

```js
var a = 10;
console.log(window.a) // 10
```

使用`var`声明的变量存在变量提升的情况

```js
console.log(a) // undefined
var a = 20
```

在编译阶段，编译器会将其变成以下执行

```js
var a
console.log(a)
a = 20
```

使用`var`，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明

```js
var a = 20 
var a = 30
console.log(a) // 30
```

在函数中使用使用`var`声明变量时候，该变量是局部的

```js
var a = 20
function change(){
    var a = 30
}
change()
console.log(a) // 20 
```

而如果在函数内不使用`var`，该变量是全局的

```js
var a = 20
function change(){
   a = 30
}
change()
console.log(a) // 30 
```

==2.==let
`let`是`ES6`新增的命令，用来声明变量
用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效

```js
{
    let a = 20
}
console.log(a) // ReferenceError: a is not defined.
```

不存在变量提升

```js
console.log(a) // 报错ReferenceError
let a = 2
```

这表示在声明它之前，变量`a`是不存在的，这时如果用到它，就会抛出一个错误
只要块级作用域内存在`let`命令，这个区域就不再受外部影响

```js
var a = 123
if (true) {
    a = 'abc' // ReferenceError
    let a;
}
```

使用`let`声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”
最后，`let`不允许在相同作用域中重复声明

```js
let a = 20
let a = 30
// Uncaught SyntaxError: Identifier 'a' has already been declared
```

注意的是相同作用域，下面这种情况是不会报错的

```js
let a = 20
{
    let a = 30
}
```

因此，我们不能在函数内部重新声明参数

```js
function func(arg) {
  let arg;
}
func()
// Uncaught SyntaxError: Identifier 'arg' has already been declared
```

==3.==const
`const`声明一个只读的常量，一旦声明，常量的值就不能改变

```js
const a = 1
a = 3
// TypeError: Assignment to constant variable.
```

这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值

```js
const a;
// SyntaxError: Missing initializer in const declaration
```

如果之前用`var`或`let`声明过变量，再用`const`声明同样会报错

```js
var a = 20
let b = 20
const a = 30
const b = 30
// 都会报错
```

`const`实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动

对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量

对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的，并不能确保改变量的结构不变

```js
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

其它情况，`const`与`let`一致



### 2.ES6中数组新增了哪些扩展？

==1.==拓展运算符

ES6通过扩展元素符`...`，好比 `rest` 参数的逆运算，将一个数组转为用逗号分隔的参数序列

```js
console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll('div')]
// [<div>, <div>, <div>]
```

注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组

可以将字符串转为真正的数组

```javascript
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```

==2.==构造函数新增方法

关于构造函数，数组新增的方法有如下：

- Array.from()
- Array.of()

**arrary.from**

将两类对象转为真正的数组：类似数组的对象和可遍历`（iterable）`的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）

```js
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
//控制length可以增加可识别的数量。
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组

```js
Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```

**arrary.of**

用于将一组值，转换为数组

```js
Array.of(3, 11, 8) // [3,11,8]
```

没有参数的时候，返回一个空数组

当参数只有一个的时候，实际上是指定数组的长度

参数个数不少于 2 个时，`Array()`才会返回由参数组成的新数组

```js
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
```

==3.==实例对象新增方法

- copyWithin()
- find()、findIndex()
- fill()
- entries()，keys()，values()
- includes()
- flat()，flatMap()

**copyWithin**

将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组

参数如下：

- target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
- start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

```js
[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5] 
```

**find()、findIndex**

`find()`用于找出第一个符合条件的数组成员

参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组

```js
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10
findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2
```

这两个方法都可以接受第二个参数，用来绑定回调函数的`this`对象。

```js
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26
```

**fill**

使用给定值，填充一个数组

```javascript
['a', 'b', 'c'].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
```

还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置

```js
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
```

注意，如果填充的类型为对象，则是浅拷贝

**entries()，keys()，values()**

`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历

```js
or (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
```

**includes()**

用于判断数组是否包含给定的值

```js
[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
```

方法的第二个参数表示搜索的起始位置，默认为`0`

参数为负数则表示倒数的位置

```js
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
```

**flat()，flatMap()**

将数组扁平化处理，返回一个新数组，对原数据没有影响

```js
[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
```

`flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1

```js
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
```

`flatMap()`方法对原数组的每个成员执行一个函数相当于执行`Array.prototype.map()`，然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this
```

==数组的空位置==

数组的空位指，数组的某一个位置没有任何值

ES6 则是明确将空位转为`undefined`，包括`Array.from`、扩展运算符、`copyWithin()`、`fill()`、`entries()`、`keys()`、`values()`、`find()`和`findIndex()`

建议大家在日常书写中，避免出现空位

==排序稳定性==

将`sort()`默认设置为稳定的排序算法

```js
const arr = [
  'peach',
  'straw',
  'apple',
  'spork'
];

const stableSorting = (s1, s2) => {
  if (s1[0] < s2[0]) return -1;
  return 1;
};

arr.sort(stableSorting)
// ["apple", "peach", "straw", "spork"]
```

排序结果中，`straw`在`spork`的前面，跟原始顺序一致

### 3.对象新增了哪些扩展？

- 属性的简写：ES6中，当对象键名与对应值名相等的时候，可以进行简写
- 属性名表达式：ES6 允许字面量定义对象时，将表达式放在括号内
- super关键字：`this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字`super`，指向当前对象的原型对象

```js
class Animal {
    constructor(name) {
        this.name = name;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // 调用父类 Animal 的构造函数
        this.breed = breed;
    }
}

const myDog = new Dog('Buddy', 'Golden Retriever');
console.log(myDog.name); // "Buddy" (来自父类)
console.log(myDog.breed); // "Golden Retriever" (来自子类)
```



- 拓展运算符
- 属性的遍历方法：Object.keys(obj）、for...in、Object.getOwnPropertyNames(obj)、Reflect.ownKeys(obj)：、Object.getOwnPropertySymbols(obj)
- 对象的新增方法：Object.is()、Object.assign()、Object.getOwnPropertyDescriptors()、Object.setPrototypeOf()，Object.getPrototypeOf()、Object.keys()，Object.values()，Object.entries()、Object.fromEntries()



==1.==属性的简写

ES6中，当对象键名与对应值名相等的时候，可以进行简写

```js
const baz = {foo:foo}

// 等同于
const baz = {foo}
```

方法也能够进行简写

```js
const o = {
  method() {
    return "Hello!";
  }
};

// 等同于

const o = {
  method: function() {
    return "Hello!";
  }
}
```

在函数内作为返回值，也会变得方便很多

```js
function getPoint() {
  const x = 1;
  const y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
```

注意：简写的对象方法不能用作构造函数，否则会报错

```js
const obj = {
  f() {
    this.foo = 'bar';
  }
};

new obj.f() // 报错
```

==2.属性名表达式==

ES6 允许字面量定义对象时，将表达式放在括号内

```js
let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
```

表达式还可以用于定义方法名

```js
let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello() // hi
```

注意，属性名表达式与简洁表示法，不能同时使用，会报错

```js
// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };
// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
```

注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串`[object Object]`

```js
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```

==3.super关键字==

`this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字`super`，指向当前对象的原型对象

```javascript
const proto = {
  foo: 'hello'
};

const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto); // 为obj设置原型对象
obj.find() // "hello"
```

==4.拓展运算符的应用==

在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面

```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

注意：解构赋值必须是最后一个参数，否则会报错

解构赋值是浅拷贝

```js
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
```

对象的扩展运算符等同于使用`Object.assign()`方法

==5.属性的遍历==

ES6 一共有 5 种方法可以遍历对象的属性。

- for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）
- Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名
- Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名
- Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名
- Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不
  管键名是 Symbol 或字符串，也不管是否可枚举

上述遍历，都遵守同样的属性遍历的次序规则：

- 首先遍历所有数值键，按照数值升序排列
- 其次遍历所有字符串键，按照加入时间升序排列
- 最后遍历所有 Symbol 键，按照加入时间升序排

```js
Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
```

==6.对象的新增方法==

关于对象新增的方法，分别有以下：

- Object.is()
- Object.assign()
- Object.getOwnPropertyDescriptors()
- Object.setPrototypeOf()，Object.getPrototypeOf()
- Object.keys()，Object.values()，Object.entries()
- Object.fromEntries()

**object.is**

严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身

```js
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

**object.assign**

```
Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target
```

`Object.assign()`方法的第一个参数是目标对象，后面的参数都是源对象

```javascript
const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
```

注意：`Object.assign()`方法是浅拷贝，遇到同名属性会进行替换

**Object.getOwnPropertyDescriptors()**

返回指定对象所有自身属性（非继承属性）的描述对象

```js
const obj = {
  foo: 123,
  get bar() { return 'abc' }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
```

**Object.setPrototypeOf()**

`Object.setPrototypeOf`方法用来设置一个对象的原型对象

```js
Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf({}, null);
```

**Object.keys()**

返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组

```js
var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// ["foo", "baz"]
```

**Object.values()**

```js
const obj = { foo: 'bar', baz: 42 };
Object.values(obj)
// ["bar", 42]
```

**Object.entries()**

返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组

```js
const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]
```

**Object.fromEntries()**

用于将一个键值对数组转为对象

```js
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: "bar", baz: 42 }
```

---

### 4.函数对象新增了哪些扩展

- 允许为参数设置默认值
- 增添了函数的length属性，表示传入没有指定默认值的参数
- 添加了name属性，表示函数名
- 严格模式
- 箭头函数



==1.参数==
`ES6`允许为函数的参数设置默认值

```
function log(x, y = 'World') {
  console.log(x, y);
}

console.log('Hello') // Hello World
console.log('Hello', 'China') // Hello China
console.log('Hello', '') // Hello
```

==2.属性==
**1.函数的length属性**
`length`将返回没有指定默认值的参数个数

```
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```

`rest` 参数也不会计入`length`属性

```
(function(...args) {}).length // 0
```

如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了

```js
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```

**2.name属性**

返回该函数的函数名

```
var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"
```

==3.作用域==
一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域
等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会
出现的
下面例子中，`y=x`会形成一个单独作用域，`x`没有被定义，所以指向全局变量`x`

```
let x = 1;

function f(y = x) { 
  // 等同于 let y = x  
  let x = 2; 
  console.log(y);
}

f() // 1
```

==4.严格模式==
只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

```
// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
```

==5.箭头函数==

---

### 5.你是怎么理解ES6新增Set、Map两种数据结构的？

么是集合？什么又是字典？

- 集合  

是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合

- 字典  

是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同

区别？

- 共同点：集合、字典都可以存储不重复的值
- 不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储
  ==set==
  `Set`是`es6`新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合
  `Set`本身是一个构造函数，用来生成 Set 数据结构

```
const s = new Set();
```

`Set`的实例关于增删改查的方法：

- add()
- delete()
- has()  返回一个布尔值，判断该值是否为`Set`的成员
- clear()  清除所有成员，没有返回值
  `Set`实例遍历的方法有如下：
  关于遍历的方法，有如下：
- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回键值对的遍历器
- forEach()：使用回调函数遍历每个成员
  `Set`的遍历顺序就是插入顺序
  `keys`方法、`values`方法、`entries`方法返回的都是遍历器对象

```
let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]
```

`forEach()`用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的`forEach`方法有第二个参数，用于绑定处理函数的`this`

```
let set = new Set([1, 4, 9]);
set.forEach((value, key) => console.log(key + ' : ' + value))
// 1 : 1
// 4 : 4
// 9 : 9
```

扩展运算符和`Set` 结构相结合实现数组或字符串去重

```
// 数组
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)]; // [3, 5, 2]

// 字符串
let str = "352255";
let unique = [...new Set(str)].join(""); // "352"
```

实现并集、交集、和差集

```
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
```

==Map==
`Map`类型是键值对的有序列表，而键和值都可以是任意类型
`Map`本身是一个构造函数，用来生成 `Map` 数据结构

```
const m = new Map()
```

`Map` 结构的实例针对增删改查有以下属性和操作方法：

- size 属性
- set()
- get()
- has()
- delete()
- clear()
  `Map`结构原生提供三个遍历器生成函数和一个遍历方法：
- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回所有成员的遍历器
- forEach()：遍历 Map 的所有成员

---

### 6.你是怎么理解ES6中 Promise的？使用场景？

==什么是Promise==
`Promise`，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大
在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码

```
doSomething(function(result) {
  doSomethingElse(result, function(newResult) {
    doThirdThing(newResult, function(finalResult) {
      console.log('得到最终结果: ' + finalResult);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
```

阅读上面代码，是不是很难受，上述形成了经典的回调地狱
现在通过`Promise`的改写上面的代码

```
doSomething().then(function(result) {
  return doSomethingElse(result);
})
.then(function(newResult) {
  return doThirdThing(newResult);
})
.then(function(finalResult) {
  console.log('得到最终结果: ' + finalResult);
})
.catch(failureCallback);
```

瞬间感受到`promise`解决异步操作的优点：

- 链式操作减低了编码难度
- 代码可读性明显增强

下面我们正式来认识`promise`：

==状态==
`promise`对象仅有三种状态

- `pending`（进行中）
- `fulfilled`（已成功）
- `rejected`（已失败）
  特点：
- 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态
- 一旦状态改变（从`pending`变为`fulfilled`和从`pending`变为`rejected`），就不会再变，任何时候都可以得到这个结果

==用法==
`Promise`对象是一个构造函数，用来生成`Promise`实例

```
const promise = new Promise(function(resolve, reject) {});
```

`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`

- `resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”
- `reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”
  ==实例方法==
  `Promise`构建出来的实例存在以下方法：
- then()
- catch()
- finally()
  ==then()==

`then`是实例状态发生改变时的回调函数，第一个参数是`resolved`状态的回调函数，第二个参数是`rejected`状态的回调函数
`then`方法返回的是一个新的`Promise`实例，也就是`promise`能链式书写的原因

```
getJSON("/posts.json").then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
```

==catch==
`catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数

```
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
```

`Promise`对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止

```
getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
```

一般来说，使用`catch`方法代替`then()`第二个参数
`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应

```
const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};
```

浏览器运行到这一行，会打印出错误提示`ReferenceError: x is not defined`，但是不会退出进程
`catch()`方法之中，还能再抛出错误，通过后面`catch`方法捕获到
==finally()==
`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作

```
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```

==构造函数方法==

`Promise`构造函数存在以下方法：

- all()
- race()
- allSettled()
- resolve()
- reject()
- try()

==all()==
`Promise.all()`方法用于将多个 `Promise`实例，包装成一个新的 `Promise`实例

```
const p = Promise.all([p1, p2, p3]);
```

接受一个数组（迭代对象）作为参数，数组成员都应为`Promise`实例
实例`p`的状态由`p1`、`p2`、`p3`决定，分为两种：

- 只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数
- 只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数
  注意，如果作为参数的 `Promise` 实例，自己定义了`catch`方法，那么它一旦被`rejected`，并不会触发`Promise.all()`的`catch`方法

```
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result)
.catch(e => e);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result)
.catch(e => e);

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e));
// ["hello", Error: 报错了]
```

如果`p2`没有自己的`catch`方法，就会调用`Promise.all()`的`catch`方法

```
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result);

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e));
// Error: 报错了
```

==race()==
`Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例

```
const p = Promise.race([p1, p2, p3]);
```

只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变
率先改变的 Promise 实例的返回值则传递给`p`的回调函数

```
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
```

==allSettled()==

`Promise.allSettled()`方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例
只有等到所有这些参数实例都返回结果，不管是`fulfilled`还是`rejected`，包装实例才会结束.也就是所有的实例都完成了，无论是成功或失败，allSettled才会返回结果。

```
const promises = [
  fetch('/api-1'),
  fetch('/api-2'),
  fetch('/api-3'),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
```

==resolve()==

将现有对象转为 `Promise`对象，实例状态为`fullfilled`

```
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

参数可以分成四种情况，分别如下：

- 参数是一个 Promise 实例，`promise.resolve`将不做任何修改、原封不动地返回这个实例
- 参数是一个`thenable`对象，`promise.resolve`会将这个对象转为 `Promise`对象，然后就立即执行`thenable`对象的`then()`方法
- 参数不是具有`then()`方法的对象，或根本就不是对象，`Promise.resolve()`会返回一个新的 Promise 对象，状态为`resolved`
- 没有参数时，直接返回一个`resolved`状态的 Promise 对象

==reject()==

`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`

```
const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) => reject('出错了'))

p.then(null, function (s) {
  console.log(s)
});
// 出错了
```

`Promise.reject()`方法的参数，会原封不动地变成后续方法的参数

```
Promise.reject('出错了')
.catch(e => {
  console.log(e === '出错了')
})
// true
```

==三、使用场景==

将图片的加载写成一个`Promise`，一旦加载完成，`Promise`的状态就发生变化

```
const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
```

通过链式操作，将多个渲染数据分别给个`then`，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题

```
// 各司其职
getInfo().then(res=>{
    let { bannerList } = res
    //渲染轮播图
    console.log(bannerList)
    return res
}).then(res=>{
    
    let { storeList } = res
    //渲染店铺列表
    console.log(storeList)
    return res
}).then(res=>{
    let { categoryList } = res
    console.log(categoryList)
    //渲染分类列表
    return res
})
```

通过`all()`实现多个请求合并在一起，汇总所有请求结果，只需设置一个`loading`即可

```
function initLoad(){
    // loading.show() //加载loading
    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=>{
        console.log(res)
        loading.hide() //关闭loading
    }).catch(err=>{
        console.log(err)
        loading.hide()//关闭loading
    })
}
//数据初始化    
initLoad()
```

通过`race`可以设置图片请求超时

```
//请求某个图片资源
function requestImg(){
    var p = new Promise(function(resolve, reject){
        var img = new Image();
        img.onload = function(){
           resolve(img);
        }
        //img.src = "https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg"; 正确的
        img.src = "https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1";
    });
    return p;
}

//延时函数，用于给请求计时
function timeout(){
    var p = new Promise(function(resolve, reject){
        setTimeout(function(){
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}

Promise
.race([requestImg(), timeout()])
.then(function(results){
    console.log(results);
})
.catch(function(reason){
    console.log(reason);
});
```


### 7.你是怎么理解ES6中 Proxy？使用场景？

ES6 中的 `Proxy` 是一个非常强大的特性，它允许你创建一个对象的“代理”，从而**拦截并自定义**该对象上的基本操作。

你可以把 `Proxy` 想象成一个在你和目标对象之间的**“中介”或“看门人”**。所有对该对象的访问（如读取、设置属性等）都必须先经过这个“看门人”（Proxy），而“看门人”可以决定如何处理这些操作。

基本语法
`Proxy` 是一个构造函数，像这样使用：

```
const target = {
  message: "Hello"
};

const handler = {
  // "handler" 是一个配置对象，它定义了要拦截哪些操作
  // 以及如何自定义这些操作（这些自定义函数被称为 "陷阱" trap）
};

const proxy = new Proxy(target, handler);
//Proxy对象的作用就是，当修改属性的时候，会执行handler中的set方法，进行一些预设的操作再判断是否进行设置；当访问属性的时候，会执行handler的get方法，进行一些预设的验证后再返回读取的值。
```

- `target`: 你要代理的原始对象（目标对象）。
- `handler`: 一个配置对象，用于定义各种“陷阱”（traps）。
- `proxy`: 返回的代理对象。

之后，你操作的应该是 `proxy` 对象，而不是 `target` 对象。


`Proxy` 的主要作用（通过 `handler` 陷阱实现）

`Proxy` 的强大之处在于 `handler` 对象可以定义多达 13 种不同的“陷阱”（trap），来拦截几乎所有对目标对象的基本操作。
以下是几个最常见和最有用的作用：

1. 数据验证（使用 `set` 陷阱）
   这是最常见的用途之一。你可以在给对象属性赋值之前，拦截 `set` 操作，以验证新值的有效性。
   **示例：** 确保 `age` 属性只能被设置为数字。

```js
let target = { name: "Alice", age: 30 };

let handler = {
  set(target, property, value) {
    if (property === 'age') {
      if (typeof value !== 'number' || value <= 0) {
        throw new Error("Age must be a positive number.");
      }
    }
    // 如果验证通过，才真正设置值
    target[property] = value;
    return true; // 表示设置成功
  }
};

let proxy = new Proxy(target, handler);

proxy.age = 31;      // 成功
console.log(proxy.age); // 31

// 尝试设置一个无效值
try {
  proxy.age = "fourty"; // 抛出错误: "Age must be a positive number."
} catch (e) {
  console.error(e.message);
}
```

    2. 响应式系统（现代框架的核心）

这是 `Proxy` 最著名的用途。像 **Vue 3** 这样的现代前端框架，其核心的响应式系统就是基于 `Proxy` 构建的。

- **`get` 陷阱**：当读取一个属性时（例如在模板中渲染 `{{ user.name }}`），`get` 陷阱会被触发。此时，框架可以**收集依赖**，即“记录”下是哪个组件的哪部分依赖了这个数据。
- **`set` 陷阱**：当修改一个属性时（例如 `user.name = "Bob"`），`set` 陷阱会被触发。此时，框架可以**通知**所有“记录”在案的、依赖这个数据的组件去重新渲染。

这比 ES5 的 `Object.defineProperty`（Vue 2 使用的）更强大，因为 `Proxy` 可以代理整个对象，包括新增的属性和数组操作，而 `defineProperty` 只能针对已存在的属性。

    3. 日志记录与调试（使用 `get` 和 `set`）

你可以拦截所有读写操作，并将其打印到控制台，以便跟踪对象在何时何处被访问或修改。

```js
let handler = {
  get(target, property) {
    console.log(`[LOG] Getting property: ${property}`);
    return target[property];
  },
  set(target, property, value) {
    console.log(`[LOG] Setting property: ${property} = ${value}`);
    target[property] = value;
    return true;
  }
};

let proxy = new Proxy({}, handler);
proxy.name = "Test"; // [LOG] Setting property: name = Test
let x = proxy.name;  // [LOG] Getting property: name
```

4. 访问控制（私有属性）

JavaScript 原生没有真正的私有属性（虽然现在有了 `#` 语法，但 `Proxy` 提供了另一种方式）。你可以约定以下划线 `_` 开头的属性为“私有”，并使用 `get` 和 `set` 陷阱阻止外部访问。

```
let handler = {
  get(target, property) {
    if (property.startsWith('_')) {
      throw new Error("Access to private property is denied.");
    }
    return target[property];
  }
  // ... 同样可以为 set, deleteProperty 等设置
};

let target = { name: "Public", _secret: "12345" };
let proxy = new Proxy(target, handler);

console.log(proxy.name); // "Public"
// console.log(proxy._secret); // 抛出错误: "Access to private property is denied."
```

---

`Proxy` 与 `Reflect`

提到 `Proxy` 几乎总要提到 `Reflect`。`Reflect` 是 ES6 提供的另一个内置对象，它提供了一套与 `Proxy` 陷阱同名的方法（如 `Reflect.get()`, `Reflect.set()`, `Reflect.apply()`）。
**最佳实践是：** 在 `Proxy` 的 `handler` 陷阱中，使用 `Reflect` 对应的方法来执行对 `target` 对象的**默认操作**。
例如，在 `set` 陷阱中，应该使用 `Reflect.set(target, property, value)` 来代替 `target[property] = value`。

```
let handler = {
  set(target, property, value, receiver) {
    console.log("Setting...");
    // 使用 Reflect.set 来执行默认操作，而不是 target[property] = value
    // 它能正确处理 "receiver"（this指向）并返回一个布尔值
    return Reflect.set(target, property, value, receiver);
  }
};
```



**“为什么在 Proxy 的陷阱函数 (handler) 内部，推荐使用 `Reflect` 的方法（如 `Reflect.set`），而不是直接操作 `target` 对象（如 `target[property] = value`）？”**

答案是：使用 `Reflect` 可以确保**操作的正确性、规范性，并简化代码**。
不使用 `Reflect` 会导致一些难以察觉的 bug，尤其是在涉及 `getter/setter` 和 `this` 指向时。
以下是必须使用 `Reflect` 的几个核心理由：

1. 确保 `this` (receiver) 指向的正确性（最重要）

这是最关键、也是最容易出错的地方。
当你通过 `proxy` 访问一个属性时，如果这个属性在 `target` 对象上是一个 `getter` 或 `setter`，你希望这个 `getter/setter` 内部的 `this` 指向的是 `proxy` 对象，而不是 `target` 对象。
**`Reflect` 方法（如 `Reflect.get`, `Reflect.set`）接受一个 `receiver` 参数，这个参数就是 `Proxy` 陷阱函数接收到的第三个参数（它通常就是 `proxy` 实例本身）。`Reflect` 会确保将这个 `receiver` 作为 `getter/setter` 的 `this` 上下文。**
**如果你直接操作 `target`，`this` 就会指向 `target`**，这就破坏了代理的封装性。
**看个例子：**

```
const target = {
  _name: "Alice",
  get name() {
    // 我们期望这里的 'this' 指向 proxy，而不是 target
    console.log('Getter中的this是否指向Proxy:', this === proxy); 
    return this._name;
  }
};

const handler = {
  get(target, property, receiver) {
    console.log(`拦截到 get 操作: ${property}`);
    
    // 错误的做法：直接操作 target
    // return target[property]; 
    // 上面这行会导致 Getter 中的 'this' 指向 target，输出 false
    
    // 正确的做法：使用 Reflect，并传入 receiver
    return Reflect.get(target, property, receiver);
  }
};

const proxy = new Proxy(target, handler);

// 当我们访问 proxy.name 时...
proxy.name; 
```

**运行结果（使用 `Reflect.get`）：**

```
拦截到 get 操作: name
Getter中的this是否指向Proxy: true
```

**如果改成 `return target[property]`：**

```
拦截到 get 操作: name
Getter中的this是否指向Proxy: false  <-- 问题在这里！
```

2. 保证规范的返回值

`Proxy` 的 `set` 或 `deleteProperty` 陷阱函数**被规范要求必须返回一个布尔值**（`true` 表示成功，`false` 表示失败）。

- **直接操作**：`target[property] = value` 这样的赋值语句，在非严格模式下通常返回赋的值，在严格模式下失败时会抛出错误。你很难统一处理它的返回值。
- **`Reflect` 操作**：`Reflect.set()` 和 `Reflect.deleteProperty()` 被设计为**总是返回一个布尔值**，无论是否在严格模式下。

这使得 `Proxy` 陷阱函数能非常干净地返回 `Reflect` 操作的结果。

```
const target = {};
Object.freeze(target); // 冻结对象，使其不可写

const handler = {
  set(target, property, value, receiver) {
    console.log("拦截 set");
    
    // 错误的做法：
    /*
    try {
      target[property] = value; // 在严格模式下会抛错
      return true; // 即使不抛错，如果静默失败了，这里也会错误地返回 true
    } catch (e) {
      return false; // 需要 try...catch 来捕获
    }
    */

    // 正确的做法：
    const success = Reflect.set(target, property, value, receiver);
    if (!success) {
      console.warn("设置失败!");
    }
    return success; // 直接返回 Reflect 的结果，干净利落
  }
};

const proxy = new Proxy(target, handler);
proxy.name = "Test"; 
// 输出: 拦截 set
// 输出: 设置失败!
```

    3. 代码更简洁且与陷阱一一对应
       `Reflect` 提供了 13 个静态方法，与 `Proxy` 的 13 个陷阱（trap）**一一对应**。

| **Proxy 陷阱 (Handler)** | **Reflect 默认操作 (Method)** |
| ------------------------ | ----------------------------- |
| `get()`                  | `Reflect.get()`               |
| `set()`                  | `Reflect.set()`               |
| `has()`                  | `Reflect.has()`               |
| `apply()`                | `Reflect.apply()`             |
| `deleteProperty()`       | `Reflect.deleteProperty()`    |
| ... (等等)               | ... (等等)                    |

这使得在 `Proxy` 陷阱中调用 `Reflect` 成为一种非常自然和易读的“标准”写法。



### 8. 箭头函数和普通函数的区别

1. 箭头函数是匿名函数，不能作为构造函数，使用 `new`关键字。
2. 箭头函数没有 `arguments`对象

在普通函数中，`arguments`是一个类数组对象，包含传入函数的所有参数。箭头函数本身没有 `arguments`，但可以访问外围函数的 `arguments`。



1. 箭头函数是匿名函数，不能作为构造函数，使用 `new`关键字。

**解释**：箭头函数没有 `[[Construct]]`内部方法，因此无法使用 `new`来实例化对象。

**代码示例**：

```
// 普通函数可以作为构造函数
const Person = function(name) {
    this.name = name;
};
const alice = new Person('Alice'); // 正确
console.log(alice.name); // "Alice"

// 箭头函数不能作为构造函数
const Animal = (name) => {
    this.name = name; // 这里的this是定义时的上下文，不是新对象
};
const cat = new Animal('Cat'); // 报错：TypeError: Animal is not a constructor
```



2. 箭头函数没有 `arguments`对象。

**解释**：在普通函数中，`arguments`是一个类数组对象，包含传入函数的所有参数。箭头函数本身没有 `arguments`，但可以访问外围函数的 `arguments`。

**代码示例**：

```
// 普通函数有 arguments
function regularFunc() {
    console.log(arguments); // Arguments(3) [1, 2, 3]
}
regularFunc(1, 2, 3);

// 箭头函数没有自己的 arguments
const arrowFunc = () => {
    console.log(arguments); // 报错：arguments is not defined
};
arrowFunc(1, 2, 3);

// 但可以访问外围函数的 arguments
function outer() {
    const inner = () => {
        console.log(arguments); // 继承自outer函数的arguments
    };
    inner();
}
outer(1, 2, 3); // 输出：Arguments(3) [1, 2, 3]

// 推荐做法：使用剩余参数（Rest Parameters）
const modernArrow = (...args) => {
    console.log(args); // [1, 2, 3] - 真正的数组
};
modernArrow(1, 2, 3);
```



3. 箭头函数没有自己的 `this`，会获取所在的上下文作为自己的 `this`。

4. `call()`、`apply()`、`bind()`方法不能改变箭头函数中的 `this`指向。

**解释**：由于箭头函数的 `this`在定义时就已经固定，无法通过 `call`、`apply`、`bind`这些方法来改变。

**代码示例**：

```js
const obj1 = { name: 'Alice' };
const obj2 = { name: 'Bob' };

// 普通函数可以被绑定
const regularFunc = function() {
    console.log(this.name);
};
regularFunc.call(obj1); // "Alice"
regularFunc.call(obj2); // "Bob"

// 箭头函数的this无法被改变
const arrowFunc = () => {
    console.log(this.name);
};
arrowFunc.call(obj1); // ""（仍然是定义时的this）
arrowFunc.call(obj2); // ""（不变）

// bind对箭头函数无效
const boundArrow = arrowFunc.bind(obj1);
boundArrow(); // ""（this仍然不变）
```

5. 箭头函数没有 `prototype`属性。

**解释**：由于箭头函数不能作为构造函数，所以不需要 `prototype`属性。



6. 箭头函数不能用作 Generator 函数，不能使用 `yield`关键字。

**解释**：`yield`关键字只能在 `function*`生成器函数中使用，箭头函数不支持这种语法。

**代码示例**：

```
// 正确的Generator函数
function* regularGenerator() {
    yield 1;
    yield 2;
    yield 3;
}
const gen = regularGenerator();
console.log(gen.next().value); // 1

// 箭头函数不能使用yield
const arrowGenerator = *() => {  // 语法错误
    yield 1;
};

// 这也是错误的
const arrowGen = () => {
    yield 1; // 语法错误：Unexpected token 'yield'
};
```

### 9.Set、Map的区别

**Set**

- 创建：`  new Set([1, 1, 2, 3, 3, 4, 2])`
- `.add(value)`：添加某个值，返回Set结构本身。
- `.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `.has(value)`：返回一个布尔值，表示该值是否为Set的成员。
- `.clear()`：清除所有成员，没有返回值。

**Map**

- `.set(key, val):` 向`Map`中添加新元素
- `.get(key):` 通过键值查找特定的数值并返回
- `.has(key): `判断`Map`对象中是否有`Key`所对应的值，有返回`true`,否则返回`false`
- `.delete(key): `通过键值从`Map`中移除对应的数据
- `.clear():` 将这个`Map`中的所有元素删除

区别

- `Map`是一种键值对的集合，和对象不同的是，键可以是任意值
- `Map`可以遍历，可以和各种数据格式转换
- `Set`是类似数组的一种的数据结构，类似数组的一种集合，但在Set中没有重复的值



### 10.map和Object的区别

`map`和`Object`都是用键值对来存储数据，区别如下：

- **键的类型**：`Map` 的键可以是**任意数据类型**（包括对象、函数、`NaN `等），而 `Object` 的键**只能是字符串**或者 `Symbol` 类型。

- **键值对的顺序**：`Map`中的键值对是按照插入的顺序存储的，而对象中的键值对则没有顺序。

**Object 的顺序不可靠**

在 ES6 之前，`Object`的属性顺序依赖于 JavaScript 引擎的实现。ES6 规范后，对于**字符串键**有了一定的顺序规则，但依然有特殊情况。

```
const obj = {};
obj['b'] = 2;
obj['a'] = 1;
obj['2'] = '数字2';
obj['1'] = '数字1';

// 遍历顺序：数字键按数字顺序，字符串键按添加顺序
for (let key in obj) {
    console.log(key); // "1", "2", "b", "a"
}

// 但不同浏览器或环境下可能有差异
```

**Map 的插入顺序保证**

`Map`严格按照键值对的插入顺序进行迭代。

```
const map = new Map();
map.set('b', 2);
map.set('a', 1);
map.set(2, '数字2');
map.set(1, '数字1');

// 严格按照插入顺序遍历
for (let [key, value] of map) {
    console.log(key, value); 
    // "b" 2
    // "a" 1
    // 2 "数字2"
    // 1 "数字1"
}
```



- **键值对的遍例**：`Map` 的键值对可以使用 `for...of` 进行遍历，而 `Object` 的键值对需要手动遍历键值对。
- **继承关系**：`Map`没有继承关系，而 `Object` 是所有对象的基类。



### 11.map和weakMap的区别

它们是 `JavaScript` 中的两种不同的键值对集合，主要区别如下：

1. `map`的键可以是任意类型，`weakMap`键只能是对象类型。

**Map：键可以是任意类型**

```
const myMap = new Map();

// 所有类型都可以作为键
myMap.set('string', '字符串键');       // 字符串
myMap.set(42, '数字键');              // 数字
myMap.set(true, '布尔键');            // 布尔值
myMap.set({id: 1}, '对象键');          // 对象
myMap.set(['a', 'b'], '数组键');      // 数组
myMap.set(function() {}, '函数键');    // 函数
myMap.set(Symbol('sym'), 'Symbol键'); // Symbol
myMap.set(null, 'null键');            // null
myMap.set(undefined, 'undefined键');  // undefined

console.log(myMap.get(42)); // "数字键"
console.log(myMap.get(null)); // "null键"
```

**WeakMap：键只能是对象类型**

```
const myWeakMap = new WeakMap();

const obj = { name: 'Alice' };
const func = function() {};
const array = [1, 2, 3];

// 这些是有效的（对象类型）
myWeakMap.set(obj, '关联数据1');
myWeakMap.set(func, '关联数据2'); 
myWeakMap.set(array, '关联数据3');

// 这些会报错（非对象类型）
// myWeakMap.set('string', '值');    // TypeError: Invalid value used as weak map key
// myWeakMap.set(42, '值');          // TypeError
// myWeakMap.set(true, '值');        // TypeError
// myWeakMap.set(null, '值');        // TypeError
// myWeakMap.set(undefined, '值');   // TypeError
// myWeakMap.set(Symbol('sym'), '值'); // TypeError

console.log(myWeakMap.get(obj)); // "关联数据1"
```

2. `map` 使用常规的引用来管理键和值之间的关系，因此即使键不再使用，`map` 仍然会保留该键的内存。`weakMap` 使用弱引用来管理键和值之间的关系，因此如果键不再有其他引用，垃圾回收机制可以自动回收键值对。

这是 `WeakMap`存在的根本原因，也是最重要的区别。

**Map：强引用，阻止垃圾回收**

```
// Map 示例 - 强引用
let obj = { data: '重要数据' };
const myMap = new Map();

myMap.set(obj, '一些元数据');

// 即使我们不再需要 obj，Map 仍然保留着对它的强引用
obj = null; // 解除对对象的引用

// 但对象仍然存在于 Map 中，无法被垃圾回收
console.log([...myMap.keys()]); // [{data: "重要数据"}] - 对象还在！

// 必须手动删除才能释放内存
myMap.delete({data: '重要数据'}); // 这样是删不掉的，因为引用不同
// 正确做法：在设置引用时就保存引用，或者遍历查找
```

**WeakMap：弱引用，允许垃圾回收**

```
// WeakMap 示例 - 弱引用
let obj = { data: '重要数据' };
const myWeakMap = new WeakMap();

myWeakMap.set(obj, '一些元数据');

console.log(myWeakMap.get(obj)); // "一些元数据" - 当前可以访问

// 当我们不再需要 obj 时
obj = null; // 解除对对象的唯一强引用

// 现在，对象只有 WeakMap 的弱引用
// 垃圾回收器会在下次运行时自动回收这个对象
// 同时，WeakMap 中的对应键值对也会被自动移除

// 我们无法验证这一点，因为 WeakMap 不可遍历
// 但可以确信内存已经被释放
```



### 22.说说你对Promise的理解

`Promise`是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了地狱回调。

`Promise`的实例有三个状态:

- `Pending`（初始状态）
- `Fulfilled`（成功状态）
- `Rejected`（失败状态）

`Promise`的实例有两个过程：

- `pending` -> `fulfilled` : **Resolved（已完成）**

- `pending` -> `rejected`：**Rejected（已拒绝）**

  注意：一旦从进行状态变成为其他状态就永远不能更改状态了，其过程是不可逆的。

`Promise`构造函数接收一个带有`resolve`和`reject`参数的回调函数。

- `resolve`的作用是将`Promise`状态从`pending`变为`fulfilled`，在异步操作成功时调用，并将异步结果返回，作为参数传递出去
- `reject`的作用是将`Promise`状态从`pending`变为`rejected`，在异步操作失败后，将异步操作错误的结果，作为参数传递出去

`Promise`的缺点：

- 无法取消 `Promise`，一旦新建它就会立即执行，无法中途取消。
- 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。
- 当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。



### 23.Promise方法

- `promise.then()`  对应`resolve`成功的处理
- `promise.catch()`对应`reject`失败的处理
- `promise.all()`可以完成并行任务，将多个`Promise`实例数组，包装成一个新的`Promise`实例，返回的实例就是普通的`Promise`。有一个失败，代表该`Primise`失败。当所有的子`Promise`完成，返回值时全部值的数组
- `promise.race()`类似`promise.all()`，区别在于有任意一个完成,状态就立刻改变。
- `promise.allSettled()` 返回一个在所有给定的 `promise` 都已经 `fulfilled` 或 `rejected` 后的 `promise` ，并带有一个对象数组，每个对象表示对应的`promise` 结果。



### 24.promise.all 和 promise.allsettled 区别

`Promise.all()` 和 `Promise.allSettled()` 都是用来处理多个 `Promise` 实例的方法，它们的区别在于以下几点：

- **all:** 只有当所有`Promise`实例都`resolve`后，才会`resolve`返回一个由所有`Promise`返回值组成的数组。如果有一个`Promise`实例`reject`，就会立即被拒绝，并返回拒绝原因。`all`是团队的成功才算，如果有一个人失败就算失败。
- **allSettled：** 等所有`Promise`执行完毕后，不管成功或失败， 都会吧每个`Promise`状态信息放到一个数组里面返回。



### 25.对async/await 的理解

`async/await`其实是Generator 的语法糖，它能实现的效果都能用`then`链来实现，它是为优化`then`链而开发出来的。通过`async`关键字声明一个异步函数， `await `用于等待一个异步方法执行完成，**并且会阻塞执行**。 `async` 函数返回的是一个 Promise 对象，如果在函数中 `return` 一个变量，`async` 会把这个直接量通过 `Promise.resolve()` 封装成 `Promise` 对象。如果没有返回值，返回 `Promise.resolve(undefined)`



### 26.async/await对比Promise的优势

- 代码可读性高，`Promise`虽然摆脱了回掉地狱，但自身的链式调用会影响可读性。
- 相对`Promise`更优雅，传值更方便。
- 对错误处理友好，可以通过`try/catch`捕获，`Promise`的错误捕获⾮常冗余

---



### 27.谈谈你对ES6的理解

**先总结：**

- 解构赋值
- 扩展运算符
- 箭头函数
- 模版字符串
- `Set`、`Map`集合
- 新增`class`类
- `Proxy`
- `Promise`



 ES6（ECMAScript 2015）是 JavaScript 语言的一次里程碑式的更新，它引入了大量的新特性，极大地提升了语言的表达能力、开发效率和工程化水平。可以说，现代前端开发（如 React、Vue 等框架）都是建立在 ES6 的基础之上的。

> 1.解构赋值 (Destructuring Assignment)

**理解**：这是一种从数组或对象中提取值的语法，能显著简化赋值操作。

**应用场景与优势**：

- **数组解构**：快速获取数组元素，交换变量值无需中间变量。

  ```
  const [a, b] = [1, 2]; // a=1, b=2
  [a, b] = [b, a]; // 交换变量值
  ```

- **对象解构**：从函数参数或 API 返回对象中快速提取所需属性，代码更直观。

  ```
  const { name, age } = user; // 从user对象中提取name和age
  function connect({ host, port }) { ... } // 函数参数解构，清晰明了
  connect({ host: 'localhost', port: 8080 });
  ```

  **回答要点**：解构赋值让数据提取变得非常简洁，提高了代码的可读性和编写效率。

> 2.扩展运算符 (Spread Operator) `...`

**理解**：它像一把“语法糖”，用于展开数组或对象。

**应用场景与优势**：

- **数组操作**：轻松实现数组复制、合并。

  ```
  const newArr = [...oldArr, newItem]; // 数组合并
  const arrCopy = [...originalArr]; // 数组浅拷贝
  ```

- **对象操作**：实现对象浅拷贝、合并新属性，是替代 `Object.assign`的更直观方式。

  ```
  const newObj = { ...oldObj, newProp: 'value' }; // 对象合并
  ```

- **函数调用**：将数组展开为函数的参数列表。

  ```
  const nums = [1, 2, 3];
  Math.max(...nums); // 等同于 Math.max(1, 2, 3)
  ```

  **回答要点**：扩展运算符极大地简化了集合数据的操作，使代码更函数式、更优雅。

> 3.箭头函数 (Arrow Functions) `=>`

**理解**：提供了一种更简洁的函数写法，并解决了 `this`指向的难题。

**应用场景与优势**：

- **语法简洁**：特别适合用于回调函数。

  ```
  // 传统函数
  arr.map(function(item) { return item * 2; });
  // 箭头函数
  arr.map(item => item * 2);
  ```

  

  **没有自己的 `this`**：箭头函数内的 `this`继承自定义它的外层作用域。这彻底解决了传统函数中 `this`指向不确定的问题，尤其在事件处理、定时器回调等场景下非常有用。

  ```
  class Counter {
      constructor() {
          this.count = 0;
          // 传统函数需要 .bind(this)，箭头函数则不需要
          setInterval(() => {
              this.count++; // 这里的this正确地指向Counter实例
          }, 1000);
      }
  }
  ```

  **回答要点**：箭头函数不仅让代码更短，更重要的是它词法作用域的 `this`行为，避免了许多潜在错误。

> 4. 模板字符串 (Template Literals)

**理解**：使用反引号 (`) 来定义字符串，允许嵌入变量和表达式。

**应用场景与优势**：

- **字符串拼接**：告别繁琐的 `+`号拼接，支持多行字符串，非常适合拼接 HTML 模板或长文本。

  ```
  const name = 'Alice';
  const message = `Hello, ${name}!
  Welcome to our website.`;
  ```

  **回答要点**：模板字符串极大地改善了字符串的处理体验，使动态字符串的生成更加清晰和方便。

> 5. Set 与 Map 集合

**理解**：提供了更专业的集合数据结构。

- **`Set`**：成员值唯一的集合，常用于数组去重。

  ```
  const unique = [...new Set([1, 2, 2, 3])]; // [1, 2, 3]
  ```

- **`Map`**：键值对集合，但键可以是任意类型（对象、函数等），比普通 Object 更强大。

  ```
  const map = new Map();
  const keyObj = {};
  map.set(keyObj, 'value'); // 对象作为键
  ```

  **回答要点**：`Set`和 `Map`填补了 JavaScript 在特定数据结构上的空白，提供了比普通对象和数组更语义化、更高效的操作方式。

>  6. 新增 Class 类

**理解**：语法糖，让基于原型的继承写法更清晰、更像传统面向对象语言。

**应用场景与优势**：

- 引入了 `class`、`constructor`、`static`、`extends`、`super`等关键字。

  ```
  class Person {
      constructor(name) { this.name = name; }
      sayHello() { console.log(`Hello, I'm ${this.name}`); }
  }
  class Student extends Person {
      constructor(name, grade) {
          super(name); // 调用父类构造函数
          this.grade = grade;
      }
  }
  ```

  **回答要点**：`class`语法并没有改变 JavaScript 基于原型的本质，但它降低了面向对象编程的理解和上手门槛，使代码结构更清晰。

> 7. Proxy

**理解**：用于创建一个对象的代理，从而可以拦截并自定义对象的基本操作（如属性查找、赋值、函数调用等）。

**应用场景与优势**：

- 实现高级功能，如数据绑定（Vue 3 的核心）、验证、日志记录等。

  ```
  const handler = {
      get(target, prop) {
          console.log(`Getting property ${prop}`);
          return target[prop];
      }
  };
  const p = new Proxy({}, handler);
  p.a = 1;
  console.log(p.a); // 会打印日志 "Getting property a"
  ```

  **回答要点**：`Proxy`提供了强大的**元编程**能力，允许我们扩展语言本身的行为，是实现复杂框架和库的基石。

> 8. Promise

**理解**：异步编程的一种解决方案，比传统的回调函数更强大。

**应用场景与优势**：

- **解决回调地狱**：通过链式调用（`.then().catch()`）将嵌套的异步操作变为扁平化的流水线操作，代码可读性大大增强。

  ```
  fetchData()
      .then(processData)
      .then(displayData)
      .catch(handleError);
  ```

- **为 async/await 奠基**：`Promise`是 `async/await`语法的基础，后者让异步代码看起来像同步代码，是目前处理异步的首选方案。 **回答要点**：`Promise`统一了异步编程模型，是现代 JavaScript 异步处理的基石，它使得复杂的异步流程控制变得简单可控。



### 28.ES6 模块与 CommonJS 模块的区别

ES6 模块和 CommonJS 模块是现代 JavaScript 开发中两种主要的模块系统,在前端业务代码部分，主要使用es6，在项目底层、构建工具、npm包生态中，commjs则扮演者更重要的角色。他们是js中两种不同的模块化方案。

> 1. 导入、导出模块方式不同

- **ES6 模块 (ESM)**：使用声明式的 `import`和 `export`关键字。

  ```
  // 导入 (import)
  import { foo, bar } from './module.js'; // 命名导入
  import defaultExport from './module.js'; // 默认导入
  import * as Module from './module.js'; // 全部导入
  
  // 导出 (export)
  export const bar = 'bar'; // 命名导出
  export default foo; // 默认导出
  ```

  **特点**：语法是静态的，意味着导入导出语句必须位于模块的顶层作用域，不能嵌套在条件语句中。这种设计有利于进行静态分析。

- **CommonJS (CJS)**：使用函数式的 `require()`和对象式的 `module.exports`或 `exports`。

  ```
  // 导入 (require)
  const fs = require('fs'); // 导入内置模块
  const myModule = require('./my-module.js'); // 导入本地模块
  
  // 导出 (module.exports / exports)
  module.exports = someValue; // 直接导出
  exports.bar = 'bar'; // 命名导出 (exports 是 module.exports 的一个引用)
  ```

  **特点**：语法是动态的，`require()`可以出现在代码的任何地方（如条件判断、函数中），因为它是一个函数调用。

**核心区别**：ESM 是**静态**的，CJS 是**动态**的。ESM 的静态结构使得打包工具（如 Webpack、Vite）可以在打包阶段就分析出模块的依赖关系，进行 **Tree Shaking**（消除死代码），这是 ESM 的一个巨大优势。

> 2.加载时机与运行方式 (Loading Time & Execution)

这是最本质的区别，决定了它们的应用场景。

- **CommonJS (CJS)**：**同步加载**，主要用于服务器端（如 Node.js 环境）。**过程**：当执行 `require('./module.js')`时，Node.js 会**同步地**阻塞后续代码，先去读取、执行整个 `module.js`文件，然后将 `module.exports`的值返回给 `require`的调用方。**适用场景**：在服务器端，模块文件都在本地磁盘，同步加载速度很快，不会成为性能瓶颈。
- **ES6 模块 (ESM)**：**异步加载**，天生适用于浏览器环境。**过程**：当遇到 `import`语句时，浏览器会**异步地**发起请求获取模块文件，但不会阻塞主线程。它会先解析整个模块的依赖关系，形成一个“模块图”，然后按照依赖顺序执行模块代码。

> 3. 值的引用与拷贝 (Value Reference vs. Copy)

这关系到模块导入值的动态绑定问题。

- **CommonJS (CJS)**：输出的是值的**拷贝**。

  ```
  // commonjs.js
  let count = 0;
  function increment() { count++; }
  module.exports = { count, increment };
  
  // main.js
  const { count, increment } = require('./commonjs.js');
  console.log(count); // 0
  increment();
  console.log(count); // 0 (值没有改变，因为导入的是原始值的拷贝)
  ```

- **ES6 模块 (ESM)**：输出的是值的**引用**（动态绑定）。

  ```
  // esm.js
  export let count = 0;
  export function increment() { count++; }
  
  // main.js
  import { count, increment } from './esm.js';
  console.log(count); // 0
  increment();
  console.log(count); // 1 (值改变了，因为导入的是活的引用)
  ```

**核心区别**：ESM 是**动态绑定**，类似于指针，导入的变量会随着导出模块内值的改变而改变。CJS 是**值的浅拷贝**，导入后就和导出模块没关系了。





### 29.call() 、bind（）、 apply() 的区别？

`call`、`apply`和 `bind`都用于改变函数的 `this`指向，主要区别在于：

**执行时机**：`call`和 `apply`会**立即执行**函数，而 `bind`是**返回一个新函数**供后续调用。

**参数传递**：`call`接受**参数列表**，`apply`接受**参数数组**，`bind`可以分两次传递参数。

**使用场景**：`call`常用于**方法借用**，比如将类数组转为真正数组`apply`适合处理**参数是数组**的情况，比如数组合并`bind`主要用于**固定 `this`上下文**，比如事件处理函数和回调函数

简单来说，如果想立即调用函数，根据参数形式选择 `call`或 `apply`；如果想创建一个新的绑定函数供以后使用，就选择 `bind`。





好的，这是一个非常经典的面试题。`call()`、`apply()`和 `bind()`都是用于改变函数内部 `this`指向的方法，但它们在用法和时机上有关键区别。

**核心区别总结表**

| 特性         | `call(thisArg, arg1, arg2, ...)` | `apply(thisArg, [argsArray])`         | `bind(thisArg, arg1, arg2, ...)`                   |
| :----------- | :------------------------------- | :------------------------------------ | :------------------------------------------------- |
| **执行时机** | **立即执行**                     | **立即执行**                          | **不立即执行**，返回一个新函数（绑定函数）         |
| **参数形式** | 参数**逐个传递**                 | 参数作为**数组**或**类数组对象**传递  | 参数可逐个传递（分两次：绑定时可传，执行时可再传） |
| **返回值**   | 原函数的返回值                   | 原函数的返回值                        | 一个**新的函数**，其 `this`被永久绑定              |
| **主要用途** | 1. 借用方法 2. 继承              | 1. 参数是数组的情况 2. 与数学函数结合 | 1. 回调函数绑定 `this` 2. 偏函数应用               |





假设我们有一个对象和一个函数：

```
const person = {
  name: 'Alice'
};

function introduce(city, country) {
  console.log(`Hello, I'm ${this.name} from ${city}, ${country}`);
}
```

1.`call()`- 立即调用，参数逐个传递

**语法：** `function.call(thisArg, arg1, arg2, ...)`

```
introduce.call(person, 'Beijing', 'China');
// 立即输出: "Hello, I'm Alice from Beijing, China"
- 第一个参数是 `this`的新指向（`person`）
- 后续参数逐个传递给原函数
```

**经典应用：借用方法**

```
// 类数组对象 arguments 没有数组的 slice 方法
function logArgs() {
  // 借用 Array.prototype.slice 方法
  const argsArray = Array.prototype.slice.call(arguments);
  console.log(argsArray); // 变成真正的数组: [1, 2, 3]
}
logArgs(1, 2, 3);
```

2.`apply()`- 立即调用，参数数组传递

**语法：** `function.apply(thisArg, [argsArray])`

```
const myInfo = ['Shanghai', 'China'];
introduce.apply(person, myInfo);
// 立即输出: "Hello, I'm Alice from Shanghai, China"
- 第一个参数是 `this`的新指向
- 第二个参数是**数组**（或类数组对象），包含所有要传递的参数
```

**经典应用：数组合并**

```
const numbers = [1, 2, 3];
const moreNumbers = [4, 5, 6];

// 将 moreNumbers 的元素 push 到 numbers 中
Array.prototype.push.apply(numbers, moreNumbers);
console.log(numbers); // [1, 2, 3, 4, 5, 6]

// 现代写法（ES6+）：
numbers.push(...moreNumbers);
```

3.`bind()`- 不立即调用，返回新函数

**语法：** `function.bind(thisArg, arg1, arg2, ...)`

```
// 不立即执行，而是返回一个新函数
const introduceAlice = introduce.bind(person, 'Tokyo');
// 此时还没有输出任何内容

// 需要手动调用新函数
introduceAlice('Japan'); 
// 输出: "Hello, I'm Alice from Tokyo, Japan"

// 也可以一次性绑定所有参数
const introduceAliceFromTokyoJapan = introduce.bind(person, 'Tokyo', 'Japan');
introduceAliceFromTokyoJapan(); 
// 输出: "Hello, I'm Alice from Tokyo, Japan"
- 返回一个**新函数**，其 `this`被永久绑定到 `thisArg`
- 绑定的参数是"部分应用"的，调用新函数时可以继续传递剩余参数
```

**经典应用：事件处理函数**

```
class Button {
  constructor() {
    this.text = 'Click me';
    // 将 handleClick 的 this 永久绑定到当前实例
    this.element = document.createElement('button');
    this.element.addEventListener('click', this.handleClick.bind(this));
  }

  handleClick() {
    console.log(`Button text: ${this.text}`); // 这里的 this 始终指向实例
  }
}
```

**连续使用 `bind`时，`this`的指向取决于第一个 `bind`调用，后续的 `bind`调用不会改变 `this`指向。**

这是一个非常重要的知识点，也是面试中常见的陷阱题。

**`bind()`创建的绑定函数的 `this`是永久性的，后续再次 `bind()`无法覆盖。**

```
const obj1 = { name: 'Object 1' };
const obj2 = { name: 'Object 2' };  
const obj3 = { name: 'Object 3' };

function showName() {
    console.log(this.name);
}

// 连续 bind
const boundFn = showName.bind(obj1).bind(obj2).bind(obj3);

boundFn(); // 输出: "Object 1"（而不是 Object 3！）
```

> 手写call

前置知识：

一、不同环境下的全局对象不同：

```
// 在浏览器中运行
console.log(window); // 存在，是全局对象
console.log(global); // undefined

// 在Node.js中运行  
console.log(window); // undefined
console.log(global); // 存在，是全局对象

// 在Web Workers或其他环境中
console.log(window); // undefined
console.log(global); // undefined
```

代码解析

```
context = context || (typeof window !== 'undefined' ? window : global);
```

这行代码的意思是：

1. 如果用户传入了 `context`，就使用用户传入的
2. 如果用户没传 `context`（即 `context`是 `null`或 `undefined`）：先检查 `window`是否存在（判断是否在浏览器环境）如果 `window`存在，使用 `window`作为默认 `this`指向如果 `window`不存在，使用 `global`（Node.js 环境）

二、一个对象调用了一个函数，那么这个函数内部的this指的就是这个对象。

在 JavaScript 中，**方法的 `this`指向调用该方法的对象**，函数也是一种对象。



手写call代码：

```js
Function.prototype.myCall = function(context, ...args) {
    console.log(this) //greet，mycall方法被greet函数对象调用，this指的是greet函数。
    // 1. 处理 context 为 null 或 undefined 的情况，默认指向 window（浏览器）或 global（Node.js）
    context = context || (typeof window !== 'undefined' ? window : global);
    
    // 2. 避免属性名冲突，使用 Symbol 创建唯一键
    const fnKey = Symbol('fn');
    
    // 3. 将当前函数（this）设置为 context 的方法
    context[fnKey] = this;

    // 现在content的内容包括：
    // person{
    //     name:'Alice',
    //     ['fn']:greet(){...}
    // }
    
    // 4. 执行函数，传入参数
    const result = context[fnKey](...args);
    
    // 5. 删除添加的属性，避免污染原对象
    delete context[fnKey];
    
    // 6. 返回执行结果
    return result;
};
```

测试：

```js
const person = {
    name: 'Alice'
};

function greet(age, city) {
    console.log(`Hello, I'm ${this.name}, ${age} years old, from ${city}`);
}

// 原生 call
greet.call(person, 25, 'Beijing');        // Hello, I'm Alice, 25 years old, from Beijing

// 手写 myCall
greet.myCall(person, 25, 'Beijing');      // Hello, I'm Alice, 25 years old, from Beijing

// 边界情况测试
greet.myCall(null, 30, 'Shanghai');       // Hello, I'm undefined, 30 years old, from Shanghai（指向全局）
```





> 手写apply

```js
Function.prototype.myApply = function(context, argsArray) {
    // 1. 处理 context
    context = context || (typeof window !== 'undefined' ? window : global);
    
    // 2. 处理参数数组（argsArray 可能为 undefined 或 null）
    const args = argsArray || [];
    
    // 3. 使用 Symbol 避免属性冲突
    const fnKey = Symbol('fn');
    
    // 4. 将函数设置为 context 的方法
    context[fnKey] = this;
    
    // 5. 执行函数，使用展开语法传递参数数组
    const result = context[fnKey](...args);
    
    // 6. 清理属性
    delete context[fnKey];
    
    // 7. 返回结果
    return result;
};
```

```js
const numbers = [1, 2, 3, 4, 5];

// 求最大值 - 原生 apply
const max1 = Math.max.apply(null, numbers);

// 求最大值 - 手写 myApply  
const max2 = Math.max.myApply(null, numbers);

console.log(max1, max2); // 5 5

// 数组拼接测试
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

Array.prototype.push.myApply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
```



> 手写bind

实现思路：

1. 返回一个新函数（闭包）
2. 新函数执行时，使用正确的 `this`上下文
3. 支持参数合并（绑定时参数 + 执行时参数）
4. 处理 `new`操作符的情况（构造函数调用）

代码实现：

```js
Function.prototype.myBind = function(context, ...bindArgs) {
    const originalFn = this;
    
    // 返回绑定函数
    const boundFn = function(...callArgs) {
        // 判断是否通过 new 调用（构造函数调用）
        const isNewCall = this instanceof boundFn;
        
        // 如果是 new 调用，this 指向新创建的对象，否则使用绑定的 context
        const thisContext = isNewCall ? this : context;
        
        return originalFn.apply(thisContext, [...bindArgs, ...callArgs]);
    };
    
    // 维护原型关系：确保 boundFn 与 originalFn 有相同的原型链
    // 这样 instanceof 操作符才能正常工作
    if (originalFn.prototype) {
        // 使用空函数中转，避免直接修改 boundFn.prototype 影响 originalFn.prototype
        const Empty = function() {};
        Empty.prototype = originalFn.prototype;
        boundFn.prototype = new Empty();
    }
    
    return boundFn;
};
```

```js
const person = {
    name: 'Alice'
};

function introduce(age, city, hobby) {
    console.log(`I'm ${this.name}, ${age} years old, from ${city}, like ${hobby}`);
}

// 原生 bind
const bound1 = introduce.bind(person, 25);
bound1('Beijing', 'coding');  // I'm Alice, 25 years old, from Beijing, like coding

// 手写 myBind  
const bound2 = introduce.myBind(person, 25);
bound2('Beijing', 'coding');  // I'm Alice, 25 years old, from Beijing, like coding

// 测试参数合并
const boundWithArgs = introduce.myBind(person, 25, 'Shanghai');
boundWithArgs('reading');  // I'm Alice, 25 years old, from Shanghai, like reading

// 测试 new 操作符
function Person(name) {
    this.name = name;
}

const BoundPerson = Person.myBind({}, 'Initial');
const instance = new BoundPerson();  // this 指向新实例，不是绑定的 {}
console.log(instance.name);  // 'Initial'
```













### 30.浏览器的垃圾回收机制

**垃圾回收**：`JavaScript`代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。

在 V8 中，会把堆分为**新生代和老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象：

- Major  GC(主垃圾回收器)

  ：主要负责老生代垃圾的回收

  - 内存占用比较小

- Minor GC(副垃圾回收器)

  ：主要负责新生代垃圾的回收

  - 对象的占用空间大  对象存活时间长 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b90d49a71ff04b1b926a00e4acc3cb8d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=801&h=540&s=47668&e=png&b=fefefe)

**新生代（副垃圾回收器）**

副垃圾回收器主要负责新⽣代的垃圾回收。大多数的对象最开始都会被分配在新生代，该存储空间相对较小，分为两个空间：**from 空间**（对象区）和 **to 空间**（空闲区）。

- 新增变量会放到`To`空间，当空间满后需要执行一次垃圾清理操作
- 对垃圾数据进行标记，标记完成后**将存活的数据复制到From空间中**，有序排列
- 交换两个空间，原来的`To`变成`From`，旧的`From`变成`To`

**老生代（主垃圾回收器）**

主垃圾回收器主要负责⽼⽣代中的垃圾回收。存储一些占用空间大、存活时间长的数据，采用**标记清除**算法进行垃圾回收。

主要分为**标记**、**清除**两个阶段。

- **标记**：将所有的变量打上标记0，然后从根节点(`window`对象、DOM树等)开始遍历，把存活的变量标记为1
- **清除**：清除标记为0的对象，释放内存。清除后将1的变量改为0，方便下一轮回收。

对⼀块内存多次执⾏标记清除算法后，会**产⽣⼤量不连续的内存碎⽚**。⽽碎⽚过多会导致⼤对象⽆法分配到⾜够的连续内存，于是⼜引⼊了另外⼀种算法——**标记整理**。

**标记整理**的标记过程仍然与标记清除算法⾥的是⼀样的，先标记可回收对象，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有**存活的对象都向⼀端移动**，然后直接清理掉这⼀端之外的内存。

**引用计数法**

一个对象被引用一次，引用数就+1，反之就-1。当引用为0，就会出发垃圾回收。

这种方式会产生一个问题，在循环引用时，引用数永远不会为0，无法回收。





### 31.哪些情况会导致内存泄漏

意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

被遗忘的计时器或回调函数：设置了 `setInterval` 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

脱离 `DOM` 的引用：获取一个 `DOM` 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。

闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。









# vue

### 1.请系统讲讲 Vue2 与 Vue3 的核心差异（响应式、API 设计、性能与编译器）。

Vue2 和 Vue3 的核心差异主要体现在以下几个方面：
**1. 响应式系统（底层原理的根本性变化）**

| **特性**                                                     | **Vue2**                                                     | **Vue3**                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **底层实现**                                                 | 使用 **`Object.defineProperty`**                             | 使用 **`Proxy`** API                                         |
| **检测限制**                                                 | 无法监听对象属性的**新增**和**删除**，需要使用 `$set` 或 `$delete` 。 | 可以直接监听对象属性的**新增**和**删除**，不需要特殊 API。   |
| **数组检测**                                                 | 需要重写数组原型方法（如 `push`, `pop` ,`shift`,`unshift`,`splice`,`sort`,`reverse`）。 | `可以通过 `Proxy` 直接拦截数组操作，支持数组索引访问和修改。` |
| **`Proxy` 的优势：** 提供了完整的对象代理能力，性能更好，且解决了 Vue2 中无法追踪新增/删除属性的痛点。 |                                                              |                                                              |

```js
<template>
  <div>
    <h1>个人信息</h1>
    <h2>name:{{ student.name }}</h2>
    <h2 v-show="student.sex">sex:{{ student.sex }}</h2>
    <h2 v-show="student.height">height:{{ student.height }}</h2>
    <h2>hobby:{{ student.hobby }}</h2>
    <button @click="addproperty">添加身高属性</button>
    <button @click="deleteproperty">删除性别属性</button>
    <button @click="changeproperty">修改爱好属性</button>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      student: {
        name: "zk",
        sex: "male",
        hobby: ["drink", "walk"],
      },
    };
  },
  // 3_src_vue2响应式原理
  methods: {
    addproperty() {
      console.log(this.student);
      // 在vue2环境下，添加成功，但是页面并不会响应更新
      console.log(this.student.height);
      // this.student.height = "170";
      console.log(this.student.height);
      // 解决办法,记得在vue2环境下执行
      this.$set(this.student, "height", 170);
      // 问题：使用数组下标添加不会响应生效
      // this.student.hobby[0] = "play";
      // 解决
      this.student.hobby.splice(0, 0, "paly");
    },
    changeproperty() {
      // 问题：使用数组下标添加不会响应生效
      // this.student.hobby[0] = "play";
      // 解决
      this.student.hobby.splice(0, 1, "paly");
    },
    deleteproperty() {
      // 同样在vue2环境下，页面不能够及时响应
      // delete this.student.sex;
      // 解决办法
      this.$delete(this.student, "sex");
    },
  },
};
</script>

<style></style>

```



**2. 组件编写方式（代码组织方式的变化）**



| **特性**       | **Vue2**                                                     | **Vue3**                                                     |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **API 风格**   | **选项式 API (Options API)**：将逻辑分散到不同的选项中（`data`、`methods`、`computed`、`watch` 等） 。 | **组合式 API (Composition API)**：通过 `setup` 函数，将同一功能的逻辑集中写在一起 。 |
| **逻辑复用**   | 主要通过 `Mixins` 实现，容易造成命名冲突和数据来源不清晰。   | 通过自定义 **`Hooks`** (例如：`useMousePosition`) 实现，逻辑清晰，类型推导友好（配合 TypeScript 6）。 |
| **TypeScript** | 对 TS 支持不友好，需要额外的装饰器或工具。                   | 对 TS 支持是**原生**的， Composition API 更容易进行类型推导 7。 |
|                |                                                              |                                                              |



**组合式 API (Composition API) 的优势：** 提高了大型项目逻辑的可读性、可维护性和复用性，特别适合复杂组件的开发 8。





**3. 性能优化与打包体积**



| **特性**     | **Vue2**                          | **Vue3**                                                     |
| ------------ | --------------------------------- | ------------------------------------------------------------ |
| **编译优化** | 缺少静态提升，全量虚拟 DOM 比对。 | **静态提升 (Static Hoisting)** 和 **块级 (Block Tree) 优化**。 |
| **虚拟 DOM** | 全量遍历比对 VDOM 树。            | 编译时标记静态内容，运行时只比对**动态**部分，减少了不必要的比对，提升了渲染性能。 |
| **打包体积** | 难以进行彻底的 **Tree-shaking**。 | 许多内部模块（如 `Transition`、`KeepAlive`）是按需导入的，配合 Composition API，能实现更彻底的 Tree-shaking，减小打包体积。 |





**总结**

1. **响应式系统**：

   - **Vue 2**：基于Object.defineProperty，无法自动检测**对象属性的添加/删除**和**数组索引变化**，需借助Vue.set/Vue.delete等特殊 API。
   - **Vue 3**：基于Proxy，**原生支持**对对象和数组的各种变化监听，无上述限制，性能更优。

2. **API 设计**：

   - **Vue 2 (Options API)**：按选项（data,methods等）组织代码，逻辑分散。复用代码使用 **Mixins**，容易引发命名冲突。
   - **Vue 3 (Composition API)**：按**逻辑功能**组织代码，相关代码集中，更利于维护和阅读。复用代码使用**自定义 Hook 函数**，清晰灵活，且**原生 TypeScript 支持极佳**。

3. **性能与编译器**：

   - Vue 3

     在编译阶段进行了大量优化：

     - **Tree-shaking**：未使用的 API 不会打包进最终产物，体积更小。
     - **Patch Flags**：编译时标记动态节点，Diff 算法时直接定位变化，大幅提升虚拟 DOM 比对效率。
     - **静态提升**：将静态节点缓存，跳过重复渲染。

   - 结果：Vue 3 在**打包体积、更新性能、内存占用**上均优于 Vue 2。

4. **新特性**：

   - **Vue 3** 新增了 **Teleport**（将组件渲染到指定DOM）、**Fragment**（支持多根节点模板）等特性，解决了常见开发痛点。





### 2.说说 Vue 的生命周期（含父子组件先后顺序）以及常见实践放在哪些钩子里。



![image-20251116222740509](.\assets\image-20251116222740509.png)

Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期

| 生命周期      | 描述                               |
| :------------ | :--------------------------------- |
| beforeCreate  | 组件实例被创建之初                 |
| created       | 组件实例已经完全创建               |
| beforeMount   | 组件挂载之前                       |
| mounted       | 组件挂载到实例上去之后             |
| beforeUpdate  | 组件数据发生变化，更新之前         |
| updated       | 组件数据更新之后                   |
| beforeDestroy | 组件实例销毁之前                   |
| destroyed     | 组件实例销毁之后                   |
| activated     | keep-alive 缓存的组件激活时        |
| deactivated   | keep-alive 缓存的组件停用时调用    |
| errorCaptured | 捕获一个来自子孙组件的错误时被调用 |

==**生命周期流程**==

**使用场景**

1. **创建阶段（Creation）**：初始化响应式数据和事件。
   - beforeCreate：实例刚创建，**数据data和事件methods还未初始化**。
   - created：**实例创建完成**。数据data已响应式化，事件methods已配置，**可在此发起异步请求**。**但未挂载，DOM 不存在**。
2. **挂载阶段（Mounting）**：将模板编译渲染成真实 DOM 并插入页面。
   - beforeMount：模板已编译，**但尚未将渲染内容挂载到页面上**。
   - mounted：**实例已挂载到页面**，真实 DOM 已生成并可访问，**可在此进行 DOM 操作或访问$refs**。
3. **更新阶段（Updating）**：当数据变化时，虚拟 DOM 重新渲染和打补丁。
   - beforeUpdate：数据发生变化，**但虚拟 DOM 尚未重新渲染**。
   - updated：数据更改导致虚拟 DOM 重新渲染和打补丁完成，**可在此操作更新后的 DOM**（但要谨慎，避免无限循环更新）。
4. **卸载阶段（Unmouting/Destruction）**：实例被销毁。
   - beforeUnmount(Vue 3) /beforeDestroy(Vue 2)：**实例即将被销毁**，此刻实例仍完全可用。
   - unmounted(Vue 3) /destroyed(Vue 2)：**实例已销毁**，所有指令被解绑，事件监听器被移除，子实例也被销毁。**在此进行最终的清理工作**（如清除定时器、取消事件总线监听）。

> **注意**：Vue 3 将beforeDestroy和destroyed重命名为beforeUnmount和unmounted，语义更准确。

**beforeCreate -> created**

- 初始化`vue`实例，进行数据观测

**created**

- 完成数据观测，属性与方法的运算，`watch`、`event`事件回调的配置
- 可调用`methods`中的方法，访问和修改data数据触发响应式渲染`dom`，可通过`computed`和`watch`完成数据计算
- 此时`vm.$el` 并没有被创建

**created -> beforeMount**

- 判断是否存在`el`选项，若不存在则停止编译，直到调用`vm.$mount(el)`才会继续编译
- 优先级：`render` > `template` > `outerHTML`
- `vm.el`获取到的是挂载`DOM`的

**beforeMount**

- 在此阶段可获取到`vm.el`
- 此阶段`vm.el`虽已完成DOM初始化，但并未挂载在`el`选项上

**beforeMount -> mounted**

- 此阶段`vm.el`完成挂载，`vm.$el`生成的`DOM`替换了`el`选项所对应的`DOM`

**mounted**

- `vm.el`已完成`DOM`的挂载与渲染，此刻打印`vm.$el`，发现之前的挂载点及内容已被替换成新的DOM

**beforeUpdate**

- 更新的数据必须是被渲染在模板上的（`el`、`template`、`render`之一）
- 此时`view`层还未更新
- 若在`beforeUpdate`中再次修改数据，不会再次触发更新方法

**updated**

- 完成`view`层的更新
- 若在`updated`中再次修改数据，会再次触发更新方法（`beforeUpdate`、`updated`）

**beforeDestroy**

- 实例被销毁前调用，此时实例属性与方法仍可访问

**destroyed**

- 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器
- 并不能清除DOM，仅仅销毁实例

==数据请求在created在mounted的区别==

`created`是在组件实例一旦创建完成的时候立刻调用，这时候页面`dom`节点并未生成；`mounted`是在页面`dom`节点渲染完毕之后就立刻执行的。触发时机上`created`是比`mounted`要更早的，两者的相同点：都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在`mounted`中的请求有可能导致页面闪动（因为此时页面`dom`结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在`created`生命周期当中。

==父子组件生命周期顺序==

这是一个高频面试点，顺序如下：

- **加载渲染过程**：
  父 beforeCreate->父 created->父 beforeMount-> **子 beforeCreate->子 created->子 beforeMount->子 mounted** ->父 mounted
- **更新过程**：
  父 beforeUpdate-> **子 beforeUpdate->子 updated** ->父 updated
- **销毁过程**：
  父 beforeUnmount-> **子 beforeUnmount->子 unmounted** ->父 unmounted

**规律**：父组件总会等待其内部的子组件完成后，自己才会完成。如同“父组件搭建好框架(beforeMount)，子组件进去装修完工(mounted)，父组件才算整体完工(mounted)”

==常见实践和钩子选择==

| 生命周期钩子                    | 常见实践与操作                                               |
| :------------------------------ | :----------------------------------------------------------- |
| **created**                     | **最常用**。进行**异步数据请求**（如调用 API）、初始化一些非响应式的数据。此时可访问data和methods，但无法操作 DOM。 |
| **mounted**                     | **操作 DOM**、使用$refs访问子组件或 DOM 元素、集成第三方库（如图表库、地图库）需要 DOM 的场景。 |
| **beforeUnmount/beforeDestroy** | **清理工作**。清除定时器 (clearInterval)、取消事件总线监听 ($off)、取消未完成的网络请求，防止内存泄漏。 |
| **updated**                     | **在数据更改后操作更新后的 DOM**。使用较少，需特别小心，因为任何数据修改都可能触发此钩子，容易导致无限更新循环。 |
| **activated/deactivated**       | （配合\<keep-alive>使用）当组件被切换时，用于执行激活或停用的逻辑（如重新请求数据、暂停视频播放）。 |



### 3.Vue 的 MVVM 模式

1. **View（视图）**

视图是用户直接与之交互的部分，通常是 HTML 页面中的元素。它负责展示数据和接收用户的输入。在 Vue 中，视图通过模板语法（如 `{{ }}` 和 `v-bind`）来展示数据，通过事件监听（如 `v-on`）来响应用户的操作。

2. **Model（模型）**

模型是应用程序的数据存储部分。它包含了应用程序需要处理的所有数据。在 Vue 中，模型通常是 Vue 实例的 `data` 属性中定义的数据对象。模型中的数据可以是简单的变量，也可以是复杂的对象。

3. **ViewModel（视图模型）**

视图模型是连接视图和模型的桥梁。它负责监听模型中的数据变化，并将这些变化同步到视图上；同时，它也负责将视图中的用户操作（如输入框的值变化）同步到模型中。Vue 的核心功能之一就是实现了这个视图模型的自动化。

4. **`v-model` 的作用**

`v-model` 是 Vue 中实现双向数据绑定的重要指令，它是视图模型（ViewModel）的一个重要手段。通过 `v-model`，Vue 实现了视图和模型之间的自动同步。



**总结**

- **View（视图）**：展示数据和接收用户输入。
- **Model（模型）**：存储和管理数据。
- **ViewModel（视图模型）**：通过 `v-model` 等机制实现视图和模型之间的双向数据绑定，确保它们之间的数据同步。



### 4.什么是SPA

**1. 什么是单页面应用（SPA）**

单页面应用（SPA）是一种网页应用，用户在浏览时不需要重新加载整个页面。就像你在手机上用一个APP，点击不同的按钮，页面内容会变，但整个APP不会重新启动一样。

**2. 举个例子**

想象你有一个电子书阅读器的网站：

- **传统网页应用** ：每次你点击不同的章节，整个页面都会重新加载，就像你每次换书都要重新打开一个新的书一样。
- **单页面应用（SPA）** ：你点击不同的章节，只有书的内容会变，但整个页面不会重新加载，就像你在同一个书里翻页一样。

**3. SPA 的工作原理**

- **初始加载** ：用户第一次访问时，加载一个主页面，这个页面包含了所有需要的代码。
- **动态更新** ：用户点击按钮或进行操作时，只有需要的部分会更新，不需要重新加载整个页面。

官方专业一些的写法：

1. **初始加载** ：当用户首次访问 SPA 时，浏览器会加载一个主页面（通常是 `index.html`），这个页面包含了应用的基本结构和必要的脚本（如 JavaScript 文件）。
2. **动态内容加载** ：用户在应用中进行操作（如点击菜单、提交表单等）时，应用会通过 JavaScript 动态地从服务器请求数据（通常是 JSON 格式），然后根据这些数据更新页面的局部内容，而不是重新加载整个页面。
3. **路由管理** ：SPA 通常使用前端路由（也称为客户端路由）来管理不同的视图。前端路由通过监听 URL 的变化（通常是通过 `hash` 或 `history` API）来决定加载哪个组件或视图。



### 5.v-show和v-if有什么区别？使用场景分别是什么？



**v-show与v-if的共同点**

我们都知道在 `vue` 中 `v-show` 与 `v-if` 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示

在用法上也是相同的

```js
<Model v-show="isShow" />
<Model v-if="isShow" />
```

- 当表达式为`true`的时候，都会占据页面的位置
- 当表达式都为`false`时，都不会占据页面位置

**v-show与v-if的区别**

- 控制手段不同
- 编译过程不同
- 编译条件不同

控制手段：`v-show`隐藏则是为该元素添加`css--display:none`，`dom`元素依旧还在。`v-if`显示隐藏是将`dom`元素整个添加或删除

编译过程：`v-if`切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；`v-show`只是简单的基于css切换

编译条件：`v-if`是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染

- `v-show` 由`false`变为`true`的时候不会触发组件的生命周期
- `v-if`由`false`变为`true`的时候，触发组件的`beforeCreate`、`create`、`beforeMount`、`mounted`钩子，由`true`变为`false`的时候触发组件的`beforeDestory`、`destoryed`方法

性能消耗：`v-if`有更高的切换消耗；`v-show`有更高的初始渲染消耗；



**v-show与v-if的使用场景**

`v-if` 与 `v-show` 都能控制`dom`元素在页面的显示

`v-if` 相比 `v-show` 开销更大的（直接操作`dom`节点增加与删除）

如果需要非常频繁地切换，则使用 v-show 较好

如果在运行时条件很少改变，则使用 v-if 较好



==下面的看不懂==

**v-show与v-if原理分析**

具体解析流程这里不展开讲，大致流程如下

- 将模板`template`转为`ast`结构的`JS`对象
- 用`ast`得到的`JS`对象拼装`render`和`staticRenderFns`函数
- `render`和`staticRenderFns`函数被调用后生成虚拟`VNODE`节点，该节点包含创建`DOM`节点所需信息
- `vm.patch`函数通过虚拟`DOM`算法利用`VNODE`节点创建真实`DOM`节点

**v-show原理**



不管初始条件是什么，元素总是会被渲染

我们看一下在`vue`中是如何实现的

代码很好理解，有`transition`就执行`transition`，没有就直接设置`display`属性

```js
// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.ts
export const vShow: ObjectDirective<VShowElement> = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === 'none' ? '' : el.style.display
    if (transition && value) {
      transition.beforeEnter(el)
    } else {
      setDisplay(el, value)
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el)
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    // ...
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value)
  }
}
```

**v-if原理**

`v-if`在实现上比`v-show`要复杂的多，因为还有`else` `else-if` 等条件需要处理，这里我们也只摘抄源码中处理 `v-if` 的一小部分

返回一个`node`节点，`render`函数通过表达式的值来决定是否生成`DOM`

```js
// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.ts
export const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      // ...
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          ) as IfConditionalExpression
        } else {
          // attach this branch's codegen node to the v-if root.
          const parentCondition = getParentCondition(ifNode.codegenNode!)
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          )
        }
      }
    })
  }
)
```



### 6.v-if和v-for的优先级是什么？

==用法==

`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 `true`值的时候被渲染

`v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组或者对象，而 `item` 则是被迭代的数组元素的别名

在 `v-for` 的时候，建议设置`key`值，并且保证每个`key`值是独一无二的，这便于`diff`算法进行优化

==优先级==

最终结论：`v-for`优先级比`v-if`高

**详情可以去看(网址)[https://vue3js.cn/interview/vue/if_for.html#%E4%BA%8C%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7]**

### 7.SPA首屏加载速度慢怎么解决

==什么是首屏加载==

首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

首屏加载可以说是用户体验中**最重要**的环节。

==加载缓慢的原因==

在页面渲染的过程，导致加载速度慢的因素可能如下：

- 网络延时问题
- 资源文件体积是否过大
- 资源是否重复发送请求去加载了
- 加载脚本的时候，渲染内容堵塞了

==解决方案==

常见的几种SPA首屏优化方式

- 减小入口文件积
- 静态资源本地缓存
- UI框架按需加载
- 图片资源的压缩
- 组件重复打包
- 开启GZip压缩
- 使用SSR

**减入口文件体积**

常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加

在`vue-router`配置路由的时候，采用动态加载路由的形式

```
routes:[ 
    path: 'Blogs',
    name: 'ShowBlogs',
    component: () => import('./components/ShowBlogs.vue')
]
```

以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件

**静态资源本地缓存**

后端返回资源问题：

- 采用`HTTP`缓存，设置`Cache-Control`，`Last-Modified`，`Etag`等响应头
- 采用`Service Worker`离线缓存

前端合理利用`localStorage`

**UI框架按需加载**

在日常使用`UI`框架，例如`element-UI`、或者`antd`，我们经常性直接引用整个`UI`库

```js
import ElementUI from 'element-ui'
Vue.use(ElementUI)
```

但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用

```js
import { Button, Input, Pagination, Table, TableColumn, MessageBox } from 'element-ui';
Vue.use(Button)
Vue.use(Input)
Vue.use(Pagination)
```

**组件重复打包**

假设`A.js`文件是一个常用的库，现在有多个路由使用了`A.js`文件，这就造成了重复下载

解决方案：在`webpack`的`config`文件中，修改`CommonsChunkPlugin`的配置

```js
minChunks: 3
```

`minChunks`为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件

**图片资源压缩**

图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素

对于所有的图片资源，我们可以进行适当的压缩

对页面上使用到的`icon`，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻`http`请求压力。

**开启Gzip压缩**

拆完包之后，我们再用`gzip`做一下压缩 安装`compression-webpack-plugin`

```js
cnmp i compression-webpack-plugin -D
```

在`vue.congig.js`中引入并修改`webpack`配置

```js
const CompressionPlugin = require('compression-webpack-plugin')

configureWebpack: (config) => {
        if (process.env.NODE_ENV === 'production') {
            // 为生产环境修改配置...
            config.mode = 'production'
            return {
                plugins: [new CompressionPlugin({
                    test: /\.js$|\.html$|\.css/, //匹配文件名
                    threshold: 10240, //对超过10k的数据进行压缩
                    deleteOriginalAssets: false //是否删除原文件
                })]
            }
        }
```

在服务器我们也要做相应的配置 如果发送请求的浏览器支持`gzip`，就发送给它`gzip`格式的文件 我的服务器是用`express`框架搭建的 只要安装一下`compression`就能使用

```text
const compression = require('compression')
app.use(compression())  // 在其他中间件使用之前调用
```

**使用SSR**

SSR（Server side render ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器

从头搭建一个服务端渲染是很复杂的，`vue`应用建议使用`Nuxt.js`实现服务端渲染

### 8.为什么data属性是一个函数而不是一个对象？

- 根实例对象`data`可以是对象也可以是函数（根实例是单例），不会产生数据污染情况
- 组件实例对象`data`必须为函数，目的是为了防止多个组件实例对象之间共用一个`data`，产生数据污染。采用函数的形式，`initData`时会将其作为工厂函数都会返回全新`data`对象

**[详细原理分析](https://vue3js.cn/interview/vue/data.html#%E4%B8%89%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90)**

### 9.动态给vue的data添加一个新的属性的时候会发生什么？怎么解决

==一、直接添加属性的问题==

我们从一个例子开始

定义一个`p`标签，通过`v-for`指令进行遍历

然后给`botton`标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行

```html
<p v-for="(value,key) in item" :key="key">
    {{ value }}
</p>
<button @click="addProperty">动态添加新属性</button>
```

实例化一个`vue`实例，定义`data`属性和`methods`方法

```js
const app = new Vue({
    el:"#app",
   	data:()=>{
       	item:{
            oldProperty:"旧属性"
        }
    },
    methods:{
        addProperty(){
            this.items.newProperty = "新属性"  // 为items添加新属性
            console.log(this.items)  // 输出带有newProperty的items
        }
    }
})
```

点击按钮，发现结果不及预期，数据虽然更新了（`console`打印出了新属性），但页面并没有更新

==二、原理分析==

为什么产生上面的情况呢？

下面来分析一下

`vue2`是用过`Object.defineProperty`实现数据响应式

```js
const obj = {}
Object.defineProperty(obj, 'foo', {
        get() {
            console.log(`get foo:${val}`);
            return val
        },
        set(newVal) {
            if (newVal !== val) {
                console.log(`set foo:${newVal}`);
                val = newVal
            }
        }
    })
}
```

当我们访问`foo`属性或者设置`foo`值的时候都能够触发`setter`与`getter`

```js
obj.foo   
obj.foo = 'new'
```

但是我们为`obj`添加新属性的时候，却无法触发事件属性的拦截

```js
obj.bar  = '新属性'
```

原因是一开始`obj`的`foo`属性被设成了响应式数据，而`bar`是后面新增的属性，并没有通过`Object.defineProperty`设置成响应式数据

==三、解决方案==

`Vue` 不允许在已经创建的实例上动态添加新的响应式属性

若想实现数据与视图同步更新，可采取下面三种解决方案：

- Vue.set()
- Object.assign()
- $forcecUpdated()

==Vue.set()==

Vue.set( target, propertyName/index, value )

```
new Vue({
  el: '#app',
  data: {
    user: {
      name: '张三'
    }
  },
  methods: {
    addAge() {
      // 使用 Vue.set 动态添加新属性
      this.$set(this.user, 'age', 25);
    }
  }
});
```



参数

- `{Object | Array} target`
- `{string | number} propertyName/index`
- `{any} value`

返回值：设置的值

通过`Vue.set`向响应式对象中添加一个`property`，并确保这个新 `property`同样是响应式的，且触发视图更新

关于`Vue.set`源码（省略了很多与本节不相关的代码）

源码位置：`src\core\observer\index.js`

```js
function set (target: Array<any> | Object, key: any, val: any): any {
  ...
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
```

这里无非再次调用`defineReactive`方法，实现新增属性的响应式

关于`defineReactive`方法，内部还是通过`Object.defineProperty`实现属性拦截

大致代码如下：

```js
function defineReactive(obj, key, val) {
    Object.defineProperty(obj, key, {
        get() {
            console.log(`get ${key}:${val}`);
            return val
        },
        set(newVal) {
            if (newVal !== val) {
                console.log(`set ${key}:${newVal}`);
                val = newVal
            }
        }
    })
}
```

==Object.assign()==

直接使用`Object.assign()`添加到对象的新属性不会触发更新

应创建一个新的对象，合并原对象和混入对象的属性

```js
this.someObject = Object.assign({},this.someObject,{newProperty1:1,newProperty2:2 ...})
```

```
new Vue({
  el: '#app',
  data: {
    user: {
      name: '张三',
      age: 20
    }
  },
  methods: {
    updateUser() {
      // 使用 Object.assign 更新 user 对象
      //{} 是一个空对象，用作 Object.assign 的目标对象。这一步是为了确保我们不会直接修改原始的 this.user 对象，而是创建一个新的对象。
      this.user = Object.assign({}, this.user, {
        name: '李四',
        age: 25
      });
      //添加属性
     this.user = Object.assign({}, this.user, {
        email: 'zhangsan@example.com'
      });
    }
  }
});
```

==$forceUpdate==

如果你发现你自己需要在 `Vue`中做一次强制更新，99.9% 的情况，是你在某个地方做错了事

`$forceUpdate`迫使`Vue` 实例重新渲染

PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。

==小结==

- 如果为对象添加少量的新属性，可以直接采用`Vue.set()`
- 如果需要为新对象添加大量的新属性，则通过`Object.assign()`创建新对象
- 如果你实在不知道怎么操作时，可采取`$forceUpdate()`进行强制刷新 (不建议)

PS：`vue3`是用过`proxy`实现数据响应式的，直接动态添加新属性仍可以实现数据响应式

### 10.vue中组件和插件有什么区别

==一、组件是什么==

回顾以前对组件的定义：

组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在`Vue`中每一个`.vue`文件都可以视为一个组件

组件的优势

- 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现
- 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单
- 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级

==二、插件是什么==

插件通常用来为 `Vue` 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：

- 添加全局方法或者属性。如: `vue-custom-element`
- 添加全局资源：指令/过滤器/过渡等。如 `vue-touch`
- 通过全局混入来添加一些组件选项。如`vue-router`
- 添加 `Vue` 实例方法，通过把它们添加到 `Vue.prototype` 上实现。
- 一个库，提供自己的 `API`，同时提供上面提到的一个或多个功能。如`vue-router`

==三、两者的区别==

两者的区别主要表现在以下几个方面：

- 编写形式
- 注册形式
- 使用场景

**编写形式**

- 编写组件

编写一个组件，可以有很多方式，我们最常见的就是`vue`单文件的这种格式，每一个`.vue`文件我们都可以看成是一个组件

`vue`文件标准格式

```vue
<template>
</template>
<script>
export default{ 
    ...
}
</script>
<style>
</style>
```

我们还可以通过`template`属性来编写一个组件，如果组件内容多，我们可以在外部定义`template`组件内容，如果组件内容并不多，我们可直接写在`template`属性上

```js
<template id="testComponent">     // 组件显示的内容
    <div>component!</div>   
</template>

Vue.component('componentA',{ 
    template: '#testComponent'  
    template: `<div>component</div>`  // 组件内容少可以通过这种形式
})
```

- 编写插件

`vue`插件的实现应该暴露一个 `install` 方法。这个方法的第一个参数是 `Vue` 构造器，第二个参数是一个可选的选项对象

```js
js文件中：
MyPlugin.install = function (Vue, options) {
  // 1. 添加全局方法
  //这里定义了一个全局方法 myGlobalMethod，可以通过 Vue.myGlobalMethod() 调用。
  //全局方法可以在任何地方使用，但通常用于工具函数或通用逻辑
  Vue.myGlobalMethod = function () {
    console.log('这是一个全局方法');
  };

  // 2. 添加全局指令
  //这里定义了一个全局指令 my-directive，可以通过 v-my-directive 使用。
  //指令的 bind 钩子在指令绑定到元素时调用，可以用来操作 DOM。
  Vue.directive('my-directive', {
    bind (el, binding, vnode) {
      console.log('指令绑定到元素上');
      el.style.color = 'red'; // 示例：将元素文字颜色变为红色
    }
  });

  // 3. 注入组件选项
  //这里使用 Vue.mixin 注入了一个全局的 created 钩子。
  //这个钩子会在每个组件的 created 钩子之前执行，可以用来添加全局的逻辑。
  Vue.mixin({
    created: function () {
      console.log('每个组件创建时都会执行这里');
    }
  });

  // 4. 添加实例方法
  //这里定义了一个实例方法 $myMethod，可以通过 this.$myMethod() 在任何组件中调用。
  //实例方法通常用于组件内部的逻辑，可以接收参数。
  Vue.prototype.$myMethod = function (methodOptions) {
    console.log('这是一个实例方法', methodOptions);
  };
};
```

```
<template>
    <div id="app">
      <p v-my-directive>{{ message }}</p>
    </div>
</template>
<script>
    import Vue from 'vue';
    import MyPlugin from './MyPlugin';

    // 使用插件
    Vue.use(MyPlugin);

    new Vue({
      el: '#app',
      data: {
        message: 'Hello Vue!'
      },
      mounted() {
        // 调用全局方法
        Vue.myGlobalMethod();

        // 调用实例方法
        this.$myMethod({ name: 'Kimi' });
      }
    });
</script>
```

输出：

这是一个全局方法
这是一个实例方法 { name: 'Kimi' }
每个组件创建时都会执行这里

页面显示：

Hello Vue!

文字颜色为红色（因为 `v-my-directive` 指令将文字颜色变为红色）。



**注册形式**

- 组件注册

`vue`组件注册主要分为全局注册与局部注册

全局注册通过`Vue.component`方法，第一个参数为组件的名称，第二个参数为传入的配置项

```js
Vue.component('my-component-name', { /* ... */ })
```

局部注册只需在用到的地方通过`components`属性注册一个组件

```js
const component1 = {...} // 定义一个组件

export default {
	components:{
		component1   // 局部注册
	}
}
```

- 插件注册

插件的注册通过`Vue.use()`的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项

```js
Vue.use(插件名字,{ /* ... */} )
```

注意的是：

注册插件的时候，需要在调用 `new Vue()` 启动应用之前完成

`Vue.use`会自动阻止多次注册相同插件，只会注册一次

==使用场景==

具体的其实在插件是什么章节已经表述了，这里在总结一下

组件 `(Component)` 是用来构成你的 `App` 的业务模块，它的目标是 `App.vue`

插件 `(Plugin)` 是用来增强你的技术栈的功能模块，它的目标是 `Vue` 本身

简单来说，插件就是指对`Vue`的功能的增强或补充

### 11.组件间的通信方式有哪些

整理`vue`中8种常规的通信方案

1. 通过 props 传递
2. 通过 $emit 触发自定义事件
3. 使用 ref
4. EventBus
5. $parent 或$root

通过共同祖辈`$parent`或者`$root`搭建通信桥连

兄弟组件

```
this.$parent.on('add',this.add)
```

另一个兄弟组件

```
this.$parent.emit('add')
```

attrs 与 listeners

Provide 与 Inject

Vuex/pinia

### 12.说说你对数据双向绑定的理解

好的，我来进一步简化和详细解释这段代码，特别是其中的关键部分，帮助你更好地理解 Vue 的双向绑定机制。

1. ==双向绑定的核心概念==

**双向绑定** 是指数据（Model）和视图（View）之间的自动同步。具体来说：

- **单向绑定**：数据变化时，视图自动更新。
- **双向绑定**：数据变化时，视图自动更新；视图变化时，数据也自动更新。

2. Vue ==的双向绑定实现==

Vue 的双向绑定主要通过以下三个部分实现：

1. **数据层（Model）**：存储数据和业务逻辑。
2. **视图层（View）**：展示数据和用户界面。
3. **业务逻辑层（ViewModel）**：连接数据层和视图层，实现数据和视图的同步。

4. ==实现双向绑定的关键步骤==

3.1 数据响应化处理

Vue 使用 `Object.defineProperty` 来实现数据的响应化处理。这意味着当数据发生变化时，Vue 能够自动检测到这些变化并触发视图更新。

```javascript
function defineReactive(obj, key, val) {
  const dep = new Dep(); // 创建一个依赖收集器
  Object.defineProperty(obj, key, {
    get() {
      if (Dep.target) {
        dep.addDep(Dep.target); // 收集依赖
      }
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        val = newVal;
        dep.notify(); // 通知依赖更新
      }
    }
  });
}
```

3.2 依赖收集

依赖收集是双向绑定的关键部分。当视图读取数据时，Vue 会自动将视图的更新函数（Watcher）添加到依赖列表中。

```javascript
class Dep {
  constructor() {
    this.deps = []; // 依赖列表
  }

  addDep(dep) {
    this.deps.push(dep); // 添加依赖
  }

  notify() {
    this.deps.forEach(dep => dep.update()); // 通知所有依赖更新
  }
}
```

3.3 视图更新

当数据发生变化时，依赖收集器会通知所有依赖的更新函数（Watcher），从而触发视图更新。

```javascript
class Watcher {
  constructor(vm, key, updater) {
    this.vm = vm;
    this.key = key;
    this.updater = updater;

    Dep.target = this; // 设置当前 Watcher
    this.vm[this.key]; // 触发 getter，收集依赖
    Dep.target = null; // 清除当前 Watcher
  }

  update() {
    this.updater.call(this.vm, this.vm[this.key]); // 更新视图
  }
}
```

4. ==实现一个简单的双向绑定==

为了更好地理解这些概念，我们来实现一个简单的双向绑定。



```html
<div id="app">
  <input v-model="message" />
  <p>{{ message }}</p>
</div>
```



```javascript
class Dep {
  constructor() {
    this.deps = [];
  }

  addDep(dep) {
    this.deps.push(dep);
  }

  notify() {
    this.deps.forEach(dep => dep.update());
  }
}

class Watcher {
  constructor(vm, key, updater) {
    this.vm = vm;
    this.key = key;
    this.updater = updater;

    Dep.target = this;
    this.vm[this.key];
    Dep.target = null;
  }

  update() {
    this.updater.call(this.vm, this.vm[this.key]);
  }
}

function defineReactive(obj, key, val) {
  const dep = new Dep();
  Object.defineProperty(obj, key, {
    get() {
      if (Dep.target) {
        dep.addDep(Dep.target);
      }
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        val = newVal;
        dep.notify();
      }
    }
  });
}

class Vue {
  constructor(options) {
    this.$options = options;
    this.$data = options.data;

    // 响应化处理
    Object.keys(this.$data).forEach(key => {
      defineReactive(this.$data, key, this.$data[key]);
    });

    // 代理 data 到 vm
    Object.keys(this.$data).forEach(key => {
      Object.defineProperty(this, key, {
        get() {
          return this.$data[key];
        },
        set(newVal) {
          this.$data[key] = newVal;
        }
      });
    });

    // 编译模板
    new Compile(options.el, this);
  }
}

class Compile {
  constructor(el, vm) {
    this.$vm = vm;
    this.$el = document.querySelector(el);
    this.compile(this.$el);
  }

  compile(el) {
    const childNodes = el.childNodes;
    Array.from(childNodes).forEach(node => {
      if (this.isElement(node)) {
        this.compileElement(node);
      } else if (this.isInterpolation(node)) {
        this.compileText(node);
      }
      if (node.childNodes && node.childNodes.length > 0) {
        this.compile(node);
      }
    });
  }

  compileElement(node) {
    const attrs = node.attributes;
    Array.from(attrs).forEach(attr => {
      const { name, value } = attr;
      if (name === 'v-model') {
        const key = value;
        new Watcher(this.$vm, key, (newVal) => {
          node.value = newVal;
        });
        node.addEventListener('input', (e) => {
          this.$vm[key] = e.target.value;
        });
      }
    });
  }

  compileText(node) {
    const reg = /\{\{(.*)\}\}/;
    const match = node.textContent.match(reg);
    if (match) {
      const key = match[1].trim();
      new Watcher(this.$vm, key, (newVal) => {
        node.textContent = newVal;
      });
    }
  }

  isElement(node) {
    return node.nodeType === 1;
  }

  isInterpolation(node) {
    return node.nodeType === 3 && /\{\{(.*)\}\}/.test(node.textContent);
  }
}

// 使用
new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
});
```

代码解释

1. **`Dep` 类**：
   - 管理依赖（`Watcher`）。
   - 提供 `addDep` 方法添加依赖，`notify` 方法通知依赖更新。

2. **`Watcher` 类**：
   - 用于更新视图。
   - 在构造函数中，将当前 `Watcher` 添加到依赖列表中。
   - 提供 `update` 方法，用于更新视图。

3. **`defineReactive` 函数**：
   - 使用 `Object.defineProperty` 为数据属性添加 `getter` 和 `setter`。
   - 在 `getter` 中收集依赖，在 `setter` 中通知依赖更新。

4. **`Vue` 构造函数**：
   - 初始化选项 `options`。
   - 对 `data` 执行响应化处理。
   - 代理 `data` 到 `vm` 上。
   - 执行编译。

5. **`Compile` 类**：
   - 遍历 DOM 节点，解析指令和插值文本。
   - 对每个节点进行递归编译。
   - 处理 `v-model` 指令，实现双向绑定。

### 13.$nexttick原理及作用

`$nextTick` 是 Vue 提供的一个方法，用于在 DOM 更新完成后执行某个操作

==工作远离==

Vue 在数据更新后，将 DOM 更新放入队列中，在下一个“tick”中处理队列，`$nextTick` 的回调函数会在 DOM 更新完成后被调用。

==为什么要是用它？==

在 Vue 中，数据更新后，DOM 的更新是异步的。这意味着如果你在数据更新后立即操作 DOM，可能会因为 DOM 还未更新而得不到预期的结果。`$nextTick` 提供了一个在 DOM 更新完成后执行操作的方法。

==vue的异步更新机制==

Vue 的异步更新机制确保了在同一个事件循环中，对数据的多次修改只会触发一次 DOM 更新。具体步骤如下：

1.**数据变化队列**：

- 当你修改数据时，Vue 将这些修改放入一个队列中。
- 这个队列被称为 **“异步更新队列”**。

2.**去重机制**：

- Vue 的异步更新队列会自动去重。如果同一个数据属性在同一个事件循环中被多次修改，Vue 只会保留最后一次修改。
- 这意味着，即使你在 `for` 循环中多次修改同一个属性，Vue 只会保留最后一次修改的内容。

3.**批量更新**：

- 在当前事件循环结束后，Vue 会从队列中取出所有待处理的修改，**并一次性更新 DOM**。
- 这个过程称为 **“批量更新**

```
<template>
  <div>
    <p v-for="item in items" :key="item.id">{{ item.text }}</p>
    <button @click="updateItems">更新列表</button>
  </div>
</template>
//vue的异步更新机制保证同一个数据的多次改变只引起一次dom的更新，从而有性能优化的作用。
<script>
export default {
  data() {
    return {
      items: [
        { id: 1, text: 'Item 1' },
        { id: 2, text: 'Item 2' },
        { id: 3, text: 'Item 3' }
      ]
    };
  },
  methods: {
    updateItems() {
      for (let i = 0; i < 1000; i++) {
        this.items[i % 3].text = `Item ${i + 1}`;
      }
      this.$nextTick(() => {
        console.log('DOM 已更新');
        // 在这里可以安全地操作 DOM
      });
    }
  }
};
</script>
```

### 14.什么是mixin

在 Vue.js 中，**mixin（混入）** 是一种非常灵活的方式，用于在组件之间共享逻辑。Mixin 允许你定义一些可复用的功能，然

后在多个组件中混入这些功能，而不需要重复编写相同的代码。Mixin 在 Vue.js 中的作用类似于其他编程语言中的“类”或“模

块”，用于共享属性和方法。Mixin 提供了一种灵活的方式，让你可以在多个组件之间复用代码，而不需要重复编写相同的逻

辑，不同之处在于其没有继承机制。vue3中虽然有mixin，但是官方推荐通过composition api来来提高代码的复用性和可维护性。

==1. 什么是 Mixin==

Mixin 是一个包含 Vue 组件选项的对象。当你将一个 mixin 混入到组件中时，mixin 中的选项会被“混入”到组件的选项中。如果 mixin 和组件有相同的选项，Vue 会按照一定的规则进行合并。

==2. Mixin 的使用场景==

- **共享方法和计算属性**：在多个组件中复用逻辑。
- **共享生命周期钩子**：在多个组件中执行相同的初始化或销毁逻辑。
- **共享数据**：在多个组件中共享数据。

==3. 定义和使用 Mixin==

定义 Mixin

你可以定义一个 mixin 对象，包含 Vue 组件支持的所有选项：

```javascript
const myMixin = {
  data() {
    return {
      mixinData: 'Mixin Data'
    };
  },
  methods: {
    mixinMethod() {
      console.log('Mixin Method');
    }
  },
  created() {
    console.log('Mixin Created');
  }
};
```

使用 Mixin

在组件中使用 mixin 时，可以通过 `mixins` 选项将 mixin 混入到组件中：

```javascript
import Vue from 'vue';
import myMixin from './myMixin';

export default {
  mixins: [myMixin],
  data() {
    return {
      componentData: 'Component Data'
    };
  },
  methods: {
    componentMethod() {
      console.log('Component Method');
    }
  },
  created() {
    console.log('Component Created');
    this.mixinMethod(); // 调用 mixin 中的方法
  }
};
```

==4. Mixin 的合并策略==

当 mixin 和组件有相同的选项时，Vue 会按照以下规则进行合并：

- **数据（data）**：如果 mixin 和组件都有 `data` 选项，它们会被合并为一个对象。
- **方法（methods）**：如果 mixin 和组件有相同的方法名，组件中的方法会覆盖 mixin 中的方法。
- **生命周期钩子**：如果 mixin 和组件有相同的生命周期钩子，它们会被调用多次，按照 mixin 的顺序依次调用。
- **计算属性（computed）**：如果 mixin 和组件有相同的计算属性，组件中的计算属性会覆盖 mixin 中的计算属性。
- **其他选项**：其他选项（如 `props`、`watch` 等）也会按照类似的规则进行合并。

==5. 全局 Mixin==

你还可以定义全局 mixin，这样所有组件都会自动混入这个 mixin：

```javascript
import Vue from 'vue';

Vue.mixin({
  created() {
    console.log('Global Mixin Created');
  }
});
```

==6. 注意事项==

- **命名冲突**：如果 mixin 和组件有相同的选项，可能会导致命名冲突。尽量避免在 mixin 和组件中使用相同的选项名。
- **复杂性**：过度使用 mixin 可能会使代码难以维护，特别是当多个 mixin 之间存在复杂的依赖关系时。尽量保持 mixin 的简单和清晰。

==7.示例代码==

定义 Mixin

```javascript
// myMixin.js
export default {
  data() {
    return {
      mixinData: 'Mixin Data'
    };
  },
  methods: {
    mixinMethod() {
      console.log('Mixin Method');
    }
  },
  created() {
    console.log('Mixin Created');
  }
};
```

使用 Mixin

```javascript
// MyComponent.vue
<template>
  <div>
    <p>{{ mixinData }}</p>
    <p>{{ componentData }}</p>
    <button @click="mixinMethod">调用 Mixin 方法</button>
    <button @click="componentMethod">调用组件方法</button>
  </div>
</template>

<script>
import myMixin from './myMixin';

export default {
  mixins: [myMixin],
  data() {
    return {
      componentData: 'Component Data'
    };
  },
  methods: {
    componentMethod() {
      console.log('Component Method');
    }
  },
  created() {
    console.log('Component Created');
    this.mixinMethod(); // 调用 mixin 中的方法
  }
};
</script>
```

==8. 输出结果==

- 当组件创建时，会依次调用 mixin 和组件的 `created` 钩子：

  ```
  Mixin Created
  Component Created
  ```

- 点击按钮时，会调用 mixin 和组件中的方法：

  ```
  Mixin Method
  Component Method
  ```

==为什么要有mixin，直接导出函数或属性不可以吗？==

因为mixin导出的不只是属性或函数，而是带有状态的逻辑。

✅ `mixin` 是一种**将一组 data、method、生命周期函数等“混合”到组件中**的机制。不能使用“导出函数export”代替

mixin，因为vue2的相应机制限制了这种可能，- 你无法在一个普通函数中创建一个“能被 Vue 自动追踪”的响应式变量。 - 你无

法从外部函数注册 `created` 或 `mounted` 钩子。所以，**普通函数无法替代 mixin 的“状态 + 生命周期”复用能力**。在

vue3中。普通的export只适用于工具函数（如格式化，计算，日期），配置常量，与vue组件状态无关的逻辑，无法复用“响应式

数据”或“组件生命周期”

==在vue3中是如何实现这种“带状态的逻辑”复用==

1.通过ref和reactive创建响应式状态

```js
// composables/useCounter.js
import { ref } from 'vue';

export function useCounter(initialValue = 0) {
  const count = ref(initialValue); // ✅ 响应式状态
  const double = computed(() => count.value * 2);

  function increment() {
    count.value++;
  }

  return { count, double, increment }; // 暴露给组件使用
}
//这里的 count 是一个响应式引用（ref），它的变化会被 Vue 自动追踪，视图会随之更新。
```

2.在函数中使用生命周期和副作用

```js
import { onMounted, watch } from 'vue';

export function useCounter() {
  const count = ref(0);

  // ✅ 注册生命周期钩子
  onMounted(() => {
    console.log('计数器功能已加载');
  });

  // ✅ 监听状态变化
  watch(() => count.value, (newVal) => {
    console.log('计数变为：', newVal);
  });

  function increment() {
    count.value++;
  }

  return { count, increment };
}
//👉 这些 onMounted、watch 只有在组件的 setup() 上下文中才能正常工作，Composition API 确保了这一点。
```

3.在组件中导入并使用

```javascript
<script setup>
import { useCounter } from './useCounter';

const { count, increment } = useCounter();
</script>

<template>
  <div>当前计数：{{ count }}</div>
  <button @click="increment">+1</button>
</template>
```

**疑问？这不就是组件引用吗，vue2也能做到，在vue3中生命周期函数也不能够在js文件中生效。**

你说到点子上了：**“纯 JS 文件中不能使用 `onMounted` 等生命周期函数” —— 这完全正确！**

但这并不意味着这些函数“无效”，关键在于：

> 🔑 **这些组合函数（composable）虽然写在 `.js` 或 `.ts` 文件中，但它们只能在 `setup()` 或 `<script setup>` 的组件上下文中被调用时，才能正常工作。**

**疑问？那为什么在vue2中的生命周期函数就不能写入到js文件中，然后后面再import呢？为什么vue3中就可以在js中写一些生命周期函数，执行一些操作，在引入呢？**

首先，这种“带状态的逻辑”vue3通过ref和reactive实现了响应式，vue2中没有，这是可以理解的。其次，vue2中的生命周期

是“声明式配置”，必须在组件定义时写好，这些钩子是 **“静态声明”** 的；Vue 在创建组件实例时，会去读取这些特定名字的选

项；你不能在运行时“动态注册”一个 `mounted` 钩子；所以如果你想复用逻辑，就必须用 `mixin` 或 HOC 来“合并配置”。

而vue3中，则是提供了“命令式的钩子”，可以在setup中动态注册这些钩子，在vue创建时，内部有固定的生命周期操作执行，

同时外部也可以通过引入 钩子API 来添加一些操作”

总结：

✅ 在 Vue 2 中，生命周期钩子是组件配置的一部分，必须在定义组件时**静态声明**，Vue 在初始化时读取并执行。

✅ 在 Vue 3 中，Vue 仍然有固定的生命周期流程，但它提供了一组 **“副作用注册 API”**（如 `onMounted`、`onUpdated`），允许你在 `setup()` 中**动态注册**额外的操作。

这些 API 并不是“替代”了内部生命周期，而是**扩展了它** —— 就像给一辆车预留了“插槽”，你可以随时插入自己的模块。

### 15.slot是什么

==slot是什么==

`Slot` 艺名插槽，花名“占坑”，我们可以理解为`solt`在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中`slot`位置）。

==使用场景==

通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理

如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情

通过`slot`插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用

比如布局组件、表格列、下拉选、弹框显示内容等

==分类==

`slot`可以分来以下三种：

- 默认插槽
- 具名插槽
- 作用域插槽

**默认插槽**

子组件用`<slot>`标签来确定渲染的位置，标签里面可以放`DOM`结构，当父组件使用的时候没有往插槽传入内容，标签内`DOM`结构就会显示在页面

父组件在使用的时候，直接在子组件的标签内写入内容即可

子组件`Child.vue`

```html
<template>
    <slot>
      <p>插槽后备的内容</p>
    </slot>
</template>
```

父组件

```html
<Child>
  <div>默认插槽</div>  
</Child>
```

**具名插槽**

子组件用`name`属性来表示插槽的名字，不传为默认插槽

父组件中在使用时在默认插槽的基础上加上`slot`属性，值为子组件插槽`name`属性值

子组件`Child.vue`

```html
<template>
    <slot>插槽后备的内容</slot>
  <slot name="content">插槽后备的内容</slot>
</template>
```

父组件

```html
<child>
    <template v-slot:default>具名插槽</template>
    <!-- 具名插槽⽤插槽名做参数 -->
    <template v-slot:content>内容...</template>
</child>
```

**作用域插槽**

子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件`v-slot`接受的对象上

父组件中在使用时通过`v-slot:`（简写：#）获取子组件的信息，在内容中使用

子组件`Child.vue`

```html
<template> 
  <slot name="footer" testProps="子组件的值">
          <h3>没传footer插槽</h3>
    </slot>
</template>
```

父组件

```html
<child> 
    <!-- 把v-slot的值指定为作⽤域上下⽂对象 -->
    <template v-slot:default="slotProps">
      来⾃⼦组件数据：{{slotProps.testProps}}
    </template>
    <template #default="slotProps">
      来⾃⼦组件数据：{{slotProps.testProps}}
    </template>
</child>
```

小结：

- `v-slot`属性只能在`<template>`上使用，但在只有默认插槽时可以在组件标签上使用
- 默认插槽名为`default`，可以省略default直接写`v-slot`
- 缩写为`#`时不能不写参数，写成`#default`
- 可以通过解构获取`v-slot={user}`，还可以重命名`v-slot="{user: newName}"`和定义默认值`v-slot="{user = '默认值'}"`

### 16.讲一下Vue.obserbable

`Vue.observable` 是 Vue 2.6+ 提供的一个方法，它**可以直接将一个普通对象变成响应式对象**，而不需要定义在组件的 `data` 中。

```
import Vue from 'vue';

const state = Vue.observable({
  count: 0,
  name: 'Alice'
});
```

👉 `state` 现在是一个**响应式对象**，你可以在任何地方修改它，所有依赖它的 Vue 组件都会自动更新。

==为什么需要他？==

在 Vue 2 中，**只有在组件的 `data` 中定义的数据才是响应式的**。这导致一个问题：

> ❌ 你无法在组件外部创建一个“可被 Vue 追踪”的响应式对象。

比如你想实现一个全局状态管理（类似 Vuex），但又不想用 Vuex，该怎么办？

`Vue.observable` 就是为此设计的

==使用示例：创建一个简单的全局状态管理==

==创建一个响应式状态模块==

```
// store.js
import Vue from 'vue';

export const store = Vue.observable({
  count: 0,
  message: 'Hello'
});

export const mutations = {
  increment() {
    store.count++;
  },
  setMessage(msg) {
    store.message = msg;
  }
};
```

 **==在组件中使用（自动响应式更新）==**

```
<template>
  <div>
    <p>Count: {{ count }}</p>
    <p>Message: {{ message }}</p>
    <button @click="increment">+1</button>
    <button @click="setMessage('Hi')">Set Message</button>
  </div>
</template>

<script>
import { store, mutations } from '@/store';

export default {
  computed: {
    count() {
      return store.count; // ✅ 依赖响应式对象
    },
    message() {
      return store.message;
    }
  },
  methods: {
    increment() {
      mutations.increment();
    },
    setMessage(msg) {
      mutations.setMessage(msg);
    }
  }
}
</script>
```

✅ 当 `store.count` 被修改时，组件会自动重新渲染！

==本质==

其实就是：

> **一个轻量级的、手动创建的响应式对象**，相当于 `data()` 函数返回的对象。

```
// 这两个是等价的
const a = Vue.observable({ count: 0 });

const b = new Vue({
  data() {
    return { count: 0 }
  }
}).$data;
```

它们都被 Vue 的响应式系统（`Object.defineProperty`）处理过。

==缺点==

- 在 Vue 3 中，`Vue.observable` 被 **废弃**，推荐使用 `reactive()` 或 `ref()`。
- 因为 Vue 3 的响应式系统基于 `Proxy`，`reactive()` 更强大。
- 只能用于vue2.6+，不支持早期版本
- 不如vuex、pinia规范

👉 所以你可以把 `Vue.observable` 看作是 **Vue 3 `reactive()` 的“前身”**。

### 17.Vue常用的修饰符有哪些，应用场景是什么

在`Vue`中，修饰符处理了许多`DOM`事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注

于程序的逻辑处理

`vue`中修饰符分为以下五种：

- 表单修饰符
- 事件修饰符
- 鼠标按键修饰符
- 键值修饰符
- v-bind修饰符

==修饰符的作用==

1.表单修饰符

在我们填写表单的时候用得最多的是`input`标签，指令用得最多的是`v-model`

关于表单的修饰符有如下：

- lazy
- trim
- number

**lazy**

在我们填完信息，光标离开标签的时候，才会将值赋予给`value`，也就是在`change`事件之后再进行信息同步

```js
<input type="text" v-model.lazy="value">
<p>{{value}}</p>
```

**trim**

自动过滤用户输入的首空格字符，而中间的空格不会过滤

```js
<input type="text" v-model.trim="value">
```

**number**

自动将用户的输入值转为数值类型，但如果这个值无法被`parseFloat`解析，则会返回原来的值

```js
<input v-model.number="age" type="number">
```

2.事件修饰符

事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：

- stop
- prevent
- self
- once
- capture
- passive
- native

**stop**

阻止了事件冒泡，相当于调用了`event.stopPropagation`方法

```js
<div @click="shout(2)">
  <button @click.stop="shout(1)">ok</button>
</div>
//只输出1
```

**prevent**

阻止了事件的默认行为，相当于调用了`event.preventDefault`方法

```js
<form v-on:submit.prevent="onSubmit"></form>
```

**self**

✅ **只有当事件是从该元素本身触发时，才触发回调函数**，而不是从它的子元素“冒泡”上来的

```
<template>
  <div @click.self="handleClick">
    <!-- 子元素 -->
    <button>点我</button>
  </div>
</template>
```

👉 只有当点击的是 `div` 本身（而不是里面的 `button`）时，`handleClick` 才会执行。

**once**

绑定了事件以后只能触发一次，第二次就不会触发

```js
<button @click.once="shout(1)">ok</button>
```

**capture**

在 DOM 中，一个事件的传播分为三个阶段：

1. **捕获阶段（Capture）**：事件从 `window` → `document` → 父元素 → ... → 目标元素（由外向内）
2. **目标阶段（Target）**：事件到达目标元素
3. **冒泡阶段（Bubble）**：事件从目标元素 → 父元素 → ... → `window`（由内向外）

⚠️ 默认情况下，Vue 和原生 DOM 事件都是在 **冒泡阶段** 触发。

==实际例子对比==



```
<div id="outer" @click="outerClick">
  外层 div
  <div id="inner" @click="innerClick">
    内层 div
    <button @click="btnClick">按钮</button>
  </div>
</div>
```

情况 1：无 `.capture`（默认冒泡）

```
outerClick() { console.log('outer clicked (bubble)'); }
innerClick() { console.log('inner clicked (bubble)'); }
btnClick()   { console.log('button clicked'); }
```

👉 点击按钮，输出顺序：

```
button clicked
inner clicked (bubble)
outer clicked (bubble)
```

情况 2：外层使用 `.capture`

```
<div id="outer" @click.capture="outerClick">
```

👉 输出顺序：

```
outer clicked (capture)  ← 捕获阶段先执行！
button clicked
inner clicked (bubble)
```

> 🔥 注意：`outerClick` 在事件到达目标前就执行了！

**passive**

在移动端，当我们在监听元素滚动事件的时候，会一直触发`onscroll`事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给`onscroll`事件整了一个`.lazy`修饰符

```js
<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

> 不要把 `.passive` 和 `.prevent` 一起使用,因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。
>
> `passive` 会告诉浏览器你不想阻止事件的默认行为

**native**

让组件变成像`html`内置标签那样监听根元素的原生事件，否则组件上使用 `v-on` 只会监听自定义事件

```js
<my-component v-on:click.native="doSomething"></my-component>
```

> 使用.native修饰符来操作普通HTML标签是会令事件失效的

在 vue2 中

```
<!-- MyButton.vue -->
<template>
  <button @click="handleClick">
    点我
  </button>
</template>

<script>
export default {
  methods: {
    handleClick() {
      // 1. 浏览器触发原生 click（自动）
      // 2. 我们手动触发一个自定义 click 事件
      this.$emit('click', 'Hello from button');
    }
  }
}
</script>
```

```vue
<!-- Parent.vue -->
<template>
  <div>
    <!-- 方式1：监听自定义 click -->
    <MyButton @click="onCustom" />

    <!-- 方式2：监听原生 click -->
    <MyButton @click.native="onNative" />
  </div>
</template>

<script>
export default {
  methods: {
    onCustom(msg) {
      console.log('自定义 click:', msg); // 输出: Hello from button
    },
    onNative() {
      console.log('原生 click 被触发');
    }
  }
}
</script>
```

在 Vue 3 中：

- 如果你**没有**在 `emits: ['click']` 中声明 `click`，那么 `@click` 默认监听原生事件；
- 如果你**有**声明 `emits: ['click']`，那么 `@click` 就是自定义事件；
- `.native` 被移除。



==鼠标按钮修饰符==

鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：

- left 左键点击
- right 右键点击
- middle 中键点击

```js
<button @click.left="shout(1)">ok</button>
<button @click.right="shout(1)">ok</button>
<button @click.middle="shout(1)">ok</button>
```

==键盘修饰符==

键盘修饰符是用来修饰键盘事件（`onkeyup`，`onkeydown`）的，有如下：

`keyCode`存在很多，但`vue`为我们提供了别名，分为以下两种：

- 普通键（enter、tab、delete、space、esc、up...）
- 系统修饰键（ctrl、alt、meta、shift...）

```js
// 只有按键为keyCode的时候才触发
<input type="text" @keyup.keyCode="shout()">
```

还可以通过以下方式自定义一些全局的键盘码别名

```js
Vue.config.keyCodes.f2 = 113
```

==v-bind修饰符==

v-bind修饰符主要是为属性进行操作，用来分别有如下：

- async
- prop
- camel

==async==

能对`props`进行一个双向绑定

```js
//父组件
<comp :myMessage.sync="bar"></comp> 
//子组件
this.$emit('update:myMessage',params);
```

以上这种方法相当于以下的简写

```js
//父亲组件
<comp :myMessage="bar" @update:myMessage="func"></comp>
func(e){
 this.bar = e;
}
//子组件js
func2(){
  this.$emit('update:myMessage',params);
}
```

使用`async`需要注意以下两点：

- 使用`sync`的时候，子组件传递的事件名格式必须为`update:value`，其中`value`必须与子组件中`props`中声明的名称完全一致
- 注意带有 `.sync` 修饰符的 `v-bind` 不能和表达式一起使用
- 将 `v-bind.sync` 用在一个字面量的对象上，例如 `v-bind.sync=”{ title: doc.title }”`，是无法正常工作的



### 18.你有写过自定义指令吗？应用场景有哪些？

我们看到的`v-`开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能

除了核心功能默认内置的指令 (`v-model` 和 `v-show`)，`Vue` 也允许注册自定义指令

==如何使用==

注册一个自定义指令有全局注册与局部注册

全局注册主要是通过`Vue.directive`方法进行注册

`Vue.directive`第一个参数是指令的名字（不需要写上`v-`前缀），第二个参数可以是对象数据，也可以是一个指令函数

==注册方式==

1.全局注册

```
import { createApp } from 'vue';
import App from './App.vue';

const app = createApp(App);

// 全局注册 v-focus 指令
app.directive('focus', {
  // 指令钩子函数
  mounted(el) {
    el.focus(); // 自动聚焦
  }
});

app.mount('#app');
```

2.局部注册的

```
<template>
  <input v-focus placeholder="自动聚焦" />
</template>

<script>
export default {
  directives: {
    focus: {
      mounted(el) {
        el.focus();
      }
    }
  }
}
</script>
```

在钩子函数中，第二个参数 `binding` 是一个对象，包含以下属性：

| 属性        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| `value`     | 指令的值，如 `v-mydir="1 + 1"` → `value: 2`                  |
| `arg`       | 动态参数，如 `v-mydir:arg="value"` → `arg: 'arg'`            |
| `modifiers` | 修饰符对象，如 `v-mydir.foo.bar` → `{ foo: true, bar: true }` |
| `instance`  | 绑定元素的组件实例                                           |
| `dir`       | 指令定义对象                                                 |

场景 1：`v-color="'red'"`

```
app.directive('color', (el, binding) => {
  el.style.color = binding.value; // binding.value = 'red'
});
```

- `el`: 被着色的元素
- `binding.value`: 颜色值

------

场景 2：`v-log:userId.enter.space="user"

```
app.directive('log', (el, binding) => {
  console.log('元素:', el);
  console.log('用户ID:', binding.arg);        // → userId
  console.log('修饰符:', binding.modifiers);   // → { enter: true, space: true }
  console.log('绑定的数据:', binding.value);   // → user 对象
});
```

------

场景 3：权限指令 `v-permission="'admin'"

```
app.directive('permission', {
  mounted(el, binding) {
    const userRole = localStorage.getItem('role');
    if (userRole !== binding.value) { // binding.value = 'admin'
      el.remove(); // 无权限则移除元素
    }
  }
});
```

==实战==

1.自动聚焦

```
app.directive('focus', {
  mounted(el) {
    el.focus();
  }
});



<input v-focus />
```

2.权限控制

```
app.directive('permission', {
  mounted(el, binding) {
    const userRole = localStorage.getItem('role');
    const requiredRole = binding.value;

    if (userRole !== requiredRole) {
      el.parentNode.removeChild(el); // 无权限则移除
    }
  }
});


<button v-permission="'admin'">删除用户</button>


```

3.防抖

```
app.directive('debounce', {
  mounted(el, binding) {
    let timeout;
    const delay = binding.arg || 300; // 支持 v-debounce:500
    const handler = binding.value;  //search函数

    el.addEventListener('input', () => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        handler();
      }, delay);
    });

    // 保存 handler 以便解绑
    el._debounceHandler = handler;
  },
  unmounted(el) {
    window.removeEventListener('input', el._debounceHandler);
  }
});


<input v-debounce:300="search" />
```

4.`v-click-outside` 点击外部关闭

```
app.directive('click-outside', {
  mounted(el, binding) {
    const onClick = (e) => {
      if (!el.contains(e.target)) {
        binding.value(e); // 执行传入的函数
      }
    };
    document.addEventListener('click', onClick);
    el._clickOutside = onClick;
  },
  unmounted(el) {
    document.removeEventListener('click', el._clickOutside);
  }
});

<div v-click-outside="closeModal"  class="modal">
  我是一个弹窗
</div>
```

### 19.Vue中的过滤器了解么，应用场景有哪些？

过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数

```
//局部过滤器
<template>
  <p>{{ price | formatPrice }}</p> <!-- 输出：$100.00 -->
</template>

<script>
export default {
  data() {
    return { price: 100 };
  },
  filters: {
    formatPrice(value) {
      return `$${value.toFixed(2)}`;
    }
  }
};
</script>
```

```
//全局过滤器，main.js中
import Vue from 'vue';

Vue.filter('formatPrice', (value) => {
  return `$${value.toFixed(2)}`;
});

new Vue({ ... }).$mount('#app');
```

**vue3中已经启用，可以使用计算属性，方法来代替**

==应用场景==

需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等

### 20.什么是虚拟dom，如何实现一个虚拟dom

==什么是dom==

DOM 是 **Document Object Model**（文档对象模型）的缩写，是一个编程接口，用于表示和操作 HTML 和 XML 文档。

DOM 将网页文档表示为一个树形结构，其中每个 HTML 元素都是一个"节点"（node）。通过 DOM，JavaScript 可以访问和修改网页的内容、结构和样式。



```html
<!DOCTYPE html>
<html>
  <head>
    <title>我的网页</title>
  </head>
  <body>
    <h1>标题</h1>
    <p>段落内容</p>
  </body>
</html>
```

在 DOM 中表示为：

```
Document
└── html
    ├── head
    │   └── title
    │       └── "我的网页"
    └── body
        ├── h1
        │   └── "标题"
        └── p
            └── "段落内容"
```

常用操作



```javascript
// 获取元素
document.getElementById('myId');
document.querySelector('.myClass');

// 修改内容
element.textContent = '新内容';
element.innerHTML = '<strong>粗体文本</strong>';

// 修改样式
element.style.color = 'red';

// 添加/删除元素
const newDiv = document.createElement('div');
document.body.appendChild(newDiv);
element.remove();

// 事件监听
element.addEventListener('click', function() {
  alert('被点击了！');
});
```





DOM 是前端开发的基础，它让网页从静态文档变成可以动态交互的应用程序。所有现代 JavaScript 框架（如 React、Vue）底层都在操作 DOM。

==什么是虚拟dom==

实际上它只是一层对真实`DOM`的抽象，是以`JavaScript` 对象 (`VNode` 节点) 作为基础的树，用对象的属性来描述节点，最终可以

通过一系列操作使这棵树映射到真实环境上。创建虚拟`DOM`就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟`DOM`对象的节点与真实`DOM`的属性一一照应

==作用==

`DOM`是很慢的，其元素非常庞大，页面的性能问题，大部分都是由`DOM`操作引起的。真实的`DOM`节点，哪怕一个最简单的`div`也包含着很多属性。由此可见，操作`DOM`的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验

**举个例子：**

你用传统的原生`api`或`jQuery`去操作`DOM`时，浏览器会从构建`DOM`树开始从头到尾执行一遍流程

当你在一次操作时，需要更新10个`DOM`节点，浏览器没这么智能，收到第一个更新`DOM`请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程



而通过`VNode`，同样更新10个`DOM`节点，虚拟`DOM`不会立即操作`DOM`，而是将这10次更新的`diff`内容保存到本地的一个`js`对象中，最终将这个`js`对象一次性`attach`到`DOM`树上，避免大量的无谓计算。



```

### 21.什么是diff算法

Vue 的 Diff 算法用于高效地更新 DOM，通过比较新旧虚拟 DOM 树的差异，只更新真正变化的部分。

Diff 算法基于三个假设来优化性能：

1. **只比较同层级节点**，不跨层级比较
2. **不同类型的元素产生不同的树**
3. **通过 key 来标识哪些元素是稳定的**



`diff`整体策略为：深度优先，同层比较

1. 比较只会在同层级进行, 不会跨层级比较
![a1](.\assets\91e9c9519a11caa0c5bf70714383f054-1763651026717-1.png)


1. 比较的过程中，循环从两边向中间收拢

![a2](.\assets\2dcd6ad5cf82c65b9cfc43a27ba1e4ec-1763651026718-3.png)

下面举个`vue`通过`diff`算法更新的例子：

新旧`VNode`节点如下图所示：

![a3](.\assets\80dc339f73b186479e6d1fc18bfbf66d-1763651026718-6.png)


第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为`diff`后的第一个真实节点，同时旧节点`endIndex`移动到C，新节点的 `startIndex` 移动到了 C


![a4](.\assets\76032c78c8ef74047efd42c070e48854-1763651026717-2.png)


第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，`diff` 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的 `endIndex` 移动到了 B，新节点的 `startIndex` 移动到了 E

![a5](.\assets\1c76e7489660188d35f0a38ea8c8ecd7-1763651026730-8.png)


第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 `startIndex` 移动到了 A。旧节点的 `startIndex` 和 `endIndex` 都保持不动

![a6](.\assets\4b622c0d61673ec5474465d82305d308-1763651026718-4.png)

第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 `diff` 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 `startIndex` 移动到了 B，新节点的`startIndex` 移动到了 B

![a7](.\assets\5982417c3e0b2fa9ae940354a0e67ab4-1763651026718-5.png)


第五次循环中，情形同第四次循环一样，因此 `diff` 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 `startIndex`移动到了 C，新节点的 startIndex 移动到了 F

![a8](.\assets\16cf0ef90f6e19d26c0ddffeca067e86-1763651026730-9.png)


新节点的 `startIndex` 已经大于 `endIndex` 了，需要创建 `newStartIdx` 和 `newEndIdx` 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面

![a9](.\assets\dc215b45682cf6c9cc4700a5425673ad-1763651026730-7.png)

```
### 22.vue项目中封装过axios吗，封装哪一方面？

==一、axios是什么==

`axios` 是一个轻量的 `HTTP`客户端

基于 `XMLHttpRequest` 服务来执行 `HTTP` 请求，支持丰富的配置，支持 `Promise`，支持浏览器端和 `Node.js` 端。自`Vue`2.0起，尤大宣布取消对 `vue-resource` 的官方推荐，转而推荐 `axios`。现在 `axios` 已经成为大部分 `Vue` 开发者的首选。`axios`是对`XMLHttpRequest`的二次封装。



- 从浏览器中创建 `XMLHttpRequests`
- 从 `node.js` 创建 `http`请求
- 支持 `Promise` API
- 拦截请求和响应
- 转换请求数据和响应数据
- 取消请求
- 自动转换`JSON` 数据
- 客户端支持防御`XSRF`

基本使用

安装

```js
// 项目中安装
npm install axios --S
// cdn 引入
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
```

导入

```js
import axios from 'axios'
```

发送请求

```js
axios({        
  url:'xxx',    // 设置请求的地址
  method:"GET", // 设置请求方法
  params:{      // get请求使用params进行参数凭借,如果是post请求用data
    type: '',
    page: 1
  }
}).then(res => {  
  // res为后端返回的数据
  console.log(res);   
})
```

并发请求`axios.all([])`

```js
function getUserAccount() {
    return axios.get('/user/12345');
}

function getUserPermissions() {
    return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
    .then(axios.spread(function (res1, res2) { 
    // res1第一个请求的返回的内容，res2第二个请求返回的内容
    // 两个请求都执行完成才会执行
}));
```

==二、为什么要封装==

`axios` 的 API 很友好，你完全可以很轻松地在项目中直接使用。

不过随着项目规模增大，如果每发起一次`HTTP`请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍

这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 `axios` 再使用

举个例子：

```js
axios('http://localhost:3000/data', {
  // 配置代码
  method: 'GET',
  timeout: 1000,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json',
    Authorization: 'xxx',
  },
  transformRequest: [function (data, headers) {
    return data;
  }],
  // 其他请求配置...
})
.then((data) => {
  // todo: 真正业务逻辑代码
  console.log(data);
}, (err) => {
  // 错误处理代码  
  if (err.response.status === 401) {
  // handle authorization error
  }
  if (err.response.status === 403) {
  // handle server forbidden error
  }
  // 其他错误处理.....
  console.log(err);
});
```

如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了

这时候我们就需要对`axios`进行二次封装，让使用更为便利

==三、如何封装==

封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间.......

设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分

请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)

状态码: 根据接口返回的不同`status` ， 来执行不同的业务，这块需要和后端约定好

请求方法：根据`get`、`post`等方法进行一个再次封装，使用起来更为方便

请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问

响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务

==设置接口请求前缀==

利用`node`环境变量来作判断，用来区分开发、测试、生产环境

```js
if (process.env.NODE_ENV === 'development') {
  axios.defaults.baseURL = 'http://dev.xxx.com'
} else if (process.env.NODE_ENV === 'production') {
  axios.defaults.baseURL = 'http://prod.xxx.com'
}
```

在本地调试的时候，还需要在`vue.config.js`文件中配置`devServer`实现代理转发，从而实现跨域

```js
devServer: {
    proxy: {
      '/proxyApi': {
        target: 'http://dev.xxx.com',
        changeOrigin: true,
        pathRewrite: {
          '/proxyApi': ''
        }
      }
    }
  }
```

设置请求头与超时时间

大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置

```js
const service = axios.create({
    ...
    timeout: 30000,  // 请求 30s 超时
	  headers: {
        get: {
          'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'
          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来
        },
        post: {
          'Content-Type': 'application/json;charset=utf-8'
          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来
        }
  },
})
```

封装请求方法

先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去

```js
// get 请求
export function httpGet({
  url,
  params = {}
}) {
  return new Promise((resolve, reject) => {
    axios.get(url, {
      params
    }).then((res) => {
      resolve(res.data)
    }).catch(err => {
      reject(err)
    })
  })
}

// post
// post请求
export function httpPost({
  url,
  data = {},
  params = {}
}) {
  return new Promise((resolve, reject) => {
    axios({
      url,
      method: 'post',
      transformRequest: [function (data) {
        let ret = ''
        for (let it in data) {
          ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&'
        }
        return ret
      }],
      // 发送的数据
      data,
      // url参数
      params

    }).then(res => {
      resolve(res.data)
    })
  })
}
```

把封装的方法放在一个`api.js`文件中

```js
import { httpGet, httpPost } from './http'
export const getorglist = (params = {}) => httpGet({ url: 'apps/api/org/list', params })
```

页面中就能直接调用

```js
// .vue
import { getorglist } from '@/assets/js/api'

getorglist({ id: 200 }).then(res => {
  console.log(res)
})
```

这样可以把`api`统一管理起来，以后维护修改只需要在`api.js`文件操作即可

**请求拦截器**

请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便

```js
// 请求拦截器
axios.interceptors.request.use(
  config => {
    // 每次发送请求之前判断是否存在token
    // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的
    token && (config.headers.Authorization = token)
    return config
  },
  error => {
    return Promise.error(error)
  })
```

**响应拦截器**

响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权

```js
// 响应拦截器
axios.interceptors.response.use(response => {
  // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据
  // 否则的话抛出错误
  if (response.status === 200) {
    if (response.data.code === 511) {
      // 未授权调取授权接口
    } else if (response.data.code === 510) {
      // 未登录跳转登录页
    } else {
      return Promise.resolve(response)
    }
  } else {
    return Promise.reject(response)
  }
}, error => {
  // 我们可以在这里对异常状态作统一处理
  if (error.response.status) {
    // 处理请求失败的情况
    // 对不同返回码对相应处理
    return Promise.reject(error.response)
  }
})
```

### 23.SSR解决了哪些问题，有做过SSR吗，怎么做的？

什么是 SSR

**SSR（Server-Side Rendering，服务端渲染）** 是指在服务器上将页面渲染成完整的 HTML，然后发送给浏览器的技术。

SSR vs CSR 对比

CSR（客户端渲染）传统流程

```
1. 浏览器请求页面
2. 服务器返回空 HTML + JS 文件
   <div id="app"></div>
   <script src="app.js"></script>
3. 浏览器下载并执行 JS
4. JS 发起 API 请求获取数据
5. 渲染页面内容
```

SSR 流程

```
1. 浏览器请求页面
2. 服务器执行 Vue/React 代码
3. 服务器获取数据并渲染 HTML
4. 返回完整的 HTML 内容
   <div id="app">
     <h1>已渲染的标题</h1>
     <p>已渲染的内容</p>
   </div>
5. 浏览器显示内容（水合 hydration）
6. JS 接管交互功能
```

SSR 的优势

1. **更好的 SEO（搜索引擎优化）**

搜索引擎爬虫可以直接看到完整的 HTML 内容。

```html
<!-- CSR：爬虫看到的 -->
<div id="app"></div>

<!-- SSR：爬虫看到的 -->
<div id="app">
  <h1>商品标题</h1>
  <p>商品描述，价格 ¥299</p>
</div>
```

2. **更快的首屏加载**

用户无需等待 JS 下载和执行就能看到内容。

3. **更好的用户体验**

特别是在网络较慢或设备性能较差的情况下。

==SSR 的劣势==

1. **服务器负载增加** - 每次请求都需要服务器渲染
2. **开发复杂度提高** - 需要考虑服务端和客户端环境差异
3. **部署成本更高** - 需要 Node.js 服务器，不能简单部署到静态服务器
4. **某些浏览器 API 不可用** - 如 `window`、`document` 在服务端不存在

Vue SSR 示例

基础示例

```javascript
// server.js
const Vue = require('vue');
const express = require('express');
const renderer = require('vue-server-renderer').createRenderer();

const app = express();

app.get('*', async (req, res) => {
  // 创建 Vue 实例
  const vueApp = new Vue({
    data: {
      message: '来自服务器的问候'
    },
    template: `
      <div>
        <h1>{{ message }}</h1>
        <p>当前时间：{{ new Date().toLocaleString() }}</p>
      </div>
    `
  });

  try {
    // 渲染成 HTML
    const html = await renderer.renderToString(vueApp);
    
    res.send(`
      <!DOCTYPE html>
      <html>
        <head><title>SSR Demo</title></head>
        <body>
          <div id="app">${html}</div>
        </body>
      </html>
    `);
  } catch (err) {
    res.status(500).send('Server Error');
  }
});

app.listen(3000);
```





==SSR 的变体==

1. **SSG（Static Site Generation，静态站点生成）**

构建时预渲染，适合内容不常变的页面。

```javascript
// Next.js
export async function getStaticProps() {
  // 构建时执行一次
  const data = await fetchData();
  return { props: { data } };
}
```

2. **ISR（Incremental Static Regeneration，增量静态再生）**

定期更新静态页面。

```javascript
export async function getStaticProps() {
  return {
    props: { data },
    revalidate: 60 // 每 60 秒重新生成
  };
}
```

3. **Streaming SSR（流式 SSR）**

边渲染边传输，React 18 的新特性。

```jsx
<Suspense fallback={<Loading />}>
  <SlowComponent />
</Suspense>
```

**何时使用 SSR**

✅ 适合使用 SSR

- 需要良好 SEO 的网站（电商、博客、新闻）
- 首屏加载速度要求高
- 内容动态变化但需要被搜索引擎索引

❌ 不适合 SSR

- 后台管理系统（不需要 SEO）
- 高度交互的应用（如在线编辑器）
- 实时性要求极高的应用
- 团队缺乏 SSR 经验且项目时间紧

>[!important]
>sdfasdfasd




实际项目建议

```javascript
// 选择渲染策略的决策树
if (需要 SEO) {
  if (内容很少变化) {
    return 'SSG'; // 最快
  } else if (内容经常变化) {
    return 'SSR'; // 实时性好
  } else {
    return 'ISR'; // 平衡性能和实时性
  }
} else {
  return 'CSR'; // 最简单
}
```

SSR 是现代 Web 开发的重要技术，特别是在需要平衡性能、SEO 和用户体验的场景下。选择合适的框架和渲染策略，可以大大提升应用的质量。

### 24.vue的权限管理应该怎么做，控制到按钮级别的权限要怎么做？

 ==一、是什么==

权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源

而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发

- 页面加载触发
- 页面上的按钮点击触发

总的来说，所有的请求发起都触发自前端路由或视图

所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：

- 路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 `4xx` 提示页
- 视图方面，用户只能看到自己有权浏览的内容和有权操作的控件
- 最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截

==二、如何做==

前端权限控制可以分为四个方面：

- 接口权限
- 按钮权限
- 菜单权限
- 路由权限



**接口权限**

接口权限目前一般采用`jwt`的形式来验证，没有通过的话一般返回`401`，跳转到登录页面重新进行登录

登录完拿到`token`，将`token`存起来，通过`axios`请求拦截器进行拦截，每次请求的时候头部携带`token`

```js
axios.interceptors.request.use(config => {
    config.headers['token'] = cookie.get('token')
    return config
})
axios.interceptors.response.use(res=>{},{response}=>{
    if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误
        router.push('/login')
    }
})
```



**路由权限控制**

**方案一**

初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验

```js
const routerMap = [
  {
    path: '/permission',
    component: Layout,
    redirect: '/permission/index',
    alwaysShow: true, // will always show the root menu
    meta: {
      title: 'permission',
      icon: 'lock',
      roles: ['admin', 'editor'] // you can set roles in root nav
    },
    children: [{
      path: 'page',
      component: () => import('@/views/permission/page'),
      name: 'pagePermission',
      meta: {
        title: 'pagePermission',
        roles: ['admin'] // or you can only set roles in sub nav
      }
    }, {
      path: 'directive',
      component: () => import('@/views/permission/directive'),
      name: 'directivePermission',
      meta: {
        title: 'directivePermission'
        // if do not set roles, means: this page does not require permission
      }
    }]
  }]
```

这种方式存在以下四种缺点：

- 加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。
- 全局路由守卫里，每次路由跳转都要做权限判断。
- 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译
- 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识

**方案二**

初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制

登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用`addRoutes`添加路由

```js
import router from './router'
import store from './store'
import { Message } from 'element-ui'
import NProgress from 'nprogress' // progress bar
import 'nprogress/nprogress.css'// progress bar style
import { getToken } from '@/utils/auth' // getToken from cookie

NProgress.configure({ showSpinner: false })// NProgress Configuration

// permission judge function
function hasPermission(roles, permissionRoles) {
  if (roles.indexOf('admin') >= 0) return true // admin permission passed directly
  if (!permissionRoles) return true
  return roles.some(role => permissionRoles.indexOf(role) >= 0)
}

const whiteList = ['/login', '/authredirect']// no redirect whitelist

router.beforeEach((to, from, next) => {
  NProgress.start() // start progress bar
  if (getToken()) { // determine if there has token
    /* has token*/
    if (to.path === '/login') {
      next({ path: '/' })
      NProgress.done() // if current page is dashboard will not trigger	afterEach hook, so manually handle it
    } else {
      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息
        store.dispatch('GetUserInfo').then(res => { // 拉取user_info
          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']
          store.dispatch('GenerateRoutes', { roles }).then(() => { // 根据roles权限生成可访问的路由表
            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表
            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record
          })
        }).catch((err) => {
          store.dispatch('FedLogOut').then(() => {
            Message.error(err || 'Verification failed, please login again')
            next({ path: '/' })
          })
        })
      } else {
        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓
        if (hasPermission(store.getters.roles, to.meta.roles)) {
          next()//
        } else {
          next({ path: '/401', replace: true, query: { noGoBack: true }})
        }
        // 可删 ↑
      }
    }
  } else {
    /* has no token*/
    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
      next()
    } else {
      next('/login') // 否则全部重定向到登录页
      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it
    }
  }
})

router.afterEach(() => {
  NProgress.done() // finish progress bar
})
```

按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限

这种方式也存在了以下的缺点：

- 全局路由守卫里，每次路由跳转都要做判断
- 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译
- 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识

**菜单权限控制**

菜单权限可以理解成将页面与理由进行解耦

**方案1**

菜单与路由分离，菜单由后端返回

前端定义路由信息

```js
{
    name: "login",
    path: "/login",
    component: () => import("@/pages/Login.vue")
}
```

`name`字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有`name`对应的字段，并且做唯一性校验

全局路由守卫里做判断

```js
function hasPermission(router, accessMenu) {
  if (whiteList.indexOf(router.path) !== -1) {
    return true;
  }
  let menu = Util.getMenuByName(router.name, accessMenu);
  if (menu.name) {
    return true;
  }
  return false;

}

Router.beforeEach(async (to, from, next) => {
  if (getToken()) {
    let userInfo = store.state.user.userInfo;
    if (!userInfo.name) {
      try {
        await store.dispatch("GetUserInfo")
        await store.dispatch('updateAccessMenu')
        if (to.path === '/login') {
          next({ name: 'home_index' })
        } else {
          //Util.toDefaultPage([...routers], to.name, router, next);
          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由
        }
      }  
      catch (e) {
        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
          next()
        } else {
          next('/login')
        }
      }
    } else {
      if (to.path === '/login') {
        next({ name: 'home_index' })
      } else {
        if (hasPermission(to, store.getters.accessMenu)) {
          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);
        } else {
          next({ path: '/403',replace:true })
        }
      }
    }
  } else {
    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
      next()
    } else {
      next('/login')
    }
  }
  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);
  Util.title(menu.title);
});

Router.afterEach((to) => {
  window.scrollTo(0, 0);
});
```

每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的`name`与路由的`name`是一一对应的，而后端返回的菜单就已经是经过权限过滤的

如果根据路由`name`找不到对应的菜单，就表示用户有没权限访问

如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过`addRoutes`动态挂载

这种方式的缺点：

- 菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用
- 全局路由守卫里，每次路由跳转都要做判断

**方案二**

菜单和路由都由后端返回

前端统一定义路由组件

```js
const Home = () => import("../pages/Home.vue");
const UserInfo = () => import("../pages/UserInfo.vue");
export default {
    home: Home,
    userInfo: UserInfo
};
```

后端路由组件返回以下格式

```js
[
    {
        name: "home",
        path: "/",
        component: "home"
    },
    {
        name: "home",
        path: "/userinfo",
        component: "userInfo"
    }
]
```

在将后端返回路由通过`addRoutes`动态挂载之间，需要将数据处理一下，将`component`字段换为真正的组件

如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理

这种方法也会存在缺点：

- 全局路由守卫里，每次路由跳转都要做判断
- 前后端的配合要求更高

**按钮权限**

**方案1**



按钮权限也可以用`v-if`判断

但是如果页面过多，每个页面页面都要获取用户权限`role`和路由表里的`meta.btnPermissions`，然后再做判断

这种方式就不展开举例了

**方案二**

通过自定义指令进行按钮权限的判断

首先配置路由

```js
{
    path: '/permission',
    component: Layout,
    name: '权限测试',
    meta: {
        btnPermissions: ['admin', 'supper', 'normal']
    },
    //页面需要的权限
    children: [{
        path: 'supper',
        component: _import('system/supper'),
        name: '权限测试页',
        meta: {
            btnPermissions: ['admin', 'supper']
        } //页面需要的权限
    },
    {
        path: 'normal',
        component: _import('system/normal'),
        name: '权限测试页',
        meta: {
            btnPermissions: ['admin']
        } //页面需要的权限
    }]
}
```

自定义权限鉴定指令

```js
import Vue from 'vue'
/**权限指令**/
const has = Vue.directive('has', {
    bind: function (el, binding, vnode) {
        // 获取页面按钮权限
        let btnPermissionsArr = [];
        if(binding.value){
            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。
            btnPermissionsArr = Array.of(binding.value);
        }else{
            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。
            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;
        }
        if (!Vue.prototype.$_has(btnPermissionsArr)) {
            el.parentNode.removeChild(el);
        }
    }
});
// 权限检查方法
Vue.prototype.$_has = function (value) {
    let isExist = false;
    // 获取用户按钮权限
    let btnPermissionsStr = sessionStorage.getItem("btnPermissions");
    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {
        return false;
    }
    if (value.indexOf(btnPermissionsStr) > -1) {
        isExist = true;
    }
    return isExist;
};
export {has}
```

在使用的按钮中只需要引用`v-has`指令

```js
<el-button @click='editClick' type="primary" v-has>编辑</el-button>
```

### 25.vue项目中是如何解决跨域问题的

==一、跨域是什么==

跨域本质是浏览器基于**同源策略**的一种安全手段

同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能

所谓同源（即指在同一个域）具有以下三个相同点

- 协议相同（protocol）
- 主机相同（host）
- 端口相同（port）

反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域

> 一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。


==二、如何解决==

解决跨域的方法有很多，下面列举了三种：

- JSONP
- CORS
- Proxy

而在`vue`项目中，我们主要针对`CORS`或`Proxy`这两种方案进行展开

**CORS**

CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应

`CORS` 实现起来非常方便，只需要增加一些 `HTTP` 头，让服务器能声明允许的访问来源

只要后端实现了 `CORS`，就实现了跨域



以`koa`框架举例

添加中间件，直接设置`Access-Control-Allow-Origin`响应头

```js
app.use(async (ctx, next)=> {
  ctx.set('Access-Control-Allow-Origin', '*');
  ctx.set('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');
  ctx.set('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');
  if (ctx.method == 'OPTIONS') {
    ctx.body = 200; 
  } else {
    await next();
  }
})
```

ps: `Access-Control-Allow-Origin` 设置为*其实意义不大，可以说是形同虚设，实际应用中，上线前我们会将`Access-Control-Allow-Origin` 值设为我们目标`host`

**Proxy**

代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击

**方案一**

如果是通过`vue-cli`脚手架工具搭建项目，我们可以通过`webpack`为我们起一个本地服务器作为请求的代理对象

通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域

在`vue.config.js`文件，新增以下代码

```js
amodule.exports = {
    devServer: {
        host: '127.0.0.1',
        port: 8084,
        open: true,// vue项目启动时自动打开浏览器
        proxy: {
            '/api': { // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
                target: "http://xxx.xxx.xx.xx:8080", //目标地址，一般是指后台服务器地址
                changeOrigin: true, //是否跨域
                pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
                    '^/api': "" 
                }
            }
        }
    }
}
```

通过`axios`发送请求中，配置请求的根路径

```js
axios.defaults.baseURL = '/api'
```

**方案二**

此外，还可通过服务端实现代理请求转发

以`express`框架为例

```js
var express = require('express');
const proxy = require('http-proxy-middleware')
const app = express()
app.use(express.static(__dirname + '/'))
app.use('/api', proxy({ target: 'http://localhost:4000', changeOrigin: false
                      }));
module.exports = app
```

**方案三**

通过配置`nginx`实现代理

```js
server {
    listen    80;
    # server_name www.josephxia.com;
    location / {
        root  /var/www/html;
        index  index.html index.htm;
        try_files $uri $uri/ /index.html;
    }
    location /api {
        proxy_pass  http://127.0.0.1:3000;
        proxy_redirect   off;
        proxy_set_header  Host       $host;
        proxy_set_header  X-Real-IP     $remote_addr;
        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;
    }
}
```

### 26.Vue3.0性能提升主要是通过哪几方面体现的？

==编译阶段优化==



**1.静态提升（Static Hoisting / Static Tree Hoisting）**

这是 Vue 3 编译优化中最核心的改进之一。

- **原理：**

  - Vue 3 的编译器会分析模板，识别出**完全不会改变**的静态内容（例如，纯文本节点、没有动态绑定的 HTML 元素等）。

  - 在编译阶段，这些静态内容会被提升（hoist）到 `render` 函数的外部，**只创建一次**。

  - 在组件后续的重新渲染和 Diff 过程中，可以直接重用这些创建好的静态 VNode，

    **完全跳过对这些静态节点的 Diff 比较**。

> **示例：** 一个组件模板中有一个纯粹的 `<h1>静态标题</h1>`，在 Vue 3 中，这个 `h1` 元素对应的 VNode 会被提升，无论父组件数据如何变化，`h1` VNode 都会被复用。



**2.事件监听缓存（Cache Handler）**



这是针对**事件绑定**的优化。

- **目标：** 解决 Vue 2 中由于内联函数导致的重复创建问题。
- **Vue 2 的问题：** 当在模板中像 `@click="count++"` 或 `@click="someMethod()"` 这样使用内联函数或方法引用时，**每次组件更新**，Vue 2 都会**创建一个新的内联函数**，即使这个逻辑没有变化。这会导致：
  1. 每次更新都需要解绑旧的事件监听器。
  2. 每次更新都需要绑定新的事件监听器。
  3. 每次更新都会创建新的函数对象，造成一定的内存和 GC 压力。
- **Vue 3 的优化（Cache Handler）：**
  - Vue 3 编译器会**自动缓存**这些内联事件监听器。
  - 在组件的初次渲染时创建事件处理函数，并在随后的更新中**直接复用**这个缓存的函数。
- **带来的优化：** 避免了不必要的解绑/绑定操作和函数对象的重复创建，提高了事件处理的效率。

**3.SSR 优化（Server-Side Rendering Optimization）**



Vue 3 的 SSR 性能相比 Vue 2 有了显著提升，核心在于**更高效的字符串拼接**和对**流式传输**

的支持。

- **目标：** 提高服务器端渲染速度，加快首屏时间。
- **主要优化点：**
  1. **更快的模板编译产物：**
     - 在 SSR 模式下，Vue 3 的模板被编译成**更优化、更高效的字符串拼接函数**，而不是 Vue 2 中的 VNode `render` 函数。
     - 直接拼接字符串比先创建 VNode 对象再序列化为字符串的效率更高。
  2. **流式 SSR (Streaming SSR)：**
     - Vue 3 提供了对**流式渲染**的原生支持。这意味着服务器可以**分块**将 HTML 发送给浏览器，而不是等待整个应用渲染完成再发送。
     - 浏览器可以立即开始解析和渲染已接收到的部分，**缩短了“首次内容绘制”（FCP）时间**，改善了用户体验。
  3. **水合（Hydration）优化：**
     - SSR 生成的 HTML 在客户端需要“水合”以变得可交互。Vue 3 的 VNode 树结构更高效，能**更快地匹配**服务器端渲染的 DOM 结构进行水合。

==源码体积==

相比`Vue2`，`Vue3`整体体积变小了，除了移出一些不常用的API，再重要的是`Tree shanking`

任何一个函数，如`ref`、`reavtived`、`computed`等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小

==响应式系统==

`vue2`中采用 `defineProperty`来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加`getter`和`setter`，实现响应式

`vue3`采用`proxy`重写了响应式系统，因为`proxy`可以对整个对象进行监听，所以不需要深度遍历

- 可以监听动态属性的添加
- 可以监听到数组的索引和数组`length`属性
- 可以监听删除属性

### 27.Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？

==一、Object.defineProxy==

定义：`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象

**为什么能实现响应式**

通过`defineProperty` 两个属性，`get`及`set`

- get

属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值

- set

属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined

下面通过代码展示：

定义一个响应式函数`defineReactive`

```js
function update() {
    app.innerText = obj.foo
}

function defineReactive(obj, key, val) {
    Object.defineProperty(obj, key, {
        get() {
            console.log(`get ${key}:${val}`);
            return val
        },
        set(newVal) {
            if (newVal !== val) {
                val = newVal
                update()
            }
        }
    })
}
```

调用`defineReactive`，数据发生变化触发`update`方法，实现数据响应式

```js
const obj = {}
defineReactive(obj, 'foo', '')
setTimeout(()=>{
    obj.foo = new Date().toLocaleTimeString()
},1000)
```

在对象存在多个`key`情况下，需要进行遍历

```js
function observe(obj) {
    if (typeof obj !== 'object' || obj == null) {
        return
    }
    Object.keys(obj).forEach(key => {
        defineReactive(obj, key, obj[key])
    })
}
```

如果存在嵌套对象的情况，还需要在`defineReactive`中进行递归

```js
function defineReactive(obj, key, val) {
    observe(val)
    Object.defineProperty(obj, key, {
        get() {
            console.log(`get ${key}:${val}`);
            return val
        },
        set(newVal) {
            if (newVal !== val) {
                val = newVal
                update()
            }
        }
    })
}
```

当给`key`赋值为对象的时候，还需要在`set`属性中进行递归

```js
set(newVal) {
    if (newVal !== val) {
        observe(newVal) // 新值是对象的情况
        notifyUpdate()
    }
}
```

上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题

现在对一个对象进行删除与添加属性操作，无法劫持到

```js
const obj = {
    foo: "foo",
    bar: "bar"
}
observe(obj)
delete obj.foo // no ok
obj.jar = 'xxx' // no ok
```

当我们对一个数组进行监听的时候，并不那么好使了

```js
const arrData = [1,2,3,4,5];
arrData.forEach((val,index)=>{
    defineProperty(arrData,index,val)
})
arrData.push() // no ok
arrData.pop()  // no ok
arrDate[0] = 99 // ok
```

可以看到数据的`api`无法劫持到，从而无法实现数据响应式，

所以在`Vue2`中，增加了`set`、`delete` API，并且对数组`api`方法进行一个重写

还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题

**小结**

- 检测不到对象属性的添加和删除
- 数组`API`方法无法监听到
- 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题

==proxy==

`Proxy`的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了

在`ES6`系列中，我们详细讲解过`Proxy`的使用，就不再述说了

下面通过代码进行展示：

定义一个响应式方法`reactive`

```js
function reactive(obj) {
    if (typeof obj !== 'object' && obj != null) {
        return obj
    }
    // Proxy相当于在对象外层加拦截
    const observed = new Proxy(obj, {
        get(target, key, receiver) {
            const res = Reflect.get(target, key, receiver)
            console.log(`获取${key}:${res}`)
            return res
        },
        set(target, key, value, receiver) {
            const res = Reflect.set(target, key, value, receiver)
            console.log(`设置${key}:${value}`)
            return res
        },
        deleteProperty(target, key) {
            const res = Reflect.deleteProperty(target, key)
            console.log(`删除${key}:${res}`)
            return res
        }
    })
    return observed
}
```

测试一下简单数据的操作，发现都能劫持

```js
const state = reactive({
    foo: 'foo'
})
// 1.获取
state.foo // ok
// 2.设置已存在属性
state.foo = 'fooooooo' // ok
// 3.设置不存在属性
state.dong = 'dong' // ok
// 4.删除属性
delete state.dong // ok
```

再测试嵌套对象情况，这时候发现就不那么 OK 了

```js
const state = reactive({
    bar: { a: 1 }
})

// 设置嵌套对象属性
state.bar.a = 10 // no ok
```

如果要解决，需要在`get`之上再进行一层代理

```js
function reactive(obj) {
    if (typeof obj !== 'object' && obj != null) {
        return obj
    }
    // Proxy相当于在对象外层加拦截
    const observed = new Proxy(obj, {
        get(target, key, receiver) {
            const res = Reflect.get(target, key, receiver)
            console.log(`获取${key}:${res}`)
            return isObject(res) ? reactive(res) : res
        },
    return observed
}
```

==问题总结==

`Object.defineProperty`只能遍历对象属性进行劫持

```js
function observe(obj) {
    if (typeof obj !== 'object' || obj == null) {
        return
    }
    Object.keys(obj).forEach(key => {
        defineReactive(obj, key, obj[key])
    })
}
```

`Proxy`直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的

```js
function reactive(obj) {
    if (typeof obj !== 'object' && obj != null) {
        return obj
    }
    // Proxy相当于在对象外层加拦截
    const observed = new Proxy(obj, {
        get(target, key, receiver) {
            const res = Reflect.get(target, key, receiver)
            console.log(`获取${key}:${res}`)
            return res
        },
        set(target, key, value, receiver) {
            const res = Reflect.set(target, key, value, receiver)
            console.log(`设置${key}:${value}`)
            return res
        },
        deleteProperty(target, key) {
            const res = Reflect.deleteProperty(target, key)
            console.log(`删除${key}:${res}`)
            return res
        }
    })
    return observed
}
```

`Proxy`可以直接监听数组的变化（`push`、`shift`、`splice`）

```js
const obj = [1,2,3]
const proxtObj = reactive(obj)
obj.psuh(4) // ok
```

`Proxy`有多达13种拦截方法,不限于`apply`、`ownKeys`、`deleteProperty`、`has`等等，这是`Object.defineProperty`不具备的

正因为`defineProperty`自身的缺陷，导致`Vue2`在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外`set`、`delete`方法）

```js
// 数组重写
const originalProto = Array.prototype
const arrayProto = Object.create(originalProto)
['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'sort'].forEach(method => {
  arrayProto[method] = function () {
    originalProto[method].apply(this.arguments)
    dep.notice()
  }
});

// set、delete
Vue.set(obj,'bar','newbar')
Vue.delete(obj),'bar')
```

`Proxy` 不兼容IE，也没有 `polyfill`, `defineProperty` 能支持到IE9

### 28.Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？

Composition API（组合式 API）与 Vue 2.x 使用的 Options API（选项式 API）在**代码组织、逻辑复用**和**类型推导**方面存在根本性的不同。

### Vue API 区别对比



| **特点**          | **Composition API (Vue 3.0+)**                               | **Options API (Vue 2.x)**                                    |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **代码组织**      | **按逻辑组织**（通过 `setup()` 函数）                        | **按选项类型组织**（`data`, `methods`, `computed` 等）       |
| **逻辑复用**      | 🌟 **非常出色**，通过自定义 Hook（函数）实现，参数和返回值非常灵活。 | 较困难，主要通过 `mixin` 实现，易产生命名冲突和数据来源不清晰。 |
| **代码阅读**      | 逻辑紧密的代码块更集中，阅读一个功能时不需要在文件内来回跳转。 | 一个功能的逻辑分散在不同的选项中（“横向切割”）。             |
| **类型推导**      | 🌟 **优秀**，大量使用普通函数，对 TypeScript 的支持和类型推导非常友好。 | 较弱，组件实例上的 `this` 类型需要更复杂的工具支持。         |
| **性能/运行时**   | 内部实现对 tree-shaking 友好，打包体积更小。                 | 相对固定。                                                   |
| **上手难度**      | 上手需要理解响应式原理（`ref`, `reactive`），心智负担稍重。  | 上手简单，遵循固定的对象结构即可。                           |
| **`this` 关键字** | 基本不使用 `this`，一切都是通过函数调用和返回值来处理。      | 广泛依赖 `this` 上下文来访问数据和方法。                     |

**代码组织**

**Options API：** 是一种“横向切割”的组织方式。

- 当实现一个功能（比如一个计数器）时，你需要将这个功能的逻辑分散到不同的选项块中：状态放到 `data`，计算属性放到 `computed`，方法放到 `methods`，生命周期逻辑放到 `mounted` 等。
- 对于大型组件，一个功能的逻辑代码往往需要你不断`上下滚动文件`查找。

**Composition API：** 是一种“纵向聚合”的组织方式。

- 通过一个统一的入口函数 `setup()`，你可以将**同一个功能相关联的**状态、计算属性和方法**集中写在一起**。
- 这样，当阅读或维护代码时，你只需要关注这个功能所在的逻辑块即可，极大地提高了大型组件的可维护性。



**逻辑复用**

在`Vue2`中，我们是用过`mixin`去复用相同的逻辑

下面举个例子，我们会另起一个`mixin.js`文件

```js
export const MoveMixin = {
  data() {
    return {
      x: 0,
      y: 0,
    };
  },

  methods: {
    handleKeyup(e) {
      console.log(e.code);
      // 上下左右 x y
      switch (e.code) {
        case "ArrowUp":
          this.y--;
          break;
        case "ArrowDown":
          this.y++;
          break;
        case "ArrowLeft":
          this.x--;
          break;
        case "ArrowRight":
          this.x++;
          break;
      }
    },
  },

  mounted() {
    window.addEventListener("keyup", this.handleKeyup);
  },

  unmounted() {
    window.removeEventListener("keyup", this.handleKeyup);
  },
};
```

然后在组件中使用

```js
<template>
  <div>
    Mouse position: x {{ x }} / y {{ y }}
  </div>
</template>
<script>
import mousePositionMixin from './mouse'
export default {
  mixins: [mousePositionMixin]
}
</script>
```

使用单个`mixin`似乎问题不大，但是当我们一个组件混入大量不同的 `mixins` 的时候

```js
mixins: [mousePositionMixin, fooMixin, barMixin, otherMixin]
```

会存在两个非常明显的问题：

- 命名冲突
- 数据来源不清晰

现在通过`Compositon API`这种方式改写上面的代码

```js
import { onMounted, onUnmounted, reactive } from "vue";
export function useMove() {
  const position = reactive({
    x: 0,
    y: 0,
  });

  const handleKeyup = (e) => {
    console.log(e.code);
    // 上下左右 x y
    switch (e.code) {
      case "ArrowUp":
        // y.value--;
        position.y--;
        break;
      case "ArrowDown":
        // y.value++;
        position.y++;
        break;
      case "ArrowLeft":
        // x.value--;
        position.x--;
        break;
      case "ArrowRight":
        // x.value++;
        position.x++;
        break;
    }
  };

  onMounted(() => {
    window.addEventListener("keyup", handleKeyup);
  });

  onUnmounted(() => {
    window.removeEventListener("keyup", handleKeyup);
  });

  return { position };
}
```

在组件中使用

```js
<template>
  <div>
    Mouse position: x {{ x }} / y {{ y }}
  </div>
</template>

<script>
import { useMove } from "./useMove";
import { toRefs } from "vue";
export default {
  setup() {
    const { position } = useMove();
    const { x, y } = toRefs(position);
    return {
      x,
      y,
    };

  },
};
</script>
```

可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题





### 29.



### 30.
