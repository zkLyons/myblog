# html/css




## JavaScript

### 1.说说JavaScript中的数据类型？存储上的差别？
在`JavaScript`中，我们可以分成两种类型：
- 基本类型
- 复杂类型
两种类型的区别是：存储位置不同
==基本类型==
基本类型主要为以下6种：

- Number
- String
字符串可以使用双引号（"）、单引号（'）或反引号（\`）标示，字符串是不可变的，意思是一旦创建，它们的值就不能变了
- Boolean
`Boolean`（布尔值）类型有两个字面值： `true` 和`false`,通过`Boolean`可以将其他类型的数据转化成布尔值
- Undefined
`Undefined` 类型只有一个值，就是特殊值 `undefined`。当使用 `var`或 `let`声明了变量但没有初始化时，就相当于给变量赋予了 `undefined`值。
包含`undefined` 值的变量跟未定义变量是有区别的

```js
let message; // 这个变量被声明了，只是值为 undefined

console.log(message); // "undefined"
console.log(age); // 没有声明过这个变量，报错
```
- null
`Null`类型同样只有一个值，即特殊值 `null`,逻辑上讲， null 值表示一个空对象指针
- symbol

他可以最为唯一的对象属性名称，作为 Symbol **最重要**的用途。由于每个 Symbol 都是唯一的，可以避免属性名冲突。

**场景：** 为对象添加"元数据"或"隐藏属性"

```
// 不同的库或模块可能都想给对象添加属性
const user = { name: 'Alice' };

// 模块A想添加一个标识
const MODULE_A_FLAG = Symbol('moduleA');
user[MODULE_A_FLAG] = true;

// 模块B也想添加类似的标识
const MODULE_B_FLAG = Symbol('moduleB'); 
user[MODULE_B_FLAG] = 'processed';

// 两个属性不会冲突，即使描述相同也不会冲突
const ANOTHER_FLAG = Symbol('moduleA'); // 描述相同但Symbol不同
user[ANOTHER_FLAG] = 'another';

console.log(user);
//控制台输出的信息可以观察到，第一个和第三个描述key都是一样的，但是实际上他们是完全独立的，
// {
//   name: 'Alice',
//   [Symbol(moduleA)]: true,
//   [Symbol(moduleB)]: 'processed',
//   [Symbol(moduleA)]: 'another'
// }
//对于同名key该如何访问呢？
console.log(user[MODULE_A_FLAG]) //true
console.log(user[ANOTHER_FLAG])  //another
```





==引用类型==
复杂类型统称为`Object`，我们这里主要讲述下面三种：

- Object
- Array
- Function

==存储区别==
基本数据类型和引用数据类型存储在内存中的位置不同：

- 基本数据类型存储在栈中    
- 引用类型的对象存储于堆中



1. **基本数据类型 (Primitives):**
   - 存在栈里。
   - `let a = 10;` 栈上的 `a` 变量就**直接**保存着 `10` 这个**值**。
2. **引用数据类型 (References):**
   - **地址**在栈里。
   - **值**（即对象 `{...}` 或数组 `[...]` 本身）在堆里。
   - `let obj = { name: 'Tom' };` 栈上的 `obj` 变量保存的是一个**地址**（比如 `0x1A2B`），这个地址指向堆内存中存储 `{ name: 'Tom' }` 的那个位置。



- **栈 (Stack)** 是高度有序的，必须严格遵循**后进先出 (LIFO)** 的规则来分配和释放，就像叠盘子，非常高效。
- **堆 (Heap)** 就像一个大仓库，当你需要存东西（创建对象）时，系统就在仓库里找个**大小足够的空位**把东西放进去，它不需要按顺序放。因此，它的内存分配是**动态**且相对**无序**的。



==小结==

- 声明变量时不同的内存地址分配：
    - 简单类型的值存放在栈中，在栈中存放的是对应的值
    - 引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址
- 不同的类型数据导致赋值变量时的不同：
    - 简单类型赋值，是生成相同的值，两个对象对应不同的地址
    - 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象



### 2.数组常用的方法有哪些

现总结：
- 数组和字符串的转换方法：`toString()`、`toLocalString()`、`join()` 其中 `join()` 方法可以指定转换为字符串时的分隔符。

```js
console.log(num.toString()); // "123"
//返回对象的本地化字符串表示，根据语言环境和地区设置格式化。
const number = 1234567.89;
console.log(number.toString()); // "1234567.89"
console.log(number.toLocaleString()); // 中文环境："1,234,567.89"
console.log(number.toLocaleString('de-DE')); // 德语环境："1.234.567,89"
console.log(number.toLocaleString('ar-EG')); // 阿拉伯语环境："١٬٢٣٤٬٥٦٧٫٨٩"
```



- 数组尾部操作的方法 `pop()` 和 `push()`，`push` 方法可以传入多个参数。

- 数组首部操作的方法 `shift()` 和 `unshift()` ，重排序的方法 `reverse()` 和 `sort()`，`sort()` 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。

- 数组连接的方法 `concat()` ，返回的是拼接好的数组，不影响原数组。

- 数组截取办法 `slice()`，用于截取数组中的一部分返回，不影响原数组。

- 数组插入方法 `splice()`，影响原数组查找特定项的索引的方法`indexOf()` 和 `lastIndexOf()` ，迭代方法 `every()`、`some()`、`filter()`、`map()` 和`forEach()`方法

```
//every用于判断元素是否全部都满足条件，任何一个不满足就返回false
const numbers1 = [1, 2, 3, 4, 5];
const allPositive = numbers1.every(num => num > 0);
console.log(allPositive); // true

some()- 至少有一个元素满足条件

filter()- 过滤留下满足条件的元素
map()- 映射/转换每个元素
```

- 数组归并方法 `reduce()` 方法

```js
// 使用reduce
const sumReduce = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(sumReduce); // 15
```

- **改变原数组的方法**：`fill()`、`pop()`、`push()`、`shift()`、`splice()`、`unshift()`、`reverse()`、`sort()`；

```
array.fill(value, start, end)
// 填充整个数组
const arr1 = new Array(5).fill(0);
console.log(arr1); // [0, 0, 0, 0, 0]
```



- **不改变原数组的方法**：`concat()`、`every()`、`filter()`、`find()`、`findIndex()`、`forEach()`、`indexOf()`、`join()`、`lastIndexOf()`、`map()`、`reduce()`、`reduceRight()`、`slice()`、`some()`。



>增删查改

数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生
影响，哪些方法不会
==增==
下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响

- push()
  `push()`方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
- unshift()
  unshift()在数组开头添加任意多个值，然后返回新的数组长度
- splice()
  传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组
- concat(）
  首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组





==删==

下面三种都会影响原数组，最后一项不影响原数组：

- pop()
  `pop()` 方法用于删除数组的最后一项，同时减少数组的`length` 值，返回被删除的项
- shift()、
  `shift()`方法用于删除数组的第一项，同时减少数组的`length` 值，返回被删除的项
- splice()
  传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组
- slice(）
slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组

==改==
splice
传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响
==查==
即查找元素，返回元素坐标或者元素值

- indexOf()
返回要查找的元素在数组中的位置，如果没找到则返回 -1
- includes()
返回要查找的元素在数组中的位置，找到返回`true`，否则`false`
- find()
返回第一个匹配的元素
>排序方法


数组有两个方法可以用来对元素重新排序：
- reverse()
顾名思义，将数组元素方向反转
- sort()
sort()方法接受一个比较函数，用于判断哪个值应该排在前面
```js
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
let values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); // 0,1,5,10,15
```


>转换方法

join
join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串

```js
let colors = ["red", "green", "blue"];
alert(colors.join(",")); // red,green,blue
alert(colors.join("||")); // red||green||blue
```

>迭代方法
- some()
对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let someResult = numbers.some((item, index, array) => item > 2);
console.log(someResult) // true
```
- every()
对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let everyResult = numbers.every((item, index, array) => item > 2);
console.log(everyResult) // false
```
- forEach()
没有返回值
- filter()
对数组每一项都运行传入的函数，函数返回 `true` 的项会组成数组之后返回
- map()
对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组



```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let mapResult = numbers.map((item, index, array) => item * 2);
console.log(mapResult) // 2,4,6,8,10,8,6,4,2
```

### 3.字符串常用的方法
==增==
这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作
除了常用`+`以及`${}`进行字符串拼接之外，还可通过`concat`

```js
concat
let stringValue = "hello ";
let result = stringValue.concat("world");
console.log(result); // "hello world"
console.log(stringValue); // "hello"
```

==删==
这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作
常见的有：

- slice()
- substr()
- substring()

这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。

```js
let stringValue = "hello world";
console.log(stringValue.slice(3)); // "lo world"
console.log(stringValue.substring(3)); // "lo world"
console.log(stringValue.substr(3)); // "lo world"
console.log(stringValue.slice(3, 7)); // "lo w"
console.log(stringValue.substring(3,7)); // "lo w"
console.log(stringValue.substr(3, 7)); // "lo worl"
```
==改==
这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作
常见的有：

- trim()、trimLeft()、trimRight()
删除前、后或前后所有空格符，再返回新的字符串
```js
let stringValue = " hello world ";
let trimmedStringValue = stringValue.trim();
console.log(stringValue); // " hello world "
console.log(trimmedStringValue); // "hello world"
```
- repeat()
```js
let stringValue = "na ";
let copyResult = stringValue.repeat(2) // na na 
```
- padStart()、padEnd()
复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件
```js
let stringValue = "foo";
console.log(stringValue.padStart(6)); // " foo"
console.log(stringValue.padStart(9, ".")); // "......foo"
```
- toLowerCase()、 toUpperCase()



==查==
除了通过索引的方式获取字符串的值，还可通过：

- chatAt()
返回给定索引位置的字符，由传给方法的整数参数指定

```js
let message = "abcde";
console.log(message.charAt(2)); // "c"
```
- indexOf()
从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）

```js
let stringValue = "hello world";
console.log(stringValue.indexOf("o")); // 4
```
- startWith()
- includes()
从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值

```js
let message = "foobarbaz";
console.log(message.startsWith("foo")); // true
console.log(message.startsWith("bar")); // false
console.log(message.includes("bar")); // true
console.log(message.includes("qux")); // false
```
==转换方法==
把字符串按照指定的分割符，拆分成数组中的每一项

```js
let str = "12+23+34"
let arr = str.split("+") // [12,23,34]
```

==模板匹配方法==
针对正则表达式，字符串设计了几个方法：

- match()
接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，返回数组。
```js
let text = "cat, bat, sat, fat";
let pattern = /.at/;
let matches = text.match(pattern);
console.log(matches[0]); // "cat"
```
- search()
接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，找到则返回匹配索引，否则返回 -1

```js
let text = "cat, bat, sat, fat";
let pos = text.search(/at/);
console.log(pos); // 1
```
- replace()
接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）
```js
let text = "cat, bat, sat, fat";
let result = text.replace("at", "ond");
console.log(result); // "cond, bat, sat, fat"
```

### 4. 谈谈js中的类型转换机制
常见的类型转换有：
- 强制转换（显示转换）

- 自动转换（隐式转换）

  

  ==显示转换==
  显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：

- Number()

- parseInt()

- String()

- Boolean(）

**number()**
将任意类型的值转化为数值
先给出类型转换规则：
实践一下：

```js
Number(324) // 324
// 字符串：如果可以被解析为数值，则转换为相应的数值
Number('324') // 324
// 字符串：如果不可以被解析为数值，返回 NaN
Number('324abc') // NaN
// 空字符串转为0
Number('') // 0
// 布尔值：true 转成 1，false 转成 0
Number(true) // 1
Number(false) // 0
// undefined：转成 NaN
Number(undefined) // NaN
// null：转成0
Number(null) // 0
// 对象：通常转换成NaN(除了只包含单个数值的数组)
Number({a: 1}) // NaN
Number([1, 2, 3]) // NaN
Number([5]) // 5
```

从上面可以看到，`Number`转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`
**parseint**
`parseInt`相比`Number`，就没那么严格了，`parseInt`函数逐个解析字符，遇到不能转换的字符就停下来

```js
parseInt('32a3') //32
```

**string**
可以将任意类型的值转化成字符串
实践一下：

```js
// 数值：转为相应的字符串
String(1) // "1"
//字符串：转换后还是原来的值
String("a") // "a"
//布尔值：true转为字符串"true"，false转为字符串"false"
String(true) // "true"
//undefined：转为字符串"undefined"
String(undefined) // "undefined"
//null：转为字符串"null"
String(null) // "null"
//对象
String({a: 1}) // "[object Object]"
String([1, 2, 3]) // "1,2,3"
```

**Boolean**

```js
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```

==隐式转换==
在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？

我们这里可以归纳为两种情况发生隐式转换的场景：

- 比较运算（`==`、`!=`、`>`、`<`）、`if`、`while`需要布尔值地方
- 算术运算（`+`、`-`、`*`、`/`、`%`）

除了上面的场景，还要求运算符两边的操作数不是同一类型
**自动转换为布尔值**
在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用`Boolean`函数

可以得出个小结：
- undefined

- null

- false

- +0

- -0

- NaN

- ""
  除了上面几种会被转化成`false`，其他都换被转化成`true`

  

**自动转换为字符串**

遇到预期为字符串的地方，就会将非字符串的值自动转为字符串

具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串

常发生在`+`运算中，一旦存在字符串，则会进行字符串拼接操作

```js
'5' + 1 // '51'
'5' + true // "5true"
'5' + false // "5false"
'5' + {} // "5[object Object]"
'5' + [] // "5"
'5' + function (){} // "5function (){}"
'5' + undefined // "5undefined"
'5' + null // "5null"
```
**自动转换为数值**
除了`+`有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值

```js
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN
```



###  5.\==和\=\==区别，分别在什么情况下使用

==\==操作符==
等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 `true`

前面文章，我们提到在`JavaScript`中存在隐式转换。等于操作符（\==）在比较中会先进行类型转换，再确定操作数是否相等。

遵循以下规则：

如果任一操作数是布尔值，则将其转换为数值再比较是否相等

```js
let result1 = (true == 1); // true
```

如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等

```js
let result1 = ("55" == 55); // true
```

如果一个操作数是对象，另一个操作数不是，则调用对象的 `valueOf()`方法取得其原始值，再根据前面的规则进行比较

```js
let obj = {valueOf:function(){return 1}}
let result1 = (obj == 1); // true
```

`null`和`undefined`相等

```js
let result1 = (null == undefined ); // true
```

如果有任一操作数是 `NaN` ，则相等操作符返回 `false`

```js
let result1 = (NaN == NaN ); // false
```

如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回`true`

```js
let obj1 = {name:"xxx"}
let obj2 = {name:"xxx"}
let result1 = (obj1 == obj2 ); // false
```

下面进一步做个小结：

- 两个都为简单类型，字符串和布尔值都会转换成数值，再比较
  
- 简单类型与引用类型比较，对象转化成其原始类型的值，再比较
  
- 两个都为引用类型，则比较它们是否指向同一个对象
  
- null 和 undefined 相等
  
- 存在 NaN 则返回 false

==\=\==操作符==
全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 `true`。即类型相同，值也需相同

```
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`undefined` 和 `null` 与自身严格相等

```
let result1 = (null === null)  //true
let result2 = (undefined === undefined)  //false
```

==区别==
相等操作符（\==）会做类型转换，再进行值的比较，全等运算符不会做类型转换

```
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`null` 和 `undefined` 比较，相等操作符（\==）为`true`，全等为`false`

```js
let result1 = (null == undefined ); // true
let result2 = (null  === undefined); // false
```

==总结==
相等运算符隐藏的类型转换，会带来一些违反直觉的结果

```js
'' == '0' // false
0 == '' // true
0 == '0' // true

false == 'false' // false
false == '0' // true

false == undefined // false
false == null // false
null == undefined // true

' \t\r\n' == 0 // true
```

但在比较`null`的情况的时候，我们一般使用相等操作符`==`

```js
const obj = {};

if(obj.x == null){
  console.log("1");  //执行
}
```

等同于下面写法

```js
if(obj.x === null || obj.x === undefined) {
    ...
}
```

使用相等操作符（\==）的写法明显更加简洁了

所以，除了在比较对象属性为`null`或者`undefined`的情况下，我们可以使用相等操作符（\==），其他情况建议一律使用全等操作符（\=\==）

---



### 6. 深拷贝和浅拷贝的区别？如何实现深拷贝？


下面简单实现一个浅拷贝

```js
function shallowClone(obj) {
    const newObj = {};
    for(let prop in obj) {
        if(obj.hasOwnProperty(prop)){
            newObj[prop] = obj[prop];
        }
    }
    return newObj;
}
只是复制了地址，如果对深层次的数据进行修改，源数据也会发生变化。
只是复制了第一层属性/元素的值引用，而不复制嵌套对象或数组的内部结构。
```

hasOwnProperty 是 JavaScript 中 **对象原型方法**（Object.prototype.hasOwnProperty），它的作用是：

> **判断一个属性是否是对象“自身的属性”（own property），而不是从原型链上继承来的。**

JavaScript 是基于**原型继承**的语言，对象可以从原型链上继承属性。

```
const obj = { name: 'Alice' };
```
obj 除了有 name 属性外，还能访问 toString、hasOwnProperty 等方法，这些是继承自 Object.prototype 的。

```
'name' in obj;           // true  ← 自身属性
'toString' in obj;       // true  ← 继承来的！
```
使用 in 操作符**无法区分**是自身属性还是继承属性。
而 hasOwnProperty **只检查自身**：

```
obj.hasOwnProperty('name');       // true
obj.hasOwnProperty('toString');   // false ←--不是自身的
```

在`JavaScript`中，存在浅拷贝的现象有：

- `Object.assign`
- `Array.prototype.slice()`, `Array.prototype.concat()`
- 使用拓展运算符实现的复制

Object.assign

```
var obj = {
    age: 18,
    nature: ['smart', 'good'],
    names: {
        name1: 'fx',
        name2: 'xka'
    },
    love: function () {
        console.log('fx is a great girl')
    }
}
var newObj = Object.assign({}, fxObj);
newObj.nature[0]='abc'
console.log(obj.nature[0]) //'abc',被修改了。
```

slice()

```
const arr = [1, { name: 'Alice' }, [10, 20]]; //这是一个数组，不是类数组对象

const copy = arr.slice();
copy[1].name = 'Bob'; console.log(arr[1].name); // 'Bob' ← 原数组也被改了！

```

concat()

```
const arr = [1, { age: 25 }];
const copy = arr.concat(); // 等价于 [].concat(arr)
copy[1].age = 30; 
console.log(arr[1].age); // 30 ← 共享引用

```

拓展运算符

```
const obj = { a: 1, b: { x: 10 }, c: [1, 2] };
const copy = { ...obj };
copy.b.x = 99; 
console.log(obj.b.x); // 99 ← 原对象被改了！

```

==深拷贝==
深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

- _.cloneDeep()
  
- jQuery.extend()
  
- JSON.stringify()
  
- 手写循环递归
  

**\_cloneDeep**

```js
const _ = require('lodash');
//- 引入 **Lodash** 库，一个流行的 JavaScript 工具库。
- _ 是 Lodash 的默认导出对象，包含大量实用函数。
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
```

**jQuery.extend()**

```js
const $ = require('jquery');
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

**JSON.stringfy()**

```js
const obj2=JSON.parse(JSON.stringify(obj1））
//先把对象转换为JSON字符串，序列化
//在把JSON字符串转换为js对象，反序列化
//得到一个与 obj1 结构相同、但完全独立的新对象（深拷贝）
```

但是这种方式存在弊端，会忽略`undefined`、`symbol`和`函数`
```js
const obj = {
    name: 'A',
    name1: undefined,
    name3: function() {},
    name4:  Symbol('A')
}
const obj2 = JSON.parse(JSON.stringify(obj));
console.log(obj2); // {name: "A"}
```

**递归循环**
```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```

###  7. 什么是闭包？应用场景有哪些？

==什么是闭包==

在一个函数环境中，，闭包=函数+词法环境。
在 JavaScript（前端最常用的语言）里，**闭包（Closure）**指的是 **函数 + 它能够访问的外层函数作用域中的变量** 的组合。

**先总结：**

**闭包优点：**

- 创建全局私有变量，避免变量全局污染
- 可以实现封装、缓存等

**闭包缺点：**

- 创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出
  - **解决：** 在不需要使用的时候把变量设为`null`

**使用场景：**

- 用于创建全局私有变量
- 封装类和模块
- 实现函数柯里化

闭包一定会造成内存泄漏吗？

闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。只要合理的使用闭包，就不会造成内存泄漏。







它的核心价值在于：

1. **数据私有化 / 封装** 让变量只能被内部函数访问，外部无法直接读取或修改，实现“私有成员”。
2. **保持状态（记忆功能）** 每次调用闭包函数时，都能“记住”之前创建时的环境变量，实现计数器、缓存、配置等持久化状态。
3. **模块化 / 避免全局污染** 通过立即执行函数（IIFE）或模块模式，把实现细节隐藏，只暴露必要的 API。
4. **实现柯里化、函数工厂、事件绑定、回调等高级模式**

1.数据私有化,保持状态

```js
function createCounter() {
  let count = 0;               // 私有变量
  return function () {         // 闭包
    return ++count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// 外部无法直接访问 count
console.log(typeof count); // undefined
```
**解释**

- count 只在 createCounter 的词法环境中。
- 返回的匿名函数形成了闭包，**记住**了 count。
- 每次调用 counter() 都会操作同一个 count，实现私有计数器。

2.函数工厂（柯里化）

```js
function makeAdder(base) {
  return function (x) {
    return base + x;   // 记住 base
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(3));  // 8
console.log(add10(3)); // 13
```

3.模块函数
```JS
const MyModule = (function () {
  // 私有数据
  const API_KEY = 'abc123';
  const cache = {};

  // 私有方法
  function _fetch(url) {
    if (cache[url]) return cache[url];
    // 模拟异步请求
    return fetch(url + '?key=' + API_KEY).then(res => {
      cache[url] = res;
      return res;
    });
  }

  // 暴露的公共 API
  return {
    get: _fetch,
    clearCache() {
      for (let k in cache) delete cache[k];
    }
  };
})();

MyModule.get('/data').then(console.log);
MyModule.clearCache();
```


==应用场景==


| 作用          | 典型场景                  | 关键点                 |
| ------------- | ------------------------- | ---------------------- |
| **数据私有**  | 计数器、配置对象          | 外部不可直接访问变量   |
| **保持状态**  | 防抖/节流、缓存           | 闭包记住上一次调用环境 |
| **模块化**    | IIFE 模块、ES6 前私有成员 | 只暴露 API             |
| **循环/事件** | for 循环绑定事件          | 用闭包捕获每次迭代的值 |

==会不会造成内存泄露==
闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。如果后续还需要使用这个闭包变量，那么就没有造成泄露。

---



### 8.谈谈你对作用域链的理解

==一、作用域==
作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合
换句话说，作用域决定了代码区块中变量和其他资源的可见性
举个例子
```
function myFunction() {
    let inVariable = "函数内部变量";
}
myFunction();//要先执行这个函数，否则根本不知道里面是啥
console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined
```

上述例子中，函数`myFunction`内部创建一个`inVariable`变量，当我们在全局访问这个变量的时候，系统会报错
这就说明我们在全局是无法获取到（闭包除外）函数内部的变量
我们一般将作用域分成：

- 全局作用域
  
- 函数作用域
  
- 块级作用域
**1.全局作用域**

任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问
```
// 全局变量
var greeting = 'Hello World!';
function greet() {
  console.log(greeting);
}
// 打印 'Hello World!'
greet();
```

**2.函数作用域**

函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问

```
function greet() {
  var greeting = 'Hello World!';
  console.log(greeting);
}
// 打印 'Hello World!'
greet();
// 报错： Uncaught ReferenceError: greeting is not defined
console.log(greeting);
```

可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域

**3.块级作用域**

ES6引入了`let`和`const`关键字,和`var`关键字不同，在大括号中使用`let`和`const`声明的变量存在于块级作用域中。在大括号之外不能访问这些变量

```
{
  // 块级作用域中的变量
  let greeting = 'Hello World!';
  var lang = 'English';
  console.log(greeting); // Prints 'Hello World!'
}
// 变量 'English'
console.log(lang);
// 报错：Uncaught ReferenceError: greeting is not defined
console.log(greeting);
```

==二、词法作用域==
词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，`JavaScript` 遵循的就是词法作用域。函数访问外部变量时，依据的是函数定义时的位置，而不是调用时的位置。

```
var a = 2;
function foo(){
    console.log(a)
}
function bar(){
    var a = 3;
    foo(); //2
}
bar()
```

由于`JavaScript`遵循词法作用域，相同层级的 `foo` 和 `bar` 就没有办法访问到彼此块作用域中的变量，所以输出2
==三、作用域链==
当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域

如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错

这里拿《你不知道的Javascript(上)》中的一张图解释：

把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域。

变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止

下面代码演示下：

```
var sex = '男';
function person() {
    var name = '张三';
    function student() {
        var age = 18;
        console.log(name); // 张三
        console.log(sex); // 男 
    }
    student();
    console.log(age); // Uncaught ReferenceError: age is not defined
}
person();
```

上述代码主要主要做了以下工作：

- `student`函数内部属于最内层作用域，找不到`name`，向上一层作用域`person`函数内部找，找到了输出“张三”
- `student`内部输出`sex`时找不到，向上一层作用域`person`函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男”
- 在`person`函数内部输出`age`时找不到，向上一层作用域找，即全局作用域，还是找不到则报错



---


### 9.JS原型、原型链？有什么特点？

==1.原型==
`JavaScript` 常被描述为一种基于原型的语言——每个对象拥有一个原型对象

当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的`prototype`属性上，而非实例对象本身

下面举个例子：

函数可以有属性。 每个函数都有一个特殊的属性叫作原型`prototype`

```
function doSomething(){}
console.log( doSomething.prototype );
```

控制台输出

```
{
    constructor: ƒ doSomething(),
    __proto__: {
        constructor: ƒ Object(),
        hasOwnProperty: ƒ hasOwnProperty(),
        isPrototypeOf: ƒ isPrototypeOf(),
        propertyIsEnumerable: ƒ propertyIsEnumerable(),
        toLocaleString: ƒ toLocaleString(),
        toString: ƒ toString(),
        valueOf: ƒ valueOf()
    }
}
```

上面这个对象，就是大家常说的原型对象

可以看到，原型对象有一个自有属性`constructor`，这个属性指向该函数，如下图关系展示
![image-20251116222532494](D:\A_keep_learning\markdown笔记\前端\assets\image-20251116222532494.png)





==2.原型链==
原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法

在对象实例和它的构造器之间建立一个链接（它是`__proto__`属性，是从构造函数的`prototype`属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法

下面举个例子：

```
function Person(name) {
    this.name = name;
    this.age = 18;
    this.sayName = function() {
        console.log(this.name);
    }
}
// 第二步 创建实例
var person = new Person('person')
```



下面分析一下：

- 构造函数`Person`存在原型对象`Person.prototype`
  
- 构造函数生成实例对象`person`，`person`的`__proto__`指向构造函数`Person`原型对象
  
- `Person.prototype.__proto__` 指向内置对象，因为 `Person.prototype` 是个对象，默认是由 `Object`函数作为类创建的，而 `Object.prototype` 为内置对象
  
- `Person.__proto__` 指向内置匿名函数 `anonymous`，因为 Person 是个函数对象，默认由 Function 作为类创建
  
- `Function.prototype` 和 `Function.__proto__`同时指向内置匿名函数 `anonymous`，这样原型链的终点就是 `null`

==3.总结==
下面首先要看几个概念：

`__proto__`作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的

每个对象的`__proto__`都是指向它的构造函数的原型对象`prototype`的

```
person1.__proto__ === Person.prototype
```

构造函数是一个函数对象，是通过 `Function`构造器产生的

```
Person.__proto__ === Function.prototype
```

原型对象本身是一个普通对象，而普通对象的构造函数都是`Object`

```
Person.prototype.__proto__ === Object.prototype
```

刚刚上面说了，所有的构造器都是函数对象，函数对象都是 `Function`构造产生的

```
Object.__proto__ === Function.prototype
```

`Object`的原型对象也有`__proto__`属性指向`null`，`null`是原型链的顶端

```
Object.prototype.__proto__ === null
```

下面作出总结：

- 一切对象都是继承自`Object`对象，`Object` 对象直接继承根源对象`null`
  
- 一切的函数对象（包括 `Object` 对象），都是继承自 `Function` 对象
  
- `Object` 对象直接继承自 `Function` 对象
  
- `Function`对象的`__proto__`会指向自己的原型对象，最终还是继承自`Object`对象

---



### 10.JS如何实现继承

==1.继承是什么？==
继承（inheritance）是面向对象软件技术当中的一个概念。
如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类”
- 继承的优点
继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码
在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能
虽然`JavaScript`并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富
关于继承，我们举个形象的例子：
定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等

```
class Car{
    constructor(color,speed){
        this.color = color
        this.speed = speed
        // ...
    }
}
```

由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱

```
// 货车
class Truck extends Car{
    constructor(color,speed){
        super(color,speed)
        this.Container = true // 货箱
    }
}
```

这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性

在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法

```
class Truck extends Car{
    constructor(color,speed){
        super(color,speed)
        this.color = "black" //覆盖
        this.Container = true // 货箱
    }
}
```

从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系
==2.实现方式==

下面给出`JavaScripy`常见的继承方式：

- 原型链继承
- 构造函数继承（借助 call）
- 组合继承
- 原型式继承
- 寄生式继承
- 寄生组合式继承


> 原型链继承

原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针

举个例子

```
 function Parent() {
    this.name = 'parent1';
    this.play = [1, 2, 3]
  }
  function Child() {
    this.type = 'child2';
  }
  //这里的指的就是上面的Child函数，也就是构造方法。
  Child.prototype = new Parent();
  console.log(new Child())
```

![image-20251116222635970](D:\A_keep_learning\markdown笔记\前端\assets\image-20251116222635970.png)
上面代码看似没问题，实际存在潜在问题

```
var s1 = new Child();
var s2 = new Child();
s1.play.push(4);
console.log(s1.play, s2.play); // [1,2,3,4]
```

改变`s1`的`play`属性，会发现`s2`也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的


>构造函数继承（借助 call）

借助 `call`调用`Parent`函数

```
function Parent(){
    this.name = 'parent1';
}
//给原型对象设置了一个属性方法getName
Parent.prototype.getName = function () {
    return this.name;
}

function Child(){
//- **在 Child 内部，把 Parent 当成普通函数执行，但强制把 Parent 里的 `this` 指向当前正在创建的 Child 实例**。
//结果：每个 Child 实例都会**复制一份** `name` 属性，**不会共享**。
    Parent.call(this);
    this.type = 'child'
}

let child = new Child();
console.log(child);  // 没问题
//`child` 自己身上确实有了 `name`，但**并没有继承 Parent.prototype 上的方法**。
console.log(child.getName());  // 会报错
```

借用构造函数继承**只能“搬”父类构造函数里的实例属性**，**搬不到父类原型上的方法**；  

因此**引用属性不共享**是优点，**原型方法丢失**是缺点。

相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法


>组合继承

将构造函数继承和原型链继承组合到一起
```js
┌-------- ① 定义部分 --------┐
function Parent(){
    this.name   = 'parent';
    this.play   = [1,2,3];     // 引用类型
}
Parent.prototype.getName = function(){
    return this.name;
};

function Child(){
    Parent.call(this);        // ② 第二次调用 —— 为每个实例复制一份 name + play,覆盖了第一次调用的原型链提供的name和play，从此属性不再共享了。
    this.type = 'child3';
}

Child.prototype = new Parent();  // ① 第一次调用 —— 为原型链提供 getName,name,play
//构造函数在初始化的时候，会默认分配一个原型对象，该原型对象内容为{constructor:Child...}
//现在我们强行改变了原型对象为Parent实例，现在新的原型对象内容为Child.prototype也就是parent实例对象，实例对象没有constructor属性，这里我们就手动创建一个，让其纠正为Child，而不是通过--proto--原型链
//找到parent的构造函数
Child.prototype.constructor = Child;

┌-------- ③ 使用部分 --------┐
var s3 = new Child();
var s4 = new Child();
s3.play.push(4);
console.log(s3.play); // [1,2,3,4]
console.log(s4.play); // [1,2,3]   ←— 互不影响 ✅
console.log(s3.getName()); // 'parent' ✅
```

把“属性”和“方法”拆成两条跑道

| 要继承的东西                                                 | 存在位置                | 该用哪种手段                             |
| :----------------------------------------------------------- | :---------------------- | :--------------------------------------- |
| **实例属性**（name、play 等）                                | 父类构造函数体内        | 借用构造函数  <br>`Parent.call(this)`    |
| **原型方法**（getName 等）                                   | 父类 `Parent.prototype` | 原型链继承  <br>`Child.prototype = 对象` |
| 这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到`Parent` 执行了两次，造成了多构造一次的性能开销 |                         |                                          |


> 原型式继承

这里主要借助`Object.create`方法实现普通对象的继承

```
let parent = {
    name: "parent",
    friends: ["p1", "p2", "p3"],
    getName: function() {
      return this.name;
    }
  };

  let person = Object.create(parent);
  //相当于
  //let person={}
  //person.__proto__=parent
  
  person.name = "tom";
  person.friends.push("jerry");

  let person = Object.create(parent);
  person.friends.push("lucy");

  console.log(person.name); // tom
  console.log(person.name === person.getName()); // true
  console.log(person.name); // parent
  console.log(person.friends); // ["p1", "p2", "p3","jerry","lucy"]
  console.log(person.friends); // ["p1", "p2", "p3","jerry","lucy"]
```

这种继承方式的缺点也很明显，因为`Object.create`方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能

Object.create 把**普通对象直接当原型**；  

值类型属性“读共享、写复制”，引用类型属性“读写都共享”；  

想不互串，就要在子对象里**重新赋值整个数组**，而不是**原地修改**。
想要让friends也独立，这样做

```javascript
let person4 = Object.create(parent);
person4.friends = [...parent.friends]; // 复制一份再改
person4.friends.push('jerry');
```


>寄生式继承


寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法
```js
let parent = {
    name: 'parent',
    friends: ['p1','p2','p3'],
    getName() { return this.name; }
};

function clone(original) {
    // ① 浅拷贝：新建对象，并把 original 设为其原型
    let clone = Object.create(original);

    // ② 增强：给这个副本额外挂一个方法
    clone.getFriends = function () {
        return this.friends;   // 这里的 this 指向运行时调用者
    };

    return clone;              // 返回“加强版”对象
}

let person = clone(parent);
```

- `getName` 沿原型链找到 `parent.getName`
  
- `getFriends` 是**直接挂在 person 自己身上**的方法，因此**每个克隆体都有一份新函数**（内存开销比原型方式大）。

```javascript
console.log(person.getName());    // parent
console.log(person.getFriends()); // ["p1","p2","p3"]
```
好绕呀，没看明白。


>寄生组合式继承

寄生组合式继承，借助解决普通对象的继承问题的`Object.create` 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式

```
function clone (parent, child) {
    // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
}

function Parent6() {
    this.name = 'parent6';
    this.play = [1, 2, 3];
}
Parent6.prototype.getName = function () {
    return this.name;
}
function Child6() {
    Parent6.call(this);
    this.friends = 'child5';
}

clone(Parent6, Child6);

Child6.prototype.getFriends = function () {
    return this.friends;
}

let person6 = new Child6();
console.log(person6); //{friends:"child5",name:"child5",play:[1,2,3],__proto__:Parent6}
console.log(person6.getName()); // parent6
console.log(person6.getFriends()); // child5
```

可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题

文章一开头，我们是使用`ES6` 中的`extends`关键字直接实现 `JavaScript`的继承

```
class Person {
  constructor(name) {
    this.name = name
  }
  // 原型方法
  // 即 Person.prototype.getName = function() { }
  // 下面可以简写为 getName() {...}
  getName = function () {
    console.log('Person:', this.name)
  }
}
class Gamer extends Person {
  constructor(name, age) {
    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
    super(name)
    this.age = age
  }
}
const asuna = new Gamer('Asuna', 20)
asuna.getName() // 成功访问到父类的方法
```

利用`babel`工具进行转换，我们会发现`extends`实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。
晕

---



### 11.instanceof 运算符的实现原理及实现
该运算符通过原型链检查判断对象是否属于特定类型。当执行 `key instanceof Array` 返回 `true` 时，说明变量 `key` 的原型链中存在 `Array.prototype`，即 `key` 是通过数组构造函数创建的实例。

`instanceof` 原理一句话：

> **不断拿右边构造函数的原型（`prototype`），去跟左边对象的整条原型链（`__proto__`）做全等比对**，只要有一次命中就返回 `true`，走到 `null` 还没命中就返回 `false`。

模拟实现（ES5 版，20 行不到）

```javascript
function myInstanceOf(left, right) {
  // 基本类型直接出局
  if (left === null || (typeof left !== 'object' && typeof left !== 'function')) {
    return false;
  }

  // 取目标原型
  const target = right.prototype;

  // 兼容 IE 非标准 __proto__
  left = left.__proto__;

  while (left !== null) {
    if (left === target) return true;
    left = left.__proto__; // 继续往上爬
  }
  return false;
}


```



快速验证

```javascript
function Foo() {}
const f = new Foo();

console.log(myInstanceOf(f, Foo));      // true
console.log(myInstanceOf(f, Object));   // true
console.log(myInstanceOf([], Array));   // true
console.log(myInstanceOf(123, Number)); // false
```

---

### 12.typeof 和 instanceof 区别

一句话先给结论：  

**`typeof` 只能告诉你“基本类型”或“是不是函数”；**  

**`instanceof` 只能告诉你“对象是谁构造的，沿着原型链找”。**

| 对比维度     | typeof                                                       | instanceof                                      |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------- |
| 返回值       | `'string' \| 'number' \| 'boolean' \| 'undefined' \| 'function' \| 'object' \| 'symbol' \| 'bigint'` | `true / false`                                  |
| 判断依据     | 机器码低位（Tag）                                            | 原型链（`__proto__` 能否找到 `Ctor.prototype`） |
| 适合基本类型 | ✅ 精准                                                       | ❌ 报错或 false（非对象）                        |
| 适合对象细分 | ❌ 统称 `'object'` 或 `'function'`                            | ✅ 精准识别数组、日期、自定义类等                |
| 常见坑       | `typeof null === 'object'`                                   | 跨 iframe 原型链断裂会 false                    |

```javascript
typeof 42;                           // 'number'
typeof 'abc';                        // 'string'
typeof null;                         // 'object'（历史 bug）
typeof [];                           // 'object'
typeof function f(){};               // 'function'

[] instanceof Array;                 // true
[] instanceof Object;                // true
new Date() instanceof Date;          // true
/abc/ instanceof RegExp;             // true
```

------------------------------------------------
一句话总结（写卷子上）

> **基本类型用 `typeof`，对象细分用 `instanceof`（例如Object，Arrary，Function，Date，Error，Map，set）；**  
> **两者互补，绝不重叠。**

---

### 13.null和undefined的区别
`Undefined` 和 `Null` 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 `undefined` 和 `null`。

- **undefined** 代表的含义是**未定义**，一般变量**声明了但还没有定义**的时候会返回 `undefined`，`typeof`为`undefined`
- **null** 代表的含义是**空对象**，null主要用于赋值给一些可能会返回对象的变量，作为初始化，`typeof`为`object`



```
null == undefined // true 
null === undefined //false
```

