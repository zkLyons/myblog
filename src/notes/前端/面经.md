# html/css




## JavaScript

### 1.说说JavaScript中的数据类型？存储上的差别？
在`JavaScript`中，我们可以分成两种类型：
- 基本类型
- 复杂类型
两种类型的区别是：存储位置不同
==基本类型==
基本类型主要为以下6种：

- Number
- String
字符串可以使用双引号（"）、单引号（'）或反引号（\`）标示，字符串是不可变的，意思是一旦创建，它们的值就不能变了
- Boolean
`Boolean`（布尔值）类型有两个字面值： `true` 和`false`,通过`Boolean`可以将其他类型的数据转化成布尔值
- Undefined
`Undefined` 类型只有一个值，就是特殊值 `undefined`。当使用 `var`或 `let`声明了变量但没有初始化时，就相当于给变量赋予了 `undefined`值。
包含`undefined` 值的变量跟未定义变量是有区别的

```js
let message; // 这个变量被声明了，只是值为 undefined

console.log(message); // "undefined"
console.log(age); // 没有声明过这个变量，报错
```
- null
`Null`类型同样只有一个值，即特殊值 `null`,逻辑上讲， null 值表示一个空对象指针
- symbol

他可以最为唯一的对象属性名称，作为 Symbol **最重要**的用途。由于每个 Symbol 都是唯一的，可以避免属性名冲突。

**场景：** 为对象添加"元数据"或"隐藏属性"

```
// 不同的库或模块可能都想给对象添加属性
const user = { name: 'Alice' };

// 模块A想添加一个标识
const MODULE_A_FLAG = Symbol('moduleA');
user[MODULE_A_FLAG] = true;

// 模块B也想添加类似的标识
const MODULE_B_FLAG = Symbol('moduleB'); 
user[MODULE_B_FLAG] = 'processed';

// 两个属性不会冲突，即使描述相同也不会冲突
const ANOTHER_FLAG = Symbol('moduleA'); // 描述相同但Symbol不同
user[ANOTHER_FLAG] = 'another';

console.log(user);
//控制台输出的信息可以观察到，第一个和第三个描述key都是一样的，但是实际上他们是完全独立的，
// {
//   name: 'Alice',
//   [Symbol(moduleA)]: true,
//   [Symbol(moduleB)]: 'processed',
//   [Symbol(moduleA)]: 'another'
// }
//对于同名key该如何访问呢？
console.log(user[MODULE_A_FLAG]) //true
console.log(user[ANOTHER_FLAG])  //another
```





==引用类型==
复杂类型统称为`Object`，我们这里主要讲述下面三种：

- Object
- Array
- Function

==存储区别==
基本数据类型和引用数据类型存储在内存中的位置不同：

- 基本数据类型存储在栈中    
- 引用类型的对象存储于堆中



1. **基本数据类型 (Primitives):**
   - 存在栈里。
   - `let a = 10;` 栈上的 `a` 变量就**直接**保存着 `10` 这个**值**。
2. **引用数据类型 (References):**
   - **地址**在栈里。
   - **值**（即对象 `{...}` 或数组 `[...]` 本身）在堆里。
   - `let obj = { name: 'Tom' };` 栈上的 `obj` 变量保存的是一个**地址**（比如 `0x1A2B`），这个地址指向堆内存中存储 `{ name: 'Tom' }` 的那个位置。



- **栈 (Stack)** 是高度有序的，必须严格遵循**后进先出 (LIFO)** 的规则来分配和释放，就像叠盘子，非常高效。
- **堆 (Heap)** 就像一个大仓库，当你需要存东西（创建对象）时，系统就在仓库里找个**大小足够的空位**把东西放进去，它不需要按顺序放。因此，它的内存分配是**动态**且相对**无序**的。



==小结==

- 声明变量时不同的内存地址分配：
    - 简单类型的值存放在栈中，在栈中存放的是对应的值
    - 引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址
- 不同的类型数据导致赋值变量时的不同：
    - 简单类型赋值，是生成相同的值，两个对象对应不同的地址
    - 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象



### 2.数组常用的方法有哪些

现总结：
- 数组和字符串的转换方法：`toString()`、`toLocalString()`、`join()` 其中 `join()` 方法可以指定转换为字符串时的分隔符。

```js
console.log(num.toString()); // "123"
//返回对象的本地化字符串表示，根据语言环境和地区设置格式化。
const number = 1234567.89;
console.log(number.toString()); // "1234567.89"
console.log(number.toLocaleString()); // 中文环境："1,234,567.89"
console.log(number.toLocaleString('de-DE')); // 德语环境："1.234.567,89"
console.log(number.toLocaleString('ar-EG')); // 阿拉伯语环境："١٬٢٣٤٬٥٦٧٫٨٩"
```



- 数组尾部操作的方法 `pop()` 和 `push()`，`push` 方法可以传入多个参数。

- 数组首部操作的方法 `shift()` 和 `unshift()` ，重排序的方法 `reverse()` 和 `sort()`，`sort()` 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。

- 数组连接的方法 `concat()` ，返回的是拼接好的数组，不影响原数组。

- 数组截取办法 `slice()`，用于截取数组中的一部分返回，不影响原数组。

- 数组插入方法 `splice()`，影响原数组查找特定项的索引的方法`indexOf()` 和 `lastIndexOf()` ，迭代方法 `every()`、`some()`、`filter()`、`map()` 和`forEach()`方法

```
//every用于判断元素是否全部都满足条件，任何一个不满足就返回false
const numbers1 = [1, 2, 3, 4, 5];
const allPositive = numbers1.every(num => num > 0);
console.log(allPositive); // true

some()- 至少有一个元素满足条件

filter()- 过滤留下满足条件的元素
map()- 映射/转换每个元素
```

- 数组归并方法 `reduce()` 方法

```js
// 使用reduce
const sumReduce = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(sumReduce); // 15
```

- **改变原数组的方法**：`fill()`、`pop()`、`push()`、`shift()`、`splice()`、`unshift()`、`reverse()`、`sort()`；

```
array.fill(value, start, end)
// 填充整个数组
const arr1 = new Array(5).fill(0);
console.log(arr1); // [0, 0, 0, 0, 0]
```



- **不改变原数组的方法**：`concat()`、`every()`、`filter()`、`find()`、`findIndex()`、`forEach()`、`indexOf()`、`join()`、`lastIndexOf()`、`map()`、`reduce()`、`reduceRight()`、`slice()`、`some()`。



>增删查改

数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生
影响，哪些方法不会
==增==
下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响

- push()
  `push()`方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
- unshift()
  unshift()在数组开头添加任意多个值，然后返回新的数组长度
- splice()
  传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组
- concat(）
  首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组





==删==

下面三种都会影响原数组，最后一项不影响原数组：

- pop()
  `pop()` 方法用于删除数组的最后一项，同时减少数组的`length` 值，返回被删除的项
- shift()、
  `shift()`方法用于删除数组的第一项，同时减少数组的`length` 值，返回被删除的项
- splice()
  传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组
- slice(）
slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组

==改==
splice
传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响
==查==
即查找元素，返回元素坐标或者元素值

- indexOf()
返回要查找的元素在数组中的位置，如果没找到则返回 -1
- includes()
返回要查找的元素在数组中的位置，找到返回`true`，否则`false`
- find()
返回第一个匹配的元素
>排序方法


数组有两个方法可以用来对元素重新排序：
- reverse()
顾名思义，将数组元素方向反转
- sort()
sort()方法接受一个比较函数，用于判断哪个值应该排在前面
```js
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
let values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); // 0,1,5,10,15
```


>转换方法

join
join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串

```js
let colors = ["red", "green", "blue"];
alert(colors.join(",")); // red,green,blue
alert(colors.join("||")); // red||green||blue
```

>迭代方法
- some()
对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let someResult = numbers.some((item, index, array) => item > 2);
console.log(someResult) // true
```
- every()
对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let everyResult = numbers.every((item, index, array) => item > 2);
console.log(everyResult) // false
```
- forEach()
没有返回值
- filter()
对数组每一项都运行传入的函数，函数返回 `true` 的项会组成数组之后返回
- map()
对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组



```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let mapResult = numbers.map((item, index, array) => item * 2);
console.log(mapResult) // 2,4,6,8,10,8,6,4,2
```

### 3.字符串常用的方法
==增==
这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作
除了常用`+`以及`${}`进行字符串拼接之外，还可通过`concat`

```js
concat
let stringValue = "hello ";
let result = stringValue.concat("world");
console.log(result); // "hello world"
console.log(stringValue); // "hello"
```

==删==
这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作
常见的有：

- slice()
- substr()
- substring()

这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。

```js
let stringValue = "hello world";
console.log(stringValue.slice(3)); // "lo world"
console.log(stringValue.substring(3)); // "lo world"
console.log(stringValue.substr(3)); // "lo world"
console.log(stringValue.slice(3, 7)); // "lo w"
console.log(stringValue.substring(3,7)); // "lo w"
console.log(stringValue.substr(3, 7)); // "lo worl"
```
==改==
这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作
常见的有：

- trim()、trimLeft()、trimRight()
删除前、后或前后所有空格符，再返回新的字符串
```js
let stringValue = " hello world ";
let trimmedStringValue = stringValue.trim();
console.log(stringValue); // " hello world "
console.log(trimmedStringValue); // "hello world"
```
- repeat()
```js
let stringValue = "na ";
let copyResult = stringValue.repeat(2) // na na 
```
- padStart()、padEnd()
复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件
```js
let stringValue = "foo";
console.log(stringValue.padStart(6)); // " foo"
console.log(stringValue.padStart(9, ".")); // "......foo"
```
- toLowerCase()、 toUpperCase()



==查==
除了通过索引的方式获取字符串的值，还可通过：

- chatAt()
返回给定索引位置的字符，由传给方法的整数参数指定

```js
let message = "abcde";
console.log(message.charAt(2)); // "c"
```
- indexOf()
从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）

```js
let stringValue = "hello world";
console.log(stringValue.indexOf("o")); // 4
```
- startWith()
- includes()
从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值

```js
let message = "foobarbaz";
console.log(message.startsWith("foo")); // true
console.log(message.startsWith("bar")); // false
console.log(message.includes("bar")); // true
console.log(message.includes("qux")); // false
```
==转换方法==
把字符串按照指定的分割符，拆分成数组中的每一项

```js
let str = "12+23+34"
let arr = str.split("+") // [12,23,34]
```

==模板匹配方法==
针对正则表达式，字符串设计了几个方法：

- match()
接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，返回数组。
```js
let text = "cat, bat, sat, fat";
let pattern = /.at/;
let matches = text.match(pattern);
console.log(matches[0]); // "cat"
```
- search()
接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，找到则返回匹配索引，否则返回 -1

```js
let text = "cat, bat, sat, fat";
let pos = text.search(/at/);
console.log(pos); // 1
```
- replace()
接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）
```js
let text = "cat, bat, sat, fat";
let result = text.replace("at", "ond");
console.log(result); // "cond, bat, sat, fat"
```

### 4. 谈谈js中的类型转换机制
常见的类型转换有：
- 强制转换（显示转换）

- 自动转换（隐式转换）

  

  ==显示转换==
  显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：

- Number()

- parseInt()

- String()

- Boolean(）

**number()**
将任意类型的值转化为数值
先给出类型转换规则：
实践一下：

```js
Number(324) // 324
// 字符串：如果可以被解析为数值，则转换为相应的数值
Number('324') // 324
// 字符串：如果不可以被解析为数值，返回 NaN
Number('324abc') // NaN
// 空字符串转为0
Number('') // 0
// 布尔值：true 转成 1，false 转成 0
Number(true) // 1
Number(false) // 0
// undefined：转成 NaN
Number(undefined) // NaN
// null：转成0
Number(null) // 0
// 对象：通常转换成NaN(除了只包含单个数值的数组)
Number({a: 1}) // NaN
Number([1, 2, 3]) // NaN
Number([5]) // 5
```

从上面可以看到，`Number`转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`
**parseint**
`parseInt`相比`Number`，就没那么严格了，`parseInt`函数逐个解析字符，遇到不能转换的字符就停下来

```js
parseInt('32a3') //32
```

**string**
可以将任意类型的值转化成字符串
实践一下：

```js
// 数值：转为相应的字符串
String(1) // "1"
//字符串：转换后还是原来的值
String("a") // "a"
//布尔值：true转为字符串"true"，false转为字符串"false"
String(true) // "true"
//undefined：转为字符串"undefined"
String(undefined) // "undefined"
//null：转为字符串"null"
String(null) // "null"
//对象
String({a: 1}) // "[object Object]"
String([1, 2, 3]) // "1,2,3"
```

**Boolean**

```js
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```

==隐式转换==
在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？

我们这里可以归纳为两种情况发生隐式转换的场景：

- 比较运算（`==`、`!=`、`>`、`<`）、`if`、`while`需要布尔值地方
- 算术运算（`+`、`-`、`*`、`/`、`%`）

除了上面的场景，还要求运算符两边的操作数不是同一类型
**自动转换为布尔值**
在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用`Boolean`函数

可以得出个小结：
- undefined

- null

- false

- +0

- -0

- NaN

- ""
  除了上面几种会被转化成`false`，其他都换被转化成`true`

  

**自动转换为字符串**

遇到预期为字符串的地方，就会将非字符串的值自动转为字符串

具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串

常发生在`+`运算中，一旦存在字符串，则会进行字符串拼接操作

```js
'5' + 1 // '51'
'5' + true // "5true"
'5' + false // "5false"
'5' + {} // "5[object Object]"
'5' + [] // "5"
'5' + function (){} // "5function (){}"
'5' + undefined // "5undefined"
'5' + null // "5null"
```
**自动转换为数值**
除了`+`有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值

```js
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN
```



###  5.\==和\=\==区别，分别在什么情况下使用

==\==操作符==
等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 `true`

前面文章，我们提到在`JavaScript`中存在隐式转换。等于操作符（\==）在比较中会先进行类型转换，再确定操作数是否相等。

遵循以下规则：

如果任一操作数是布尔值，则将其转换为数值再比较是否相等

```js
let result1 = (true == 1); // true
```

如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等

```js
let result1 = ("55" == 55); // true
```

如果一个操作数是对象，另一个操作数不是，则调用对象的 `valueOf()`方法取得其原始值，再根据前面的规则进行比较

```js
let obj = {valueOf:function(){return 1}}
let result1 = (obj == 1); // true
```

`null`和`undefined`相等

```js
let result1 = (null == undefined ); // true
```

如果有任一操作数是 `NaN` ，则相等操作符返回 `false`

```js
let result1 = (NaN == NaN ); // false
```

如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回`true`

```js
let obj1 = {name:"xxx"}
let obj2 = {name:"xxx"}
let result1 = (obj1 == obj2 ); // false
```

下面进一步做个小结：

- 两个都为简单类型，字符串和布尔值都会转换成数值，再比较
  
- 简单类型与引用类型比较，对象转化成其原始类型的值，再比较
  
- 两个都为引用类型，则比较它们是否指向同一个对象
  
- null 和 undefined 相等
  
- 存在 NaN 则返回 false

==\=\==操作符==
全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 `true`。即类型相同，值也需相同

```
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`undefined` 和 `null` 与自身严格相等

```
let result1 = (null === null)  //true
let result2 = (undefined === undefined)  //false
```

==区别==
相等操作符（\==）会做类型转换，再进行值的比较，全等运算符不会做类型转换

```
let result1 = ("55" === 55); // false，不相等，因为数据类型不同
let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同
```

`null` 和 `undefined` 比较，相等操作符（\==）为`true`，全等为`false`

```js
let result1 = (null == undefined ); // true
let result2 = (null  === undefined); // false
```

==总结==
相等运算符隐藏的类型转换，会带来一些违反直觉的结果

```js
'' == '0' // false
0 == '' // true
0 == '0' // true

false == 'false' // false
false == '0' // true

false == undefined // false
false == null // false
null == undefined // true

' \t\r\n' == 0 // true
```

但在比较`null`的情况的时候，我们一般使用相等操作符`==`

```js
const obj = {};

if(obj.x == null){
  console.log("1");  //执行
}
```

等同于下面写法

```js
if(obj.x === null || obj.x === undefined) {
    ...
}
```

使用相等操作符（\==）的写法明显更加简洁了

所以，除了在比较对象属性为`null`或者`undefined`的情况下，我们可以使用相等操作符（\==），其他情况建议一律使用全等操作符（\=\==）

---



### 6. 深拷贝和浅拷贝的区别？如何实现深拷贝？


下面简单实现一个浅拷贝

```js
function shallowClone(obj) {
    const newObj = {};
    for(let prop in obj) {
        if(obj.hasOwnProperty(prop)){
            newObj[prop] = obj[prop];
        }
    }
    return newObj;
}
只是复制了地址，如果对深层次的数据进行修改，源数据也会发生变化。
只是复制了第一层属性/元素的值引用，而不复制嵌套对象或数组的内部结构。
```

hasOwnProperty 是 JavaScript 中 **对象原型方法**（Object.prototype.hasOwnProperty），它的作用是：

> **判断一个属性是否是对象“自身的属性”（own property），而不是从原型链上继承来的。**

JavaScript 是基于**原型继承**的语言，对象可以从原型链上继承属性。

```
const obj = { name: 'Alice' };
```
obj 除了有 name 属性外，还能访问 toString、hasOwnProperty 等方法，这些是继承自 Object.prototype 的。

```
'name' in obj;           // true  ← 自身属性
'toString' in obj;       // true  ← 继承来的！
```
使用 in 操作符**无法区分**是自身属性还是继承属性。
而 hasOwnProperty **只检查自身**：

```
obj.hasOwnProperty('name');       // true
obj.hasOwnProperty('toString');   // false ←--不是自身的
```

在`JavaScript`中，存在浅拷贝的现象有：

- `Object.assign`
- `Array.prototype.slice()`, `Array.prototype.concat()`
- 使用拓展运算符实现的复制

Object.assign

```
var obj = {
    age: 18,
    nature: ['smart', 'good'],
    names: {
        name1: 'fx',
        name2: 'xka'
    },
    love: function () {
        console.log('fx is a great girl')
    }
}
var newObj = Object.assign({}, fxObj);
newObj.nature[0]='abc'
console.log(obj.nature[0]) //'abc',被修改了。
```

slice()

```
const arr = [1, { name: 'Alice' }, [10, 20]]; //这是一个数组，不是类数组对象

const copy = arr.slice();
copy[1].name = 'Bob'; console.log(arr[1].name); // 'Bob' ← 原数组也被改了！

```

concat()

```
const arr = [1, { age: 25 }];
const copy = arr.concat(); // 等价于 [].concat(arr)
copy[1].age = 30; 
console.log(arr[1].age); // 30 ← 共享引用

```

拓展运算符

```
const obj = { a: 1, b: { x: 10 }, c: [1, 2] };
const copy = { ...obj };
copy.b.x = 99; 
console.log(obj.b.x); // 99 ← 原对象被改了！

```

==深拷贝==
深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

- _.cloneDeep()
  
- jQuery.extend()
  
- JSON.stringify()
  
- 手写循环递归
  

**\_cloneDeep**

```js
const _ = require('lodash');
//- 引入 **Lodash** 库，一个流行的 JavaScript 工具库。
- _ 是 Lodash 的默认导出对象，包含大量实用函数。
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
```

**jQuery.extend()**

```js
const $ = require('jquery');
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

**JSON.stringfy()**

```js
const obj2=JSON.parse(JSON.stringify(obj1））
//先把对象转换为JSON字符串，序列化
//在把JSON字符串转换为js对象，反序列化
//得到一个与 obj1 结构相同、但完全独立的新对象（深拷贝）
```

但是这种方式存在弊端，会忽略`undefined`、`symbol`和`函数`
```js
const obj = {
    name: 'A',
    name1: undefined,
    name3: function() {},
    name4:  Symbol('A')
}
const obj2 = JSON.parse(JSON.stringify(obj));
console.log(obj2); // {name: "A"}
```

**递归循环**
```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```

