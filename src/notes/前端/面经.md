# html/css



# JavaScript



# vue

### 1.请系统讲讲 Vue2 与 Vue3 的核心差异（响应式、API 设计、性能与编译器）。



Vue2 和 Vue3 的核心差异主要体现在以下几个方面：



**1. 响应式系统（底层原理的根本性变化）**



| **特性**     | **Vue2**                                                     | **Vue3**                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **底层实现** | 使用 **`Object.defineProperty`**                             | 使用 **`Proxy`** API                                         |
| **检测限制** | 无法监听对象属性的**新增**和**删除**，需要使用 `$set` 或 `$delete` 。 | 可以直接监听对象属性的**新增**和**删除**，不需要特殊 API。   |
| **数组检测** | 需要重写数组原型方法（如 `push`, `pop` ,`shift`,`unshift`,`splice`,`sort`,`reverse`）。 | `可以通过 `Proxy` 直接拦截数组操作，支持数组索引访问和修改。` |

**`Proxy` 的优势：** 提供了完整的对象代理能力，性能更好，且解决了 Vue2 中无法追踪新增/删除属性的痛点。

```
<template>
  <div>
    <h1>个人信息</h1>
    <h2>name:{{ student.name }}</h2>
    <h2 v-show="student.sex">sex:{{ student.sex }}</h2>
    <h2 v-show="student.height">height:{{ student.height }}</h2>
    <h2>hobby:{{ student.hobby }}</h2>

    <button @click="addproperty">添加身高属性</button>
    <button @click="deleteproperty">删除性别属性</button>
    <button @click="changeproperty">修改爱好属性</button>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      student: {
        name: "zk",
        sex: "male",
        hobby: ["drink", "walk"],
      },
    };
  },
  // 3_src_vue2响应式原理
  methods: {
    addproperty() {
      console.log(this.student);
      // 在vue2环境下，添加成功，但是页面并不会响应更新
      console.log(this.student.height);
      // this.student.height = "170";
      console.log(this.student.height);
      // 解决办法,记得在vue2环境下执行
      this.$set(this.student, "height", 170);
      // 问题：使用数组下标添加不会响应生效
      // this.student.hobby[0] = "play";
      // 解决
      this.student.hobby.splice(0, 0, "paly");
    },
    changeproperty() {
      // 问题：使用数组下标添加不会响应生效
      // this.student.hobby[0] = "play";
      // 解决
      this.student.hobby.splice(0, 1, "paly");
    },
    deleteproperty() {
      // 同样在vue2环境下，页面不能够及时响应
      // delete this.student.sex;
      // 解决办法
      this.$delete(this.student, "sex");
    },
  },
};
</script>

<style></style>

```



**2. 组件编写方式（代码组织方式的变化）**



| **特性**       | **Vue2**                                                     | **Vue3**                                                     |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **API 风格**   | **选项式 API (Options API)**：将逻辑分散到不同的选项中（`data`、`methods`、`computed`、`watch` 等） 。 | **组合式 API (Composition API)**：通过 `setup` 函数，将同一功能的逻辑集中写在一起 。 |
| **逻辑复用**   | 主要通过 `Mixins` 实现，容易造成命名冲突和数据来源不清晰。   | 通过自定义 **`Hooks`** (例如：`useMousePosition`) 实现，逻辑清晰，类型推导友好（配合 TypeScript 6）。 |
| **TypeScript** | 对 TS 支持不友好，需要额外的装饰器或工具。                   | 对 TS 支持是**原生**的， Composition API 更容易进行类型推导 7。 |



**组合式 API (Composition API) 的优势：** 提高了大型项目逻辑的可读性、可维护性和复用性，特别适合复杂组件的开发 8。





**3. 性能优化与打包体积**



| **特性**     | **Vue2**                          | **Vue3**                                                     |
| ------------ | --------------------------------- | ------------------------------------------------------------ |
| **编译优化** | 缺少静态提升，全量虚拟 DOM 比对。 | **静态提升 (Static Hoisting)** 和 **块级 (Block Tree) 优化**。 |
| **虚拟 DOM** | 全量遍历比对 VDOM 树。            | 编译时标记静态内容，运行时只比对**动态**部分，减少了不必要的比对，提升了渲染性能。 |
| **打包体积** | 难以进行彻底的 **Tree-shaking**。 | 许多内部模块（如 `Transition`、`KeepAlive`）是按需导入的，配合 Composition API，能实现更彻底的 Tree-shaking，减小打包体积。 |





**总结**

1. **响应式系统**：

   - **Vue 2**：基于Object.defineProperty，无法自动检测**对象属性的添加/删除**和**数组索引变化**，需借助Vue.set/Vue.delete等特殊 API。
   - **Vue 3**：基于Proxy，**原生支持**对对象和数组的各种变化监听，无上述限制，性能更优。

2. **API 设计**：

   - **Vue 2 (Options API)**：按选项（data,methods等）组织代码，逻辑分散。复用代码使用 **Mixins**，容易引发命名冲突。
   - **Vue 3 (Composition API)**：按**逻辑功能**组织代码，相关代码集中，更利于维护和阅读。复用代码使用**自定义 Hook 函数**，清晰灵活，且**原生 TypeScript 支持极佳**。

3. **性能与编译器**：

   - Vue 3

      在编译阶段进行了大量优化：

     - **Tree-shaking**：未使用的 API 不会打包进最终产物，体积更小。
     - **Patch Flags**：编译时标记动态节点，Diff 算法时直接定位变化，大幅提升虚拟 DOM 比对效率。
     - **静态提升**：将静态节点缓存，跳过重复渲染。

   - 结果：Vue 3 在**打包体积、更新性能、内存占用**上均优于 Vue 2。

4. **新特性**：

   - **Vue 3** 新增了 **Teleport**（将组件渲染到指定DOM）、**Fragment**（支持多根节点模板）等特性，解决了常见开发痛点。

### 2.说说 Vue 的生命周期（含父子组件先后顺序）以及常见实践放在哪些钩子里。



<img src="./assets/image-20251023211022379.png" alt="image-20251023211022379" style="zoom:67%;" />

Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期

| 生命周期      | 描述                               |
| :------------ | :--------------------------------- |
| beforeCreate  | 组件实例被创建之初                 |
| created       | 组件实例已经完全创建               |
| beforeMount   | 组件挂载之前                       |
| mounted       | 组件挂载到实例上去之后             |
| beforeUpdate  | 组件数据发生变化，更新之前         |
| updated       | 组件数据更新之后                   |
| beforeDestroy | 组件实例销毁之前                   |
| destroyed     | 组件实例销毁之后                   |
| activated     | keep-alive 缓存的组件激活时        |
| deactivated   | keep-alive 缓存的组件停用时调用    |
| errorCaptured | 捕获一个来自子孙组件的错误时被调用 |

==**生命周期流程**==

**使用场景**

1. **创建阶段（Creation）**：初始化响应式数据和事件。
   - beforeCreate：实例刚创建，**数据data和事件methods还未初始化**。
   - created：**实例创建完成**。数据data已响应式化，事件methods已配置，**可在此发起异步请求**。**但未挂载，DOM 不存在**。
2. **挂载阶段（Mounting）**：将模板编译渲染成真实 DOM 并插入页面。
   - beforeMount：模板已编译，**但尚未将渲染内容挂载到页面上**。
   - mounted：**实例已挂载到页面**，真实 DOM 已生成并可访问，**可在此进行 DOM 操作或访问$refs**。
3. **更新阶段（Updating）**：当数据变化时，虚拟 DOM 重新渲染和打补丁。
   - beforeUpdate：数据发生变化，**但虚拟 DOM 尚未重新渲染**。
   - updated：数据更改导致虚拟 DOM 重新渲染和打补丁完成，**可在此操作更新后的 DOM**（但要谨慎，避免无限循环更新）。
4. **卸载阶段（Unmouting/Destruction）**：实例被销毁。
   - beforeUnmount(Vue 3) /beforeDestroy(Vue 2)：**实例即将被销毁**，此刻实例仍完全可用。
   - unmounted(Vue 3) /destroyed(Vue 2)：**实例已销毁**，所有指令被解绑，事件监听器被移除，子实例也被销毁。**在此进行最终的清理工作**（如清除定时器、取消事件总线监听）。

> **注意**：Vue 3 将beforeDestroy和destroyed重命名为beforeUnmount和unmounted，语义更准确。

**beforeCreate -> created**

- 初始化`vue`实例，进行数据观测

**created**

- 完成数据观测，属性与方法的运算，`watch`、`event`事件回调的配置
- 可调用`methods`中的方法，访问和修改data数据触发响应式渲染`dom`，可通过`computed`和`watch`完成数据计算
- 此时`vm.$el` 并没有被创建

**created -> beforeMount**

- 判断是否存在`el`选项，若不存在则停止编译，直到调用`vm.$mount(el)`才会继续编译
- 优先级：`render` > `template` > `outerHTML`
- `vm.el`获取到的是挂载`DOM`的

**beforeMount**

- 在此阶段可获取到`vm.el`
- 此阶段`vm.el`虽已完成DOM初始化，但并未挂载在`el`选项上

**beforeMount -> mounted**

- 此阶段`vm.el`完成挂载，`vm.$el`生成的`DOM`替换了`el`选项所对应的`DOM`

**mounted**

- `vm.el`已完成`DOM`的挂载与渲染，此刻打印`vm.$el`，发现之前的挂载点及内容已被替换成新的DOM

**beforeUpdate**

- 更新的数据必须是被渲染在模板上的（`el`、`template`、`render`之一）
- 此时`view`层还未更新
- 若在`beforeUpdate`中再次修改数据，不会再次触发更新方法

**updated**

- 完成`view`层的更新
- 若在`updated`中再次修改数据，会再次触发更新方法（`beforeUpdate`、`updated`）

**beforeDestroy**

- 实例被销毁前调用，此时实例属性与方法仍可访问

**destroyed**

- 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器
- 并不能清除DOM，仅仅销毁实例

==数据请求在created在mounted的区别==

`created`是在组件实例一旦创建完成的时候立刻调用，这时候页面`dom`节点并未生成；`mounted`是在页面`dom`节点渲染完毕之后就立刻执行的。触发时机上`created`是比`mounted`要更早的，两者的相同点：都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在`mounted`中的请求有可能导致页面闪动（因为此时页面`dom`结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在`created`生命周期当中。

==父子组件生命周期顺序==

这是一个高频面试点，顺序如下：

- **加载渲染过程**：
  父 beforeCreate->父 created->父 beforeMount-> **子 beforeCreate->子 created->子 beforeMount->子 mounted** ->父 mounted
- **更新过程**：
  父 beforeUpdate-> **子 beforeUpdate->子 updated** ->父 updated
- **销毁过程**：
  父 beforeUnmount-> **子 beforeUnmount->子 unmounted** ->父 unmounted

**规律**：父组件总会等待其内部的子组件完成后，自己才会完成。如同“父组件搭建好框架(beforeMount)，子组件进去装修完工(mounted)，父组件才算整体完工(mounted)”

==常见实践和钩子选择==

| 生命周期钩子                    | 常见实践与操作                                               |
| :------------------------------ | :----------------------------------------------------------- |
| **created**                     | **最常用**。进行**异步数据请求**（如调用 API）、初始化一些非响应式的数据。此时可访问data和methods，但无法操作 DOM。 |
| **mounted**                     | **操作 DOM**、使用$refs访问子组件或 DOM 元素、集成第三方库（如图表库、地图库）需要 DOM 的场景。 |
| **beforeUnmount/beforeDestroy** | **清理工作**。清除定时器 (clearInterval)、取消事件总线监听 ($off)、取消未完成的网络请求，防止内存泄漏。 |
| **updated**                     | **在数据更改后操作更新后的 DOM**。使用较少，需特别小心，因为任何数据修改都可能触发此钩子，容易导致无限更新循环。 |
| **activated/deactivated**       | （配合<keep-alive>使用）当组件被切换时，用于执行激活或停用的逻辑（如重新请求数据、暂停视频播放）。 |

### 3.Vue 的 MVVM 模式

1. **View（视图）**

视图是用户直接与之交互的部分，通常是 HTML 页面中的元素。它负责展示数据和接收用户的输入。在 Vue 中，视图通过模板语法（如 `{{ }}` 和 `v-bind`）来展示数据，通过事件监听（如 `v-on`）来响应用户的操作。

2. **Model（模型）**

模型是应用程序的数据存储部分。它包含了应用程序需要处理的所有数据。在 Vue 中，模型通常是 Vue 实例的 `data` 属性中定义的数据对象。模型中的数据可以是简单的变量，也可以是复杂的对象。

3. **ViewModel（视图模型）**

视图模型是连接视图和模型的桥梁。它负责监听模型中的数据变化，并将这些变化同步到视图上；同时，它也负责将视图中的用户操作（如输入框的值变化）同步到模型中。Vue 的核心功能之一就是实现了这个视图模型的自动化。

4. **`v-model` 的作用**

`v-model` 是 Vue 中实现双向数据绑定的重要指令，它是视图模型（ViewModel）的一个重要手段。通过 `v-model`，Vue 实现了视图和模型之间的自动同步。



**总结**

- **View（视图）**：展示数据和接收用户输入。
- **Model（模型）**：存储和管理数据。
- **ViewModel（视图模型）**：通过 `v-model` 等机制实现视图和模型之间的双向数据绑定，确保它们之间的数据同步。

